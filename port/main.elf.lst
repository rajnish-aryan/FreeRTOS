
main.elf:     file format elf32-littlearm


Disassembly of section .text:

00000000 <vector_table>:
       0:	20001ffc 	strdcs	r1, [r0], -ip
       4:	00000199 	muleq	r0, r9, r1
	...

00000198 <reset_handler>:

    .section .text
    .align 1
    .type reset_handler, %function
reset_handler:
    b start
     198:	e000      	b.n	19c <start>
    b .
     19a:	e7fe      	b.n	19a <reset_handler+0x2>

0000019c <start>:
#include "FreeRTOS.h"
#include "task.h"

void start()
{
     19c:	b580      	push	{r7, lr}
     19e:	af00      	add	r7, sp, #0
    vTaskStartScheduler();
     1a0:	f000 f9ce 	bl	540 <vTaskStartScheduler>
    return;
     1a4:	bf00      	nop
     1a6:	bd80      	pop	{r7, pc}

000001a8 <memset>:
void* memset(void* dst, int value, unsigned int size) {
     1a8:	b480      	push	{r7}
     1aa:	b087      	sub	sp, #28
     1ac:	af00      	add	r7, sp, #0
     1ae:	60f8      	str	r0, [r7, #12]
     1b0:	60b9      	str	r1, [r7, #8]
     1b2:	607a      	str	r2, [r7, #4]
    unsigned char *ptr = (unsigned char *)dst;
     1b4:	68fb      	ldr	r3, [r7, #12]
     1b6:	617b      	str	r3, [r7, #20]
    unsigned char byte_value = (unsigned char)value;
     1b8:	68bb      	ldr	r3, [r7, #8]
     1ba:	74fb      	strb	r3, [r7, #19]

    // FIll memory byte by byte
    while(size > 0){
     1bc:	e008      	b.n	1d0 <memset+0x28>
        *ptr = byte_value;
     1be:	697b      	ldr	r3, [r7, #20]
     1c0:	7cfa      	ldrb	r2, [r7, #19]
     1c2:	701a      	strb	r2, [r3, #0]
        ptr++;
     1c4:	697b      	ldr	r3, [r7, #20]
     1c6:	3301      	adds	r3, #1
     1c8:	617b      	str	r3, [r7, #20]
        size--;
     1ca:	687b      	ldr	r3, [r7, #4]
     1cc:	3b01      	subs	r3, #1
     1ce:	607b      	str	r3, [r7, #4]
    while(size > 0){
     1d0:	687b      	ldr	r3, [r7, #4]
     1d2:	2b00      	cmp	r3, #0
     1d4:	d1f3      	bne.n	1be <memset+0x16>
    }

    return dst;
     1d6:	68fb      	ldr	r3, [r7, #12]
     1d8:	4618      	mov	r0, r3
     1da:	371c      	adds	r7, #28
     1dc:	46bd      	mov	sp, r7
     1de:	bc80      	pop	{r7}
     1e0:	4770      	bx	lr
	...

000001e4 <prvCreateTask>:
                                  const char * const pcName,
                                  const configSTACK_DEPTH_TYPE uxStackDepth,
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask )
    {
     1e4:	b580      	push	{r7, lr}
     1e6:	b08a      	sub	sp, #40	@ 0x28
     1e8:	af04      	add	r7, sp, #16
     1ea:	60f8      	str	r0, [r7, #12]
     1ec:	60b9      	str	r1, [r7, #8]
     1ee:	607a      	str	r2, [r7, #4]
     1f0:	603b      	str	r3, [r7, #0]

            /* Allocate space for the stack used by the task being created. */
            /* MISRA Ref 11.5.1 [Malloc memory assignment] */
            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
            /* coverity[misra_c_2012_rule_11_5_violation] */
            pxStack = pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) );
     1f2:	687b      	ldr	r3, [r7, #4]
     1f4:	009b      	lsls	r3, r3, #2
     1f6:	4618      	mov	r0, r3
     1f8:	f001 fd1a 	bl	1c30 <pvPortMalloc>
     1fc:	6138      	str	r0, [r7, #16]

            if( pxStack != NULL )
     1fe:	693b      	ldr	r3, [r7, #16]
     200:	2b00      	cmp	r3, #0
     202:	d013      	beq.n	22c <prvCreateTask+0x48>
            {
                /* Allocate space for the TCB. */
                /* MISRA Ref 11.5.1 [Malloc memory assignment] */
                /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
                /* coverity[misra_c_2012_rule_11_5_violation] */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     204:	204c      	movs	r0, #76	@ 0x4c
     206:	f001 fd13 	bl	1c30 <pvPortMalloc>
     20a:	6178      	str	r0, [r7, #20]

                if( pxNewTCB != NULL )
     20c:	697b      	ldr	r3, [r7, #20]
     20e:	2b00      	cmp	r3, #0
     210:	d008      	beq.n	224 <prvCreateTask+0x40>
                {
                    ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
     212:	224c      	movs	r2, #76	@ 0x4c
     214:	2100      	movs	r1, #0
     216:	6978      	ldr	r0, [r7, #20]
     218:	f7ff ffc6 	bl	1a8 <memset>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
     21c:	697b      	ldr	r3, [r7, #20]
     21e:	693a      	ldr	r2, [r7, #16]
     220:	631a      	str	r2, [r3, #48]	@ 0x30
     222:	e005      	b.n	230 <prvCreateTask+0x4c>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
     224:	6938      	ldr	r0, [r7, #16]
     226:	f001 fdb5 	bl	1d94 <vPortFree>
     22a:	e001      	b.n	230 <prvCreateTask+0x4c>
                }
            }
            else
            {
                pxNewTCB = NULL;
     22c:	2300      	movs	r3, #0
     22e:	617b      	str	r3, [r7, #20]
            }
        }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
     230:	697b      	ldr	r3, [r7, #20]
     232:	2b00      	cmp	r3, #0
     234:	d00d      	beq.n	252 <prvCreateTask+0x6e>
                 * task was created dynamically in case it is later deleted. */
                pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
            }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
     236:	2300      	movs	r3, #0
     238:	9303      	str	r3, [sp, #12]
     23a:	697b      	ldr	r3, [r7, #20]
     23c:	9302      	str	r3, [sp, #8]
     23e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
     240:	9301      	str	r3, [sp, #4]
     242:	6a3b      	ldr	r3, [r7, #32]
     244:	9300      	str	r3, [sp, #0]
     246:	683b      	ldr	r3, [r7, #0]
     248:	687a      	ldr	r2, [r7, #4]
     24a:	68b9      	ldr	r1, [r7, #8]
     24c:	68f8      	ldr	r0, [r7, #12]
     24e:	f000 f828 	bl	2a2 <prvInitialiseNewTask>
        }

        return pxNewTCB;
     252:	697b      	ldr	r3, [r7, #20]
    }
     254:	4618      	mov	r0, r3
     256:	3718      	adds	r7, #24
     258:	46bd      	mov	sp, r7
     25a:	bd80      	pop	{r7, pc}

0000025c <xTaskCreate>:
                            const char * const pcName,
                            const configSTACK_DEPTH_TYPE uxStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
     25c:	b580      	push	{r7, lr}
     25e:	b088      	sub	sp, #32
     260:	af02      	add	r7, sp, #8
     262:	60f8      	str	r0, [r7, #12]
     264:	60b9      	str	r1, [r7, #8]
     266:	607a      	str	r2, [r7, #4]
     268:	603b      	str	r3, [r7, #0]
        TCB_t * pxNewTCB;
        BaseType_t xReturn;

        traceENTER_xTaskCreate( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );

        pxNewTCB = prvCreateTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );
     26a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
     26c:	9301      	str	r3, [sp, #4]
     26e:	6a3b      	ldr	r3, [r7, #32]
     270:	9300      	str	r3, [sp, #0]
     272:	683b      	ldr	r3, [r7, #0]
     274:	687a      	ldr	r2, [r7, #4]
     276:	68b9      	ldr	r1, [r7, #8]
     278:	68f8      	ldr	r0, [r7, #12]
     27a:	f7ff ffb3 	bl	1e4 <prvCreateTask>
     27e:	6138      	str	r0, [r7, #16]

        if( pxNewTCB != NULL )
     280:	693b      	ldr	r3, [r7, #16]
     282:	2b00      	cmp	r3, #0
     284:	d005      	beq.n	292 <xTaskCreate+0x36>
                /* Set the task's affinity before scheduling it. */
                pxNewTCB->uxCoreAffinityMask = configTASK_DEFAULT_CORE_AFFINITY;
            }
            #endif

            prvAddNewTaskToReadyList( pxNewTCB );
     286:	6938      	ldr	r0, [r7, #16]
     288:	f000 f870 	bl	36c <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
     28c:	2301      	movs	r3, #1
     28e:	617b      	str	r3, [r7, #20]
     290:	e002      	b.n	298 <xTaskCreate+0x3c>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     292:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
     296:	617b      	str	r3, [r7, #20]
        }

        traceRETURN_xTaskCreate( xReturn );

        return xReturn;
     298:	697b      	ldr	r3, [r7, #20]
    }
     29a:	4618      	mov	r0, r3
     29c:	3718      	adds	r7, #24
     29e:	46bd      	mov	sp, r7
     2a0:	bd80      	pop	{r7, pc}

000002a2 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
     2a2:	b580      	push	{r7, lr}
     2a4:	b086      	sub	sp, #24
     2a6:	af00      	add	r7, sp, #0
     2a8:	60f8      	str	r0, [r7, #12]
     2aa:	60b9      	str	r1, [r7, #8]
     2ac:	607a      	str	r2, [r7, #4]
     2ae:	603b      	str	r3, [r7, #0]
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
    {
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
     2b0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     2b2:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
     2b4:	687b      	ldr	r3, [r7, #4]
     2b6:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
     2ba:	3b01      	subs	r3, #1
     2bc:	009b      	lsls	r3, r3, #2
     2be:	4413      	add	r3, r2
     2c0:	613b      	str	r3, [r7, #16]
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     2c2:	693b      	ldr	r3, [r7, #16]
     2c4:	f023 0307 	bic.w	r3, r3, #7
     2c8:	613b      	str	r3, [r7, #16]
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
     2ca:	68bb      	ldr	r3, [r7, #8]
     2cc:	2b00      	cmp	r3, #0
     2ce:	d01e      	beq.n	30e <prvInitialiseNewTask+0x6c>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     2d0:	2300      	movs	r3, #0
     2d2:	617b      	str	r3, [r7, #20]
     2d4:	e012      	b.n	2fc <prvInitialiseNewTask+0x5a>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     2d6:	68ba      	ldr	r2, [r7, #8]
     2d8:	697b      	ldr	r3, [r7, #20]
     2da:	4413      	add	r3, r2
     2dc:	7819      	ldrb	r1, [r3, #0]
     2de:	6aba      	ldr	r2, [r7, #40]	@ 0x28
     2e0:	697b      	ldr	r3, [r7, #20]
     2e2:	4413      	add	r3, r2
     2e4:	3334      	adds	r3, #52	@ 0x34
     2e6:	460a      	mov	r2, r1
     2e8:	701a      	strb	r2, [r3, #0]

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
     2ea:	68ba      	ldr	r2, [r7, #8]
     2ec:	697b      	ldr	r3, [r7, #20]
     2ee:	4413      	add	r3, r2
     2f0:	781b      	ldrb	r3, [r3, #0]
     2f2:	2b00      	cmp	r3, #0
     2f4:	d006      	beq.n	304 <prvInitialiseNewTask+0x62>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     2f6:	697b      	ldr	r3, [r7, #20]
     2f8:	3301      	adds	r3, #1
     2fa:	617b      	str	r3, [r7, #20]
     2fc:	697b      	ldr	r3, [r7, #20]
     2fe:	2b0f      	cmp	r3, #15
     300:	d9e9      	bls.n	2d6 <prvInitialiseNewTask+0x34>
     302:	e000      	b.n	306 <prvInitialiseNewTask+0x64>
            {
                break;
     304:	bf00      	nop
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1U ] = '\0';
     306:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     308:	2200      	movs	r2, #0
     30a:	f883 2043 	strb.w	r2, [r3, #67]	@ 0x43
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
     30e:	6a3b      	ldr	r3, [r7, #32]
     310:	2b04      	cmp	r3, #4
     312:	d901      	bls.n	318 <prvInitialiseNewTask+0x76>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
     314:	2304      	movs	r3, #4
     316:	623b      	str	r3, [r7, #32]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
     318:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     31a:	6a3a      	ldr	r2, [r7, #32]
     31c:	62da      	str	r2, [r3, #44]	@ 0x2c
    {
        pxNewTCB->uxBasePriority = uxPriority;
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     31e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     320:	3304      	adds	r3, #4
     322:	4618      	mov	r0, r3
     324:	f001 fbf3 	bl	1b0e <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     328:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     32a:	3318      	adds	r3, #24
     32c:	4618      	mov	r0, r3
     32e:	f001 fbee 	bl	1b0e <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     332:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     334:	6aba      	ldr	r2, [r7, #40]	@ 0x28
     336:	611a      	str	r2, [r3, #16]

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );
     338:	6a3b      	ldr	r3, [r7, #32]
     33a:	f1c3 0205 	rsb	r2, r3, #5
     33e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     340:	619a      	str	r2, [r3, #24]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     342:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     344:	6aba      	ldr	r2, [r7, #40]	@ 0x28
     346:	625a      	str	r2, [r3, #36]	@ 0x24
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     348:	683a      	ldr	r2, [r7, #0]
     34a:	68f9      	ldr	r1, [r7, #12]
     34c:	6938      	ldr	r0, [r7, #16]
     34e:	f001 fee3 	bl	2118 <pxPortInitialiseStack>
     352:	4602      	mov	r2, r0
     354:	6abb      	ldr	r3, [r7, #40]	@ 0x28
     356:	601a      	str	r2, [r3, #0]
            pxNewTCB->uxTaskAttributes |= taskATTRIBUTE_IS_IDLE;
        }
    }
    #endif /* #if ( configNUMBER_OF_CORES > 1 ) */

    if( pxCreatedTask != NULL )
     358:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
     35a:	2b00      	cmp	r3, #0
     35c:	d002      	beq.n	364 <prvInitialiseNewTask+0xc2>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     35e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
     360:	6aba      	ldr	r2, [r7, #40]	@ 0x28
     362:	601a      	str	r2, [r3, #0]
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
     364:	bf00      	nop
     366:	3718      	adds	r7, #24
     368:	46bd      	mov	sp, r7
     36a:	bd80      	pop	{r7, pc}

0000036c <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES == 1 )

    static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
    {
     36c:	b580      	push	{r7, lr}
     36e:	b084      	sub	sp, #16
     370:	af00      	add	r7, sp, #0
     372:	6078      	str	r0, [r7, #4]
        /* Ensure interrupts don't access the task lists while the lists are being
         * updated. */
        taskENTER_CRITICAL();
     374:	f001 ff6c 	bl	2250 <vPortEnterCritical>
        {
            uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );
     378:	4b3f      	ldr	r3, [pc, #252]	@ (478 <prvAddNewTaskToReadyList+0x10c>)
     37a:	681b      	ldr	r3, [r3, #0]
     37c:	3301      	adds	r3, #1
     37e:	4a3e      	ldr	r2, [pc, #248]	@ (478 <prvAddNewTaskToReadyList+0x10c>)
     380:	6013      	str	r3, [r2, #0]

            if( pxCurrentTCB == NULL )
     382:	4b3e      	ldr	r3, [pc, #248]	@ (47c <prvAddNewTaskToReadyList+0x110>)
     384:	681b      	ldr	r3, [r3, #0]
     386:	2b00      	cmp	r3, #0
     388:	d109      	bne.n	39e <prvAddNewTaskToReadyList+0x32>
            {
                /* There are no other tasks, or all the other tasks are in
                 * the suspended state - make this the current task. */
                pxCurrentTCB = pxNewTCB;
     38a:	4a3c      	ldr	r2, [pc, #240]	@ (47c <prvAddNewTaskToReadyList+0x110>)
     38c:	687b      	ldr	r3, [r7, #4]
     38e:	6013      	str	r3, [r2, #0]

                if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     390:	4b39      	ldr	r3, [pc, #228]	@ (478 <prvAddNewTaskToReadyList+0x10c>)
     392:	681b      	ldr	r3, [r3, #0]
     394:	2b01      	cmp	r3, #1
     396:	d110      	bne.n	3ba <prvAddNewTaskToReadyList+0x4e>
                {
                    /* This is the first task to be created so do the preliminary
                     * initialisation required.  We will not recover if this call
                     * fails, but we will report the failure. */
                    prvInitialiseTaskLists();
     398:	f000 fe12 	bl	fc0 <prvInitialiseTaskLists>
     39c:	e00d      	b.n	3ba <prvAddNewTaskToReadyList+0x4e>
            else
            {
                /* If the scheduler is not already running, make this task the
                 * current task if it is the highest priority task to be created
                 * so far. */
                if( xSchedulerRunning == pdFALSE )
     39e:	4b38      	ldr	r3, [pc, #224]	@ (480 <prvAddNewTaskToReadyList+0x114>)
     3a0:	681b      	ldr	r3, [r3, #0]
     3a2:	2b00      	cmp	r3, #0
     3a4:	d109      	bne.n	3ba <prvAddNewTaskToReadyList+0x4e>
                {
                    if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     3a6:	4b35      	ldr	r3, [pc, #212]	@ (47c <prvAddNewTaskToReadyList+0x110>)
     3a8:	681b      	ldr	r3, [r3, #0]
     3aa:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     3ac:	687b      	ldr	r3, [r7, #4]
     3ae:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     3b0:	429a      	cmp	r2, r3
     3b2:	d802      	bhi.n	3ba <prvAddNewTaskToReadyList+0x4e>
                    {
                        pxCurrentTCB = pxNewTCB;
     3b4:	4a31      	ldr	r2, [pc, #196]	@ (47c <prvAddNewTaskToReadyList+0x110>)
     3b6:	687b      	ldr	r3, [r7, #4]
     3b8:	6013      	str	r3, [r2, #0]
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            uxTaskNumber++;
     3ba:	4b32      	ldr	r3, [pc, #200]	@ (484 <prvAddNewTaskToReadyList+0x118>)
     3bc:	681b      	ldr	r3, [r3, #0]
     3be:	3301      	adds	r3, #1
     3c0:	4a30      	ldr	r2, [pc, #192]	@ (484 <prvAddNewTaskToReadyList+0x118>)
     3c2:	6013      	str	r3, [r2, #0]
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
            #endif /* configUSE_TRACE_FACILITY */
            traceTASK_CREATE( pxNewTCB );

            prvAddTaskToReadyList( pxNewTCB );
     3c4:	687b      	ldr	r3, [r7, #4]
     3c6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     3c8:	2201      	movs	r2, #1
     3ca:	409a      	lsls	r2, r3
     3cc:	4b2e      	ldr	r3, [pc, #184]	@ (488 <prvAddNewTaskToReadyList+0x11c>)
     3ce:	681b      	ldr	r3, [r3, #0]
     3d0:	4313      	orrs	r3, r2
     3d2:	4a2d      	ldr	r2, [pc, #180]	@ (488 <prvAddNewTaskToReadyList+0x11c>)
     3d4:	6013      	str	r3, [r2, #0]
     3d6:	687b      	ldr	r3, [r7, #4]
     3d8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     3da:	492c      	ldr	r1, [pc, #176]	@ (48c <prvAddNewTaskToReadyList+0x120>)
     3dc:	4613      	mov	r3, r2
     3de:	009b      	lsls	r3, r3, #2
     3e0:	4413      	add	r3, r2
     3e2:	009b      	lsls	r3, r3, #2
     3e4:	440b      	add	r3, r1
     3e6:	3304      	adds	r3, #4
     3e8:	681b      	ldr	r3, [r3, #0]
     3ea:	60fb      	str	r3, [r7, #12]
     3ec:	687b      	ldr	r3, [r7, #4]
     3ee:	68fa      	ldr	r2, [r7, #12]
     3f0:	609a      	str	r2, [r3, #8]
     3f2:	68fb      	ldr	r3, [r7, #12]
     3f4:	689a      	ldr	r2, [r3, #8]
     3f6:	687b      	ldr	r3, [r7, #4]
     3f8:	60da      	str	r2, [r3, #12]
     3fa:	68fb      	ldr	r3, [r7, #12]
     3fc:	689b      	ldr	r3, [r3, #8]
     3fe:	687a      	ldr	r2, [r7, #4]
     400:	3204      	adds	r2, #4
     402:	605a      	str	r2, [r3, #4]
     404:	687b      	ldr	r3, [r7, #4]
     406:	1d1a      	adds	r2, r3, #4
     408:	68fb      	ldr	r3, [r7, #12]
     40a:	609a      	str	r2, [r3, #8]
     40c:	687b      	ldr	r3, [r7, #4]
     40e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     410:	4613      	mov	r3, r2
     412:	009b      	lsls	r3, r3, #2
     414:	4413      	add	r3, r2
     416:	009b      	lsls	r3, r3, #2
     418:	4a1c      	ldr	r2, [pc, #112]	@ (48c <prvAddNewTaskToReadyList+0x120>)
     41a:	441a      	add	r2, r3
     41c:	687b      	ldr	r3, [r7, #4]
     41e:	615a      	str	r2, [r3, #20]
     420:	687b      	ldr	r3, [r7, #4]
     422:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     424:	4919      	ldr	r1, [pc, #100]	@ (48c <prvAddNewTaskToReadyList+0x120>)
     426:	4613      	mov	r3, r2
     428:	009b      	lsls	r3, r3, #2
     42a:	4413      	add	r3, r2
     42c:	009b      	lsls	r3, r3, #2
     42e:	440b      	add	r3, r1
     430:	681b      	ldr	r3, [r3, #0]
     432:	687a      	ldr	r2, [r7, #4]
     434:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
     436:	1c59      	adds	r1, r3, #1
     438:	4814      	ldr	r0, [pc, #80]	@ (48c <prvAddNewTaskToReadyList+0x120>)
     43a:	4613      	mov	r3, r2
     43c:	009b      	lsls	r3, r3, #2
     43e:	4413      	add	r3, r2
     440:	009b      	lsls	r3, r3, #2
     442:	4403      	add	r3, r0
     444:	6019      	str	r1, [r3, #0]

            portSETUP_TCB( pxNewTCB );
        }
        taskEXIT_CRITICAL();
     446:	f001 ff1d 	bl	2284 <vPortExitCritical>

        if( xSchedulerRunning != pdFALSE )
     44a:	4b0d      	ldr	r3, [pc, #52]	@ (480 <prvAddNewTaskToReadyList+0x114>)
     44c:	681b      	ldr	r3, [r3, #0]
     44e:	2b00      	cmp	r3, #0
     450:	d00e      	beq.n	470 <prvAddNewTaskToReadyList+0x104>
        {
            /* If the created task is of a higher priority than the current task
             * then it should run now. */
            taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
     452:	4b0a      	ldr	r3, [pc, #40]	@ (47c <prvAddNewTaskToReadyList+0x110>)
     454:	681b      	ldr	r3, [r3, #0]
     456:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     458:	687b      	ldr	r3, [r7, #4]
     45a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     45c:	429a      	cmp	r2, r3
     45e:	d207      	bcs.n	470 <prvAddNewTaskToReadyList+0x104>
     460:	4b0b      	ldr	r3, [pc, #44]	@ (490 <prvAddNewTaskToReadyList+0x124>)
     462:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
     466:	601a      	str	r2, [r3, #0]
     468:	f3bf 8f4f 	dsb	sy
     46c:	f3bf 8f6f 	isb	sy
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
     470:	bf00      	nop
     472:	3710      	adds	r7, #16
     474:	46bd      	mov	sp, r7
     476:	bd80      	pop	{r7, pc}
     478:	00002438 	andeq	r2, r0, r8, lsr r4
     47c:	0000238c 	andeq	r2, r0, ip, lsl #7
     480:	00002444 	andeq	r2, r0, r4, asr #8
     484:	00002454 	andeq	r2, r0, r4, asr r4
     488:	00002440 	andeq	r2, r0, r0, asr #8
     48c:	00002390 	muleq	r0, r0, r3
     490:	e000ed04 	and	lr, r0, r4, lsl #26

00000494 <prvCreateIdleTasks>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

static BaseType_t prvCreateIdleTasks( void )
{
     494:	b580      	push	{r7, lr}
     496:	b08a      	sub	sp, #40	@ 0x28
     498:	af02      	add	r7, sp, #8
    BaseType_t xReturn = pdPASS;
     49a:	2301      	movs	r3, #1
     49c:	61fb      	str	r3, [r7, #28]
    BaseType_t xCoreID;
    char cIdleName[ configMAX_TASK_NAME_LEN ] = { 0 };
     49e:	463b      	mov	r3, r7
     4a0:	2200      	movs	r2, #0
     4a2:	601a      	str	r2, [r3, #0]
     4a4:	605a      	str	r2, [r3, #4]
     4a6:	609a      	str	r2, [r3, #8]
     4a8:	60da      	str	r2, [r3, #12]
    TaskFunction_t pxIdleTaskFunction = NULL;
     4aa:	2300      	movs	r3, #0
     4ac:	613b      	str	r3, [r7, #16]
    UBaseType_t xIdleTaskNameIndex;

    /* MISRA Ref 14.3.1 [Configuration dependent invariant] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-143. */
    /* coverity[misra_c_2012_rule_14_3_violation] */
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
     4ae:	2300      	movs	r3, #0
     4b0:	617b      	str	r3, [r7, #20]
     4b2:	e011      	b.n	4d8 <prvCreateIdleTasks+0x44>
    {
        /* MISRA Ref 18.1.1 [Configuration dependent bounds checking] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-181. */
        /* coverity[misra_c_2012_rule_18_1_violation] */
        cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
     4b4:	4a1f      	ldr	r2, [pc, #124]	@ (534 <prvCreateIdleTasks+0xa0>)
     4b6:	697b      	ldr	r3, [r7, #20]
     4b8:	4413      	add	r3, r2
     4ba:	7819      	ldrb	r1, [r3, #0]
     4bc:	463a      	mov	r2, r7
     4be:	697b      	ldr	r3, [r7, #20]
     4c0:	4413      	add	r3, r2
     4c2:	460a      	mov	r2, r1
     4c4:	701a      	strb	r2, [r3, #0]

        if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
     4c6:	463a      	mov	r2, r7
     4c8:	697b      	ldr	r3, [r7, #20]
     4ca:	4413      	add	r3, r2
     4cc:	781b      	ldrb	r3, [r3, #0]
     4ce:	2b00      	cmp	r3, #0
     4d0:	d006      	beq.n	4e0 <prvCreateIdleTasks+0x4c>
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
     4d2:	697b      	ldr	r3, [r7, #20]
     4d4:	3301      	adds	r3, #1
     4d6:	617b      	str	r3, [r7, #20]
     4d8:	697b      	ldr	r3, [r7, #20]
     4da:	2b0e      	cmp	r3, #14
     4dc:	d9ea      	bls.n	4b4 <prvCreateIdleTasks+0x20>
     4de:	e000      	b.n	4e2 <prvCreateIdleTasks+0x4e>
        {
            break;
     4e0:	bf00      	nop
            mtCOVERAGE_TEST_MARKER();
        }
    }

    /* Ensure null termination. */
    cIdleName[ xIdleTaskNameIndex ] = '\0';
     4e2:	463a      	mov	r2, r7
     4e4:	697b      	ldr	r3, [r7, #20]
     4e6:	4413      	add	r3, r2
     4e8:	2200      	movs	r2, #0
     4ea:	701a      	strb	r2, [r3, #0]

    /* Add each idle task at the lowest priority. */
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
     4ec:	2300      	movs	r3, #0
     4ee:	61bb      	str	r3, [r7, #24]
     4f0:	e016      	b.n	520 <prvCreateIdleTasks+0x8c>
    {
        #if ( configNUMBER_OF_CORES == 1 )
        {
            pxIdleTaskFunction = &prvIdleTask;
     4f2:	4b11      	ldr	r3, [pc, #68]	@ (538 <prvCreateIdleTasks+0xa4>)
     4f4:	613b      	str	r3, [r7, #16]
            }
        }
        #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( pxIdleTaskFunction,
     4f6:	69bb      	ldr	r3, [r7, #24]
     4f8:	009b      	lsls	r3, r3, #2
     4fa:	4a10      	ldr	r2, [pc, #64]	@ (53c <prvCreateIdleTasks+0xa8>)
     4fc:	4413      	add	r3, r2
     4fe:	4639      	mov	r1, r7
     500:	9301      	str	r3, [sp, #4]
     502:	2300      	movs	r3, #0
     504:	9300      	str	r3, [sp, #0]
     506:	2300      	movs	r3, #0
     508:	f44f 7280 	mov.w	r2, #256	@ 0x100
     50c:	6938      	ldr	r0, [r7, #16]
     50e:	f7ff fea5 	bl	25c <xTaskCreate>
     512:	61f8      	str	r0, [r7, #28]
                                   &xIdleTaskHandles[ xCoreID ] );
        }
        #endif /* configSUPPORT_STATIC_ALLOCATION */

        /* Break the loop if any of the idle task is failed to be created. */
        if( xReturn != pdPASS )
     514:	69fb      	ldr	r3, [r7, #28]
     516:	2b01      	cmp	r3, #1
     518:	d106      	bne.n	528 <prvCreateIdleTasks+0x94>
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
     51a:	69bb      	ldr	r3, [r7, #24]
     51c:	3301      	adds	r3, #1
     51e:	61bb      	str	r3, [r7, #24]
     520:	69bb      	ldr	r3, [r7, #24]
     522:	2b00      	cmp	r3, #0
     524:	dde5      	ble.n	4f2 <prvCreateIdleTasks+0x5e>
     526:	e000      	b.n	52a <prvCreateIdleTasks+0x96>
        {
            break;
     528:	bf00      	nop
            }
            #endif
        }
    }

    return xReturn;
     52a:	69fb      	ldr	r3, [r7, #28]
}
     52c:	4618      	mov	r0, r3
     52e:	3720      	adds	r7, #32
     530:	46bd      	mov	sp, r7
     532:	bd80      	pop	{r7, pc}
     534:	0000237c 	andeq	r2, r0, ip, ror r3
     538:	00000f91 	muleq	r0, r1, pc	@ <UNPREDICTABLE>
     53c:	0000245c 	andeq	r2, r0, ip, asr r4

00000540 <vTaskStartScheduler>:

/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     540:	b580      	push	{r7, lr}
     542:	b082      	sub	sp, #8
     544:	af00      	add	r7, sp, #0
         * the number of bits as confNUMBER_OF_CORES. */
        configASSERT( ( sizeof( UBaseType_t ) * taskBITS_PER_BYTE ) >= configNUMBER_OF_CORES );
    }
    #endif /* #if ( configUSE_CORE_AFFINITY == 1 ) && ( configNUMBER_OF_CORES > 1 ) */

    xReturn = prvCreateIdleTasks();
     546:	f7ff ffa5 	bl	494 <prvCreateIdleTasks>
     54a:	6078      	str	r0, [r7, #4]
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
     54c:	687b      	ldr	r3, [r7, #4]
     54e:	2b01      	cmp	r3, #1
     550:	d115      	bne.n	57e <vTaskStartScheduler+0x3e>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
    uint32_t ulNewBASEPRI;

    __asm volatile
     552:	f04f 0301 	mov.w	r3, #1
     556:	f383 8811 	msr	BASEPRI, r3
     55a:	f3bf 8f6f 	isb	sy
     55e:	f3bf 8f4f 	dsb	sy
     562:	603b      	str	r3, [r7, #0]
        "   msr basepri, %0                                         \n" \
        "   isb                                                     \n" \
        "   dsb                                                     \n" \
        : "=r" ( ulNewBASEPRI ) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
    );
}
     564:	bf00      	nop
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
     566:	4b09      	ldr	r3, [pc, #36]	@ (58c <vTaskStartScheduler+0x4c>)
     568:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
     56c:	601a      	str	r2, [r3, #0]
        xSchedulerRunning = pdTRUE;
     56e:	4b08      	ldr	r3, [pc, #32]	@ (590 <vTaskStartScheduler+0x50>)
     570:	2201      	movs	r2, #1
     572:	601a      	str	r2, [r3, #0]
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     574:	4b07      	ldr	r3, [pc, #28]	@ (594 <vTaskStartScheduler+0x54>)
     576:	2200      	movs	r2, #0
     578:	601a      	str	r2, [r3, #0]
        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */

        /* The return value for xPortStartScheduler is not required
         * hence using a void datatype. */
        ( void ) xPortStartScheduler();
     57a:	f001 fe36 	bl	21ea <xPortStartScheduler>
     * meaning xIdleTaskHandles are not used anywhere else. */
    ( void ) xIdleTaskHandles;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
     57e:	4b06      	ldr	r3, [pc, #24]	@ (598 <vTaskStartScheduler+0x58>)
     580:	681b      	ldr	r3, [r3, #0]

    traceRETURN_vTaskStartScheduler();
}
     582:	bf00      	nop
     584:	3708      	adds	r7, #8
     586:	46bd      	mov	sp, r7
     588:	bd80      	pop	{r7, pc}
     58a:	bf00      	nop
     58c:	00002458 	andeq	r2, r0, r8, asr r4
     590:	00002444 	andeq	r2, r0, r4, asr #8
     594:	0000243c 	andeq	r2, r0, ip, lsr r4
     598:	00002378 	andeq	r2, r0, r8, ror r3

0000059c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
     59c:	b580      	push	{r7, lr}
     59e:	b082      	sub	sp, #8
     5a0:	af00      	add	r7, sp, #0
    __asm volatile
     5a2:	f04f 0301 	mov.w	r3, #1
     5a6:	f383 8811 	msr	BASEPRI, r3
     5aa:	f3bf 8f6f 	isb	sy
     5ae:	f3bf 8f4f 	dsb	sy
     5b2:	607b      	str	r3, [r7, #4]
}
     5b4:	bf00      	nop

    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    xSchedulerRunning = pdFALSE;
     5b6:	4b04      	ldr	r3, [pc, #16]	@ (5c8 <vTaskEndScheduler+0x2c>)
     5b8:	2200      	movs	r2, #0
     5ba:	601a      	str	r2, [r3, #0]

    /* This function must be called from a task and the application is
     * responsible for deleting that task after the scheduler is stopped. */
    vPortEndScheduler();
     5bc:	f001 fe42 	bl	2244 <vPortEndScheduler>

    traceRETURN_vTaskEndScheduler();
}
     5c0:	bf00      	nop
     5c2:	3708      	adds	r7, #8
     5c4:	46bd      	mov	sp, r7
     5c6:	bd80      	pop	{r7, pc}
     5c8:	00002444 	andeq	r2, r0, r4, asr #8

000005cc <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
     5cc:	b480      	push	{r7}
     5ce:	af00      	add	r7, sp, #0
         * do not otherwise exhibit real time behaviour. */
        portSOFTWARE_BARRIER();

        /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
         * is used to allow calls to vTaskSuspendAll() to nest. */
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
     5d0:	4b04      	ldr	r3, [pc, #16]	@ (5e4 <vTaskSuspendAll+0x18>)
     5d2:	681b      	ldr	r3, [r3, #0]
     5d4:	3301      	adds	r3, #1
     5d6:	4a03      	ldr	r2, [pc, #12]	@ (5e4 <vTaskSuspendAll+0x18>)
     5d8:	6013      	str	r3, [r2, #0]
        }
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    traceRETURN_vTaskSuspendAll();
}
     5da:	bf00      	nop
     5dc:	46bd      	mov	sp, r7
     5de:	bc80      	pop	{r7}
     5e0:	4770      	bx	lr
     5e2:	bf00      	nop
     5e4:	00002460 	andeq	r2, r0, r0, ror #8

000005e8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     5e8:	b580      	push	{r7, lr}
     5ea:	b088      	sub	sp, #32
     5ec:	af00      	add	r7, sp, #0
    TCB_t * pxTCB = NULL;
     5ee:	2300      	movs	r3, #0
     5f0:	61fb      	str	r3, [r7, #28]
    BaseType_t xAlreadyYielded = pdFALSE;
     5f2:	2300      	movs	r3, #0
     5f4:	61bb      	str	r3, [r7, #24]
        /* It is possible that an ISR caused a task to be removed from an event
         * list while the scheduler was suspended.  If this was the case then the
         * removed task will have been added to the xPendingReadyList.  Once the
         * scheduler has been resumed it is safe to move all the pending ready
         * tasks from this list into their appropriate ready list. */
        taskENTER_CRITICAL();
     5f6:	f001 fe2b 	bl	2250 <vPortEnterCritical>
        {
            const BaseType_t xCoreID = ( BaseType_t ) portGET_CORE_ID();
     5fa:	2300      	movs	r3, #0
     5fc:	613b      	str	r3, [r7, #16]

            /* If uxSchedulerSuspended is zero then this function does not match a
             * previous call to vTaskSuspendAll(). */
            configASSERT( uxSchedulerSuspended != 0U );

            uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended - 1U );
     5fe:	4b6d      	ldr	r3, [pc, #436]	@ (7b4 <xTaskResumeAll+0x1cc>)
     600:	681b      	ldr	r3, [r3, #0]
     602:	3b01      	subs	r3, #1
     604:	4a6b      	ldr	r2, [pc, #428]	@ (7b4 <xTaskResumeAll+0x1cc>)
     606:	6013      	str	r3, [r2, #0]
            portRELEASE_TASK_LOCK( xCoreID );

            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     608:	4b6a      	ldr	r3, [pc, #424]	@ (7b4 <xTaskResumeAll+0x1cc>)
     60a:	681b      	ldr	r3, [r3, #0]
     60c:	2b00      	cmp	r3, #0
     60e:	f040 80ca 	bne.w	7a6 <xTaskResumeAll+0x1be>
            {
                if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     612:	4b69      	ldr	r3, [pc, #420]	@ (7b8 <xTaskResumeAll+0x1d0>)
     614:	681b      	ldr	r3, [r3, #0]
     616:	2b00      	cmp	r3, #0
     618:	f000 80c5 	beq.w	7a6 <xTaskResumeAll+0x1be>
                {
                    /* Move any readied tasks from the pending list into the
                     * appropriate ready list. */
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     61c:	e08e      	b.n	73c <xTaskResumeAll+0x154>
                    {
                        /* MISRA Ref 11.5.3 [Void pointer assignment] */
                        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
                        /* coverity[misra_c_2012_rule_11_5_violation] */
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     61e:	4b67      	ldr	r3, [pc, #412]	@ (7bc <xTaskResumeAll+0x1d4>)
     620:	68db      	ldr	r3, [r3, #12]
     622:	68db      	ldr	r3, [r3, #12]
     624:	61fb      	str	r3, [r7, #28]
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
     626:	69fb      	ldr	r3, [r7, #28]
     628:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
     62a:	60fb      	str	r3, [r7, #12]
     62c:	69fb      	ldr	r3, [r7, #28]
     62e:	69db      	ldr	r3, [r3, #28]
     630:	69fa      	ldr	r2, [r7, #28]
     632:	6a12      	ldr	r2, [r2, #32]
     634:	609a      	str	r2, [r3, #8]
     636:	69fb      	ldr	r3, [r7, #28]
     638:	6a1b      	ldr	r3, [r3, #32]
     63a:	69fa      	ldr	r2, [r7, #28]
     63c:	69d2      	ldr	r2, [r2, #28]
     63e:	605a      	str	r2, [r3, #4]
     640:	68fb      	ldr	r3, [r7, #12]
     642:	685a      	ldr	r2, [r3, #4]
     644:	69fb      	ldr	r3, [r7, #28]
     646:	3318      	adds	r3, #24
     648:	429a      	cmp	r2, r3
     64a:	d103      	bne.n	654 <xTaskResumeAll+0x6c>
     64c:	69fb      	ldr	r3, [r7, #28]
     64e:	6a1a      	ldr	r2, [r3, #32]
     650:	68fb      	ldr	r3, [r7, #12]
     652:	605a      	str	r2, [r3, #4]
     654:	69fb      	ldr	r3, [r7, #28]
     656:	2200      	movs	r2, #0
     658:	629a      	str	r2, [r3, #40]	@ 0x28
     65a:	68fb      	ldr	r3, [r7, #12]
     65c:	681b      	ldr	r3, [r3, #0]
     65e:	1e5a      	subs	r2, r3, #1
     660:	68fb      	ldr	r3, [r7, #12]
     662:	601a      	str	r2, [r3, #0]
                        portMEMORY_BARRIER();
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
     664:	69fb      	ldr	r3, [r7, #28]
     666:	695b      	ldr	r3, [r3, #20]
     668:	60bb      	str	r3, [r7, #8]
     66a:	69fb      	ldr	r3, [r7, #28]
     66c:	689b      	ldr	r3, [r3, #8]
     66e:	69fa      	ldr	r2, [r7, #28]
     670:	68d2      	ldr	r2, [r2, #12]
     672:	609a      	str	r2, [r3, #8]
     674:	69fb      	ldr	r3, [r7, #28]
     676:	68db      	ldr	r3, [r3, #12]
     678:	69fa      	ldr	r2, [r7, #28]
     67a:	6892      	ldr	r2, [r2, #8]
     67c:	605a      	str	r2, [r3, #4]
     67e:	68bb      	ldr	r3, [r7, #8]
     680:	685a      	ldr	r2, [r3, #4]
     682:	69fb      	ldr	r3, [r7, #28]
     684:	3304      	adds	r3, #4
     686:	429a      	cmp	r2, r3
     688:	d103      	bne.n	692 <xTaskResumeAll+0xaa>
     68a:	69fb      	ldr	r3, [r7, #28]
     68c:	68da      	ldr	r2, [r3, #12]
     68e:	68bb      	ldr	r3, [r7, #8]
     690:	605a      	str	r2, [r3, #4]
     692:	69fb      	ldr	r3, [r7, #28]
     694:	2200      	movs	r2, #0
     696:	615a      	str	r2, [r3, #20]
     698:	68bb      	ldr	r3, [r7, #8]
     69a:	681b      	ldr	r3, [r3, #0]
     69c:	1e5a      	subs	r2, r3, #1
     69e:	68bb      	ldr	r3, [r7, #8]
     6a0:	601a      	str	r2, [r3, #0]
                        prvAddTaskToReadyList( pxTCB );
     6a2:	69fb      	ldr	r3, [r7, #28]
     6a4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     6a6:	2201      	movs	r2, #1
     6a8:	409a      	lsls	r2, r3
     6aa:	4b45      	ldr	r3, [pc, #276]	@ (7c0 <xTaskResumeAll+0x1d8>)
     6ac:	681b      	ldr	r3, [r3, #0]
     6ae:	4313      	orrs	r3, r2
     6b0:	4a43      	ldr	r2, [pc, #268]	@ (7c0 <xTaskResumeAll+0x1d8>)
     6b2:	6013      	str	r3, [r2, #0]
     6b4:	69fb      	ldr	r3, [r7, #28]
     6b6:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     6b8:	4942      	ldr	r1, [pc, #264]	@ (7c4 <xTaskResumeAll+0x1dc>)
     6ba:	4613      	mov	r3, r2
     6bc:	009b      	lsls	r3, r3, #2
     6be:	4413      	add	r3, r2
     6c0:	009b      	lsls	r3, r3, #2
     6c2:	440b      	add	r3, r1
     6c4:	3304      	adds	r3, #4
     6c6:	681b      	ldr	r3, [r3, #0]
     6c8:	607b      	str	r3, [r7, #4]
     6ca:	69fb      	ldr	r3, [r7, #28]
     6cc:	687a      	ldr	r2, [r7, #4]
     6ce:	609a      	str	r2, [r3, #8]
     6d0:	687b      	ldr	r3, [r7, #4]
     6d2:	689a      	ldr	r2, [r3, #8]
     6d4:	69fb      	ldr	r3, [r7, #28]
     6d6:	60da      	str	r2, [r3, #12]
     6d8:	687b      	ldr	r3, [r7, #4]
     6da:	689b      	ldr	r3, [r3, #8]
     6dc:	69fa      	ldr	r2, [r7, #28]
     6de:	3204      	adds	r2, #4
     6e0:	605a      	str	r2, [r3, #4]
     6e2:	69fb      	ldr	r3, [r7, #28]
     6e4:	1d1a      	adds	r2, r3, #4
     6e6:	687b      	ldr	r3, [r7, #4]
     6e8:	609a      	str	r2, [r3, #8]
     6ea:	69fb      	ldr	r3, [r7, #28]
     6ec:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     6ee:	4613      	mov	r3, r2
     6f0:	009b      	lsls	r3, r3, #2
     6f2:	4413      	add	r3, r2
     6f4:	009b      	lsls	r3, r3, #2
     6f6:	4a33      	ldr	r2, [pc, #204]	@ (7c4 <xTaskResumeAll+0x1dc>)
     6f8:	441a      	add	r2, r3
     6fa:	69fb      	ldr	r3, [r7, #28]
     6fc:	615a      	str	r2, [r3, #20]
     6fe:	69fb      	ldr	r3, [r7, #28]
     700:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     702:	4930      	ldr	r1, [pc, #192]	@ (7c4 <xTaskResumeAll+0x1dc>)
     704:	4613      	mov	r3, r2
     706:	009b      	lsls	r3, r3, #2
     708:	4413      	add	r3, r2
     70a:	009b      	lsls	r3, r3, #2
     70c:	440b      	add	r3, r1
     70e:	681b      	ldr	r3, [r3, #0]
     710:	69fa      	ldr	r2, [r7, #28]
     712:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
     714:	1c59      	adds	r1, r3, #1
     716:	482b      	ldr	r0, [pc, #172]	@ (7c4 <xTaskResumeAll+0x1dc>)
     718:	4613      	mov	r3, r2
     71a:	009b      	lsls	r3, r3, #2
     71c:	4413      	add	r3, r2
     71e:	009b      	lsls	r3, r3, #2
     720:	4403      	add	r3, r0
     722:	6019      	str	r1, [r3, #0]

                        #if ( configNUMBER_OF_CORES == 1 )
                        {
                            /* If the moved task has a priority higher than the current
                             * task then a yield must be performed. */
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     724:	69fb      	ldr	r3, [r7, #28]
     726:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     728:	4b27      	ldr	r3, [pc, #156]	@ (7c8 <xTaskResumeAll+0x1e0>)
     72a:	681b      	ldr	r3, [r3, #0]
     72c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     72e:	429a      	cmp	r2, r3
     730:	d904      	bls.n	73c <xTaskResumeAll+0x154>
                            {
                                xYieldPendings[ xCoreID ] = pdTRUE;
     732:	4a26      	ldr	r2, [pc, #152]	@ (7cc <xTaskResumeAll+0x1e4>)
     734:	693b      	ldr	r3, [r7, #16]
     736:	2101      	movs	r1, #1
     738:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     73c:	4b1f      	ldr	r3, [pc, #124]	@ (7bc <xTaskResumeAll+0x1d4>)
     73e:	681b      	ldr	r3, [r3, #0]
     740:	2b00      	cmp	r3, #0
     742:	f47f af6c 	bne.w	61e <xTaskResumeAll+0x36>
                             * which sets xYieldPendings for the current core to pdTRUE. */
                        }
                        #endif /* #if ( configNUMBER_OF_CORES == 1 ) */
                    }

                    if( pxTCB != NULL )
     746:	69fb      	ldr	r3, [r7, #28]
     748:	2b00      	cmp	r3, #0
     74a:	d001      	beq.n	750 <xTaskResumeAll+0x168>
                         * which may have prevented the next unblock time from being
                         * re-calculated, in which case re-calculate it now.  Mainly
                         * important for low power tickless implementations, where
                         * this can prevent an unnecessary exit from low power
                         * state. */
                        prvResetNextTaskUnblockTime();
     74c:	f000 fc74 	bl	1038 <prvResetNextTaskUnblockTime>
                     * It should be safe to call xTaskIncrementTick here from any core
                     * since we are in a critical section and xTaskIncrementTick itself
                     * protects itself within a critical section. Suspending the scheduler
                     * from any core causes xTaskIncrementTick to increment uxPendedCounts. */
                    {
                        TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
     750:	4b1f      	ldr	r3, [pc, #124]	@ (7d0 <xTaskResumeAll+0x1e8>)
     752:	681b      	ldr	r3, [r3, #0]
     754:	617b      	str	r3, [r7, #20]

                        if( xPendedCounts > ( TickType_t ) 0U )
     756:	697b      	ldr	r3, [r7, #20]
     758:	2b00      	cmp	r3, #0
     75a:	d012      	beq.n	782 <xTaskResumeAll+0x19a>
                        {
                            do
                            {
                                if( xTaskIncrementTick() != pdFALSE )
     75c:	f000 f894 	bl	888 <xTaskIncrementTick>
     760:	4603      	mov	r3, r0
     762:	2b00      	cmp	r3, #0
     764:	d004      	beq.n	770 <xTaskResumeAll+0x188>
                                {
                                    /* Other cores are interrupted from
                                     * within xTaskIncrementTick(). */
                                    xYieldPendings[ xCoreID ] = pdTRUE;
     766:	4a19      	ldr	r2, [pc, #100]	@ (7cc <xTaskResumeAll+0x1e4>)
     768:	693b      	ldr	r3, [r7, #16]
     76a:	2101      	movs	r1, #1
     76c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                else
                                {
                                    mtCOVERAGE_TEST_MARKER();
                                }

                                --xPendedCounts;
     770:	697b      	ldr	r3, [r7, #20]
     772:	3b01      	subs	r3, #1
     774:	617b      	str	r3, [r7, #20]
                            } while( xPendedCounts > ( TickType_t ) 0U );
     776:	697b      	ldr	r3, [r7, #20]
     778:	2b00      	cmp	r3, #0
     77a:	d1ef      	bne.n	75c <xTaskResumeAll+0x174>

                            xPendedTicks = 0;
     77c:	4b14      	ldr	r3, [pc, #80]	@ (7d0 <xTaskResumeAll+0x1e8>)
     77e:	2200      	movs	r2, #0
     780:	601a      	str	r2, [r3, #0]
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }

                    if( xYieldPendings[ xCoreID ] != pdFALSE )
     782:	4a12      	ldr	r2, [pc, #72]	@ (7cc <xTaskResumeAll+0x1e4>)
     784:	693b      	ldr	r3, [r7, #16]
     786:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
     78a:	2b00      	cmp	r3, #0
     78c:	d00b      	beq.n	7a6 <xTaskResumeAll+0x1be>
                    {
                        #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
     78e:	2301      	movs	r3, #1
     790:	61bb      	str	r3, [r7, #24]
                        }
                        #endif /* #if ( configUSE_PREEMPTION != 0 ) */

                        #if ( configNUMBER_OF_CORES == 1 )
                        {
                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
     792:	4b0d      	ldr	r3, [pc, #52]	@ (7c8 <xTaskResumeAll+0x1e0>)
     794:	681b      	ldr	r3, [r3, #0]
     796:	4b0f      	ldr	r3, [pc, #60]	@ (7d4 <xTaskResumeAll+0x1ec>)
     798:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
     79c:	601a      	str	r2, [r3, #0]
     79e:	f3bf 8f4f 	dsb	sy
     7a2:	f3bf 8f6f 	isb	sy
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
     7a6:	f001 fd6d 	bl	2284 <vPortExitCritical>
    }

    traceRETURN_xTaskResumeAll( xAlreadyYielded );

    return xAlreadyYielded;
     7aa:	69bb      	ldr	r3, [r7, #24]
}
     7ac:	4618      	mov	r0, r3
     7ae:	3720      	adds	r7, #32
     7b0:	46bd      	mov	sp, r7
     7b2:	bd80      	pop	{r7, pc}
     7b4:	00002460 	andeq	r2, r0, r0, ror #8
     7b8:	00002438 	andeq	r2, r0, r8, lsr r4
     7bc:	00002424 	andeq	r2, r0, r4, lsr #8
     7c0:	00002440 	andeq	r2, r0, r0, asr #8
     7c4:	00002390 	muleq	r0, r0, r3
     7c8:	0000238c 	andeq	r2, r0, ip, lsl #7
     7cc:	0000244c 	andeq	r2, r0, ip, asr #8
     7d0:	00002448 	andeq	r2, r0, r8, asr #8
     7d4:	e000ed04 	and	lr, r0, r4, lsl #26

000007d8 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
     7d8:	b480      	push	{r7}
     7da:	b083      	sub	sp, #12
     7dc:	af00      	add	r7, sp, #0
    traceENTER_xTaskGetTickCount();

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    {
        xTicks = xTickCount;
     7de:	4b04      	ldr	r3, [pc, #16]	@ (7f0 <xTaskGetTickCount+0x18>)
     7e0:	681b      	ldr	r3, [r3, #0]
     7e2:	607b      	str	r3, [r7, #4]
    }
    portTICK_TYPE_EXIT_CRITICAL();

    traceRETURN_xTaskGetTickCount( xTicks );

    return xTicks;
     7e4:	687b      	ldr	r3, [r7, #4]
}
     7e6:	4618      	mov	r0, r3
     7e8:	370c      	adds	r7, #12
     7ea:	46bd      	mov	sp, r7
     7ec:	bc80      	pop	{r7}
     7ee:	4770      	bx	lr
     7f0:	0000243c 	andeq	r2, r0, ip, lsr r4

000007f4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
     7f4:	b480      	push	{r7}
     7f6:	b083      	sub	sp, #12
     7f8:	af00      	add	r7, sp, #0
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
     7fa:	2300      	movs	r3, #0
     7fc:	607b      	str	r3, [r7, #4]
    {
        xReturn = xTickCount;
     7fe:	4b04      	ldr	r3, [pc, #16]	@ (810 <xTaskGetTickCountFromISR+0x1c>)
     800:	681b      	ldr	r3, [r3, #0]
     802:	603b      	str	r3, [r7, #0]
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    traceRETURN_xTaskGetTickCountFromISR( xReturn );

    return xReturn;
     804:	683b      	ldr	r3, [r7, #0]
}
     806:	4618      	mov	r0, r3
     808:	370c      	adds	r7, #12
     80a:	46bd      	mov	sp, r7
     80c:	bc80      	pop	{r7}
     80e:	4770      	bx	lr
     810:	0000243c 	andeq	r2, r0, ip, lsr r4

00000814 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
     814:	b480      	push	{r7}
     816:	af00      	add	r7, sp, #0

    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    traceRETURN_uxTaskGetNumberOfTasks( uxCurrentNumberOfTasks );

    return uxCurrentNumberOfTasks;
     818:	4b02      	ldr	r3, [pc, #8]	@ (824 <uxTaskGetNumberOfTasks+0x10>)
     81a:	681b      	ldr	r3, [r3, #0]
}
     81c:	4618      	mov	r0, r3
     81e:	46bd      	mov	sp, r7
     820:	bc80      	pop	{r7}
     822:	4770      	bx	lr
     824:	00002438 	andeq	r2, r0, r8, lsr r4

00000828 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery )
{
     828:	b480      	push	{r7}
     82a:	b085      	sub	sp, #20
     82c:	af00      	add	r7, sp, #0
     82e:	6078      	str	r0, [r7, #4]

    traceENTER_pcTaskGetName( xTaskToQuery );

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     830:	687b      	ldr	r3, [r7, #4]
     832:	2b00      	cmp	r3, #0
     834:	d102      	bne.n	83c <pcTaskGetName+0x14>
     836:	4b06      	ldr	r3, [pc, #24]	@ (850 <pcTaskGetName+0x28>)
     838:	681b      	ldr	r3, [r3, #0]
     83a:	e000      	b.n	83e <pcTaskGetName+0x16>
     83c:	687b      	ldr	r3, [r7, #4]
     83e:	60fb      	str	r3, [r7, #12]
    configASSERT( pxTCB != NULL );

    traceRETURN_pcTaskGetName( &( pxTCB->pcTaskName[ 0 ] ) );

    return &( pxTCB->pcTaskName[ 0 ] );
     840:	68fb      	ldr	r3, [r7, #12]
     842:	3334      	adds	r3, #52	@ 0x34
}
     844:	4618      	mov	r0, r3
     846:	3714      	adds	r7, #20
     848:	46bd      	mov	sp, r7
     84a:	bc80      	pop	{r7}
     84c:	4770      	bx	lr
     84e:	bf00      	nop
     850:	0000238c 	andeq	r2, r0, ip, lsl #7

00000854 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
     854:	b580      	push	{r7, lr}
     856:	b084      	sub	sp, #16
     858:	af00      	add	r7, sp, #0
     85a:	6078      	str	r0, [r7, #4]
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == ( UBaseType_t ) 0U );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
     85c:	f7ff feb6 	bl	5cc <vTaskSuspendAll>

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
     860:	f001 fcf6 	bl	2250 <vPortEnterCritical>
    {
        xPendedTicks += xTicksToCatchUp;
     864:	4b07      	ldr	r3, [pc, #28]	@ (884 <xTaskCatchUpTicks+0x30>)
     866:	681a      	ldr	r2, [r3, #0]
     868:	687b      	ldr	r3, [r7, #4]
     86a:	4413      	add	r3, r2
     86c:	4a05      	ldr	r2, [pc, #20]	@ (884 <xTaskCatchUpTicks+0x30>)
     86e:	6013      	str	r3, [r2, #0]
    }
    taskEXIT_CRITICAL();
     870:	f001 fd08 	bl	2284 <vPortExitCritical>
    xYieldOccurred = xTaskResumeAll();
     874:	f7ff feb8 	bl	5e8 <xTaskResumeAll>
     878:	60f8      	str	r0, [r7, #12]

    traceRETURN_xTaskCatchUpTicks( xYieldOccurred );

    return xYieldOccurred;
     87a:	68fb      	ldr	r3, [r7, #12]
}
     87c:	4618      	mov	r0, r3
     87e:	3710      	adds	r7, #16
     880:	46bd      	mov	sp, r7
     882:	bd80      	pop	{r7, pc}
     884:	00002448 	andeq	r2, r0, r8, asr #8

00000888 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     888:	b580      	push	{r7, lr}
     88a:	b088      	sub	sp, #32
     88c:	af00      	add	r7, sp, #0
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
     88e:	2300      	movs	r3, #0
     890:	61fb      	str	r3, [r7, #28]

    /* Tick increment should occur on every kernel timer event. Core 0 has the
     * responsibility to increment the tick, or increment the pended ticks if the
     * scheduler is suspended.  If pended ticks is greater than zero, the core that
     * calls xTaskResumeAll has the responsibility to increment the tick. */
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     892:	4b76      	ldr	r3, [pc, #472]	@ (a6c <xTaskIncrementTick+0x1e4>)
     894:	681b      	ldr	r3, [r3, #0]
     896:	2b00      	cmp	r3, #0
     898:	f040 80de 	bne.w	a58 <xTaskIncrementTick+0x1d0>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     89c:	4b74      	ldr	r3, [pc, #464]	@ (a70 <xTaskIncrementTick+0x1e8>)
     89e:	681b      	ldr	r3, [r3, #0]
     8a0:	3301      	adds	r3, #1
     8a2:	61bb      	str	r3, [r7, #24]

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
     8a4:	4a72      	ldr	r2, [pc, #456]	@ (a70 <xTaskIncrementTick+0x1e8>)
     8a6:	69bb      	ldr	r3, [r7, #24]
     8a8:	6013      	str	r3, [r2, #0]

        if( xConstTickCount == ( TickType_t ) 0U )
     8aa:	69bb      	ldr	r3, [r7, #24]
     8ac:	2b00      	cmp	r3, #0
     8ae:	d110      	bne.n	8d2 <xTaskIncrementTick+0x4a>
        {
            taskSWITCH_DELAYED_LISTS();
     8b0:	4b70      	ldr	r3, [pc, #448]	@ (a74 <xTaskIncrementTick+0x1ec>)
     8b2:	681b      	ldr	r3, [r3, #0]
     8b4:	617b      	str	r3, [r7, #20]
     8b6:	4b70      	ldr	r3, [pc, #448]	@ (a78 <xTaskIncrementTick+0x1f0>)
     8b8:	681b      	ldr	r3, [r3, #0]
     8ba:	4a6e      	ldr	r2, [pc, #440]	@ (a74 <xTaskIncrementTick+0x1ec>)
     8bc:	6013      	str	r3, [r2, #0]
     8be:	4a6e      	ldr	r2, [pc, #440]	@ (a78 <xTaskIncrementTick+0x1f0>)
     8c0:	697b      	ldr	r3, [r7, #20]
     8c2:	6013      	str	r3, [r2, #0]
     8c4:	4b6d      	ldr	r3, [pc, #436]	@ (a7c <xTaskIncrementTick+0x1f4>)
     8c6:	681b      	ldr	r3, [r3, #0]
     8c8:	3301      	adds	r3, #1
     8ca:	4a6c      	ldr	r2, [pc, #432]	@ (a7c <xTaskIncrementTick+0x1f4>)
     8cc:	6013      	str	r3, [r2, #0]
     8ce:	f000 fbb3 	bl	1038 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
     8d2:	4b6b      	ldr	r3, [pc, #428]	@ (a80 <xTaskIncrementTick+0x1f8>)
     8d4:	681b      	ldr	r3, [r3, #0]
     8d6:	69ba      	ldr	r2, [r7, #24]
     8d8:	429a      	cmp	r2, r3
     8da:	f0c0 80a8 	bcc.w	a2e <xTaskIncrementTick+0x1a6>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     8de:	4b65      	ldr	r3, [pc, #404]	@ (a74 <xTaskIncrementTick+0x1ec>)
     8e0:	681b      	ldr	r3, [r3, #0]
     8e2:	681b      	ldr	r3, [r3, #0]
     8e4:	2b00      	cmp	r3, #0
     8e6:	d104      	bne.n	8f2 <xTaskIncrementTick+0x6a>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY;
     8e8:	4b65      	ldr	r3, [pc, #404]	@ (a80 <xTaskIncrementTick+0x1f8>)
     8ea:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
     8ee:	601a      	str	r2, [r3, #0]
                    break;
     8f0:	e09d      	b.n	a2e <xTaskIncrementTick+0x1a6>
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    /* MISRA Ref 11.5.3 [Void pointer assignment] */
                    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
                    /* coverity[misra_c_2012_rule_11_5_violation] */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     8f2:	4b60      	ldr	r3, [pc, #384]	@ (a74 <xTaskIncrementTick+0x1ec>)
     8f4:	681b      	ldr	r3, [r3, #0]
     8f6:	68db      	ldr	r3, [r3, #12]
     8f8:	68db      	ldr	r3, [r3, #12]
     8fa:	613b      	str	r3, [r7, #16]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     8fc:	693b      	ldr	r3, [r7, #16]
     8fe:	685b      	ldr	r3, [r3, #4]
     900:	60fb      	str	r3, [r7, #12]

                    if( xConstTickCount < xItemValue )
     902:	69ba      	ldr	r2, [r7, #24]
     904:	68fb      	ldr	r3, [r7, #12]
     906:	429a      	cmp	r2, r3
     908:	d203      	bcs.n	912 <xTaskIncrementTick+0x8a>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
     90a:	4a5d      	ldr	r2, [pc, #372]	@ (a80 <xTaskIncrementTick+0x1f8>)
     90c:	68fb      	ldr	r3, [r7, #12]
     90e:	6013      	str	r3, [r2, #0]
                        break;
     910:	e08d      	b.n	a2e <xTaskIncrementTick+0x1a6>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
     912:	693b      	ldr	r3, [r7, #16]
     914:	695b      	ldr	r3, [r3, #20]
     916:	60bb      	str	r3, [r7, #8]
     918:	693b      	ldr	r3, [r7, #16]
     91a:	689b      	ldr	r3, [r3, #8]
     91c:	693a      	ldr	r2, [r7, #16]
     91e:	68d2      	ldr	r2, [r2, #12]
     920:	609a      	str	r2, [r3, #8]
     922:	693b      	ldr	r3, [r7, #16]
     924:	68db      	ldr	r3, [r3, #12]
     926:	693a      	ldr	r2, [r7, #16]
     928:	6892      	ldr	r2, [r2, #8]
     92a:	605a      	str	r2, [r3, #4]
     92c:	68bb      	ldr	r3, [r7, #8]
     92e:	685a      	ldr	r2, [r3, #4]
     930:	693b      	ldr	r3, [r7, #16]
     932:	3304      	adds	r3, #4
     934:	429a      	cmp	r2, r3
     936:	d103      	bne.n	940 <xTaskIncrementTick+0xb8>
     938:	693b      	ldr	r3, [r7, #16]
     93a:	68da      	ldr	r2, [r3, #12]
     93c:	68bb      	ldr	r3, [r7, #8]
     93e:	605a      	str	r2, [r3, #4]
     940:	693b      	ldr	r3, [r7, #16]
     942:	2200      	movs	r2, #0
     944:	615a      	str	r2, [r3, #20]
     946:	68bb      	ldr	r3, [r7, #8]
     948:	681b      	ldr	r3, [r3, #0]
     94a:	1e5a      	subs	r2, r3, #1
     94c:	68bb      	ldr	r3, [r7, #8]
     94e:	601a      	str	r2, [r3, #0]

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     950:	693b      	ldr	r3, [r7, #16]
     952:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
     954:	2b00      	cmp	r3, #0
     956:	d01e      	beq.n	996 <xTaskIncrementTick+0x10e>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
     958:	693b      	ldr	r3, [r7, #16]
     95a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
     95c:	607b      	str	r3, [r7, #4]
     95e:	693b      	ldr	r3, [r7, #16]
     960:	69db      	ldr	r3, [r3, #28]
     962:	693a      	ldr	r2, [r7, #16]
     964:	6a12      	ldr	r2, [r2, #32]
     966:	609a      	str	r2, [r3, #8]
     968:	693b      	ldr	r3, [r7, #16]
     96a:	6a1b      	ldr	r3, [r3, #32]
     96c:	693a      	ldr	r2, [r7, #16]
     96e:	69d2      	ldr	r2, [r2, #28]
     970:	605a      	str	r2, [r3, #4]
     972:	687b      	ldr	r3, [r7, #4]
     974:	685a      	ldr	r2, [r3, #4]
     976:	693b      	ldr	r3, [r7, #16]
     978:	3318      	adds	r3, #24
     97a:	429a      	cmp	r2, r3
     97c:	d103      	bne.n	986 <xTaskIncrementTick+0xfe>
     97e:	693b      	ldr	r3, [r7, #16]
     980:	6a1a      	ldr	r2, [r3, #32]
     982:	687b      	ldr	r3, [r7, #4]
     984:	605a      	str	r2, [r3, #4]
     986:	693b      	ldr	r3, [r7, #16]
     988:	2200      	movs	r2, #0
     98a:	629a      	str	r2, [r3, #40]	@ 0x28
     98c:	687b      	ldr	r3, [r7, #4]
     98e:	681b      	ldr	r3, [r3, #0]
     990:	1e5a      	subs	r2, r3, #1
     992:	687b      	ldr	r3, [r7, #4]
     994:	601a      	str	r2, [r3, #0]
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
     996:	693b      	ldr	r3, [r7, #16]
     998:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     99a:	2201      	movs	r2, #1
     99c:	409a      	lsls	r2, r3
     99e:	4b39      	ldr	r3, [pc, #228]	@ (a84 <xTaskIncrementTick+0x1fc>)
     9a0:	681b      	ldr	r3, [r3, #0]
     9a2:	4313      	orrs	r3, r2
     9a4:	4a37      	ldr	r2, [pc, #220]	@ (a84 <xTaskIncrementTick+0x1fc>)
     9a6:	6013      	str	r3, [r2, #0]
     9a8:	693b      	ldr	r3, [r7, #16]
     9aa:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     9ac:	4936      	ldr	r1, [pc, #216]	@ (a88 <xTaskIncrementTick+0x200>)
     9ae:	4613      	mov	r3, r2
     9b0:	009b      	lsls	r3, r3, #2
     9b2:	4413      	add	r3, r2
     9b4:	009b      	lsls	r3, r3, #2
     9b6:	440b      	add	r3, r1
     9b8:	3304      	adds	r3, #4
     9ba:	681b      	ldr	r3, [r3, #0]
     9bc:	603b      	str	r3, [r7, #0]
     9be:	693b      	ldr	r3, [r7, #16]
     9c0:	683a      	ldr	r2, [r7, #0]
     9c2:	609a      	str	r2, [r3, #8]
     9c4:	683b      	ldr	r3, [r7, #0]
     9c6:	689a      	ldr	r2, [r3, #8]
     9c8:	693b      	ldr	r3, [r7, #16]
     9ca:	60da      	str	r2, [r3, #12]
     9cc:	683b      	ldr	r3, [r7, #0]
     9ce:	689b      	ldr	r3, [r3, #8]
     9d0:	693a      	ldr	r2, [r7, #16]
     9d2:	3204      	adds	r2, #4
     9d4:	605a      	str	r2, [r3, #4]
     9d6:	693b      	ldr	r3, [r7, #16]
     9d8:	1d1a      	adds	r2, r3, #4
     9da:	683b      	ldr	r3, [r7, #0]
     9dc:	609a      	str	r2, [r3, #8]
     9de:	693b      	ldr	r3, [r7, #16]
     9e0:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     9e2:	4613      	mov	r3, r2
     9e4:	009b      	lsls	r3, r3, #2
     9e6:	4413      	add	r3, r2
     9e8:	009b      	lsls	r3, r3, #2
     9ea:	4a27      	ldr	r2, [pc, #156]	@ (a88 <xTaskIncrementTick+0x200>)
     9ec:	441a      	add	r2, r3
     9ee:	693b      	ldr	r3, [r7, #16]
     9f0:	615a      	str	r2, [r3, #20]
     9f2:	693b      	ldr	r3, [r7, #16]
     9f4:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     9f6:	4924      	ldr	r1, [pc, #144]	@ (a88 <xTaskIncrementTick+0x200>)
     9f8:	4613      	mov	r3, r2
     9fa:	009b      	lsls	r3, r3, #2
     9fc:	4413      	add	r3, r2
     9fe:	009b      	lsls	r3, r3, #2
     a00:	440b      	add	r3, r1
     a02:	681b      	ldr	r3, [r3, #0]
     a04:	693a      	ldr	r2, [r7, #16]
     a06:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
     a08:	1c59      	adds	r1, r3, #1
     a0a:	481f      	ldr	r0, [pc, #124]	@ (a88 <xTaskIncrementTick+0x200>)
     a0c:	4613      	mov	r3, r2
     a0e:	009b      	lsls	r3, r3, #2
     a10:	4413      	add	r3, r2
     a12:	009b      	lsls	r3, r3, #2
     a14:	4403      	add	r3, r0
     a16:	6019      	str	r1, [r3, #0]
                             * task.
                             * The case of equal priority tasks sharing
                             * processing time (which happens when both
                             * preemption and time slicing are on) is
                             * handled below.*/
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     a18:	693b      	ldr	r3, [r7, #16]
     a1a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     a1c:	4b1b      	ldr	r3, [pc, #108]	@ (a8c <xTaskIncrementTick+0x204>)
     a1e:	681b      	ldr	r3, [r3, #0]
     a20:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     a22:	429a      	cmp	r2, r3
     a24:	f67f af5b 	bls.w	8de <xTaskIncrementTick+0x56>
                            {
                                xSwitchRequired = pdTRUE;
     a28:	2301      	movs	r3, #1
     a2a:	61fb      	str	r3, [r7, #28]
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     a2c:	e757      	b.n	8de <xTaskIncrementTick+0x56>
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            #if ( configNUMBER_OF_CORES == 1 )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > 1U )
     a2e:	4b17      	ldr	r3, [pc, #92]	@ (a8c <xTaskIncrementTick+0x204>)
     a30:	681b      	ldr	r3, [r3, #0]
     a32:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     a34:	4914      	ldr	r1, [pc, #80]	@ (a88 <xTaskIncrementTick+0x200>)
     a36:	4613      	mov	r3, r2
     a38:	009b      	lsls	r3, r3, #2
     a3a:	4413      	add	r3, r2
     a3c:	009b      	lsls	r3, r3, #2
     a3e:	440b      	add	r3, r1
     a40:	681b      	ldr	r3, [r3, #0]
     a42:	2b01      	cmp	r3, #1
     a44:	d901      	bls.n	a4a <xTaskIncrementTick+0x1c2>
                {
                    xSwitchRequired = pdTRUE;
     a46:	2301      	movs	r3, #1
     a48:	61fb      	str	r3, [r7, #28]
        #if ( configUSE_PREEMPTION == 1 )
        {
            #if ( configNUMBER_OF_CORES == 1 )
            {
                /* For single core the core ID is always 0. */
                if( xYieldPendings[ 0 ] != pdFALSE )
     a4a:	4b11      	ldr	r3, [pc, #68]	@ (a90 <xTaskIncrementTick+0x208>)
     a4c:	681b      	ldr	r3, [r3, #0]
     a4e:	2b00      	cmp	r3, #0
     a50:	d007      	beq.n	a62 <xTaskIncrementTick+0x1da>
                {
                    xSwitchRequired = pdTRUE;
     a52:	2301      	movs	r3, #1
     a54:	61fb      	str	r3, [r7, #28]
     a56:	e004      	b.n	a62 <xTaskIncrementTick+0x1da>
        }
        #endif /* #if ( configUSE_PREEMPTION == 1 ) */
    }
    else
    {
        xPendedTicks += 1U;
     a58:	4b0e      	ldr	r3, [pc, #56]	@ (a94 <xTaskIncrementTick+0x20c>)
     a5a:	681b      	ldr	r3, [r3, #0]
     a5c:	3301      	adds	r3, #1
     a5e:	4a0d      	ldr	r2, [pc, #52]	@ (a94 <xTaskIncrementTick+0x20c>)
     a60:	6013      	str	r3, [r2, #0]
        #endif
    }

    traceRETURN_xTaskIncrementTick( xSwitchRequired );

    return xSwitchRequired;
     a62:	69fb      	ldr	r3, [r7, #28]
}
     a64:	4618      	mov	r0, r3
     a66:	3720      	adds	r7, #32
     a68:	46bd      	mov	sp, r7
     a6a:	bd80      	pop	{r7, pc}
     a6c:	00002460 	andeq	r2, r0, r0, ror #8
     a70:	0000243c 	andeq	r2, r0, ip, lsr r4
     a74:	0000241c 	andeq	r2, r0, ip, lsl r4
     a78:	00002420 	andeq	r2, r0, r0, lsr #8
     a7c:	00002450 	andeq	r2, r0, r0, asr r4
     a80:	00002458 	andeq	r2, r0, r8, asr r4
     a84:	00002440 	andeq	r2, r0, r0, asr #8
     a88:	00002390 	muleq	r0, r0, r3
     a8c:	0000238c 	andeq	r2, r0, ip, lsl #7
     a90:	0000244c 	andeq	r2, r0, ip, asr #8
     a94:	00002448 	andeq	r2, r0, r8, asr #8

00000a98 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

#if ( configNUMBER_OF_CORES == 1 )
    void vTaskSwitchContext( void )
    {
     a98:	b480      	push	{r7}
     a9a:	b085      	sub	sp, #20
     a9c:	af00      	add	r7, sp, #0
        traceENTER_vTaskSwitchContext();

        if( uxSchedulerSuspended != ( UBaseType_t ) 0U )
     a9e:	4b1c      	ldr	r3, [pc, #112]	@ (b10 <vTaskSwitchContext+0x78>)
     aa0:	681b      	ldr	r3, [r3, #0]
     aa2:	2b00      	cmp	r3, #0
     aa4:	d003      	beq.n	aae <vTaskSwitchContext+0x16>
        {
            /* The scheduler is currently suspended - do not allow a context
             * switch. */
            xYieldPendings[ 0 ] = pdTRUE;
     aa6:	4b1b      	ldr	r3, [pc, #108]	@ (b14 <vTaskSwitchContext+0x7c>)
     aa8:	2201      	movs	r2, #1
     aaa:	601a      	str	r2, [r3, #0]
            }
            #endif
        }

        traceRETURN_vTaskSwitchContext();
    }
     aac:	e02b      	b.n	b06 <vTaskSwitchContext+0x6e>
            xYieldPendings[ 0 ] = pdFALSE;
     aae:	4b19      	ldr	r3, [pc, #100]	@ (b14 <vTaskSwitchContext+0x7c>)
     ab0:	2200      	movs	r2, #0
     ab2:	601a      	str	r2, [r3, #0]
            taskSELECT_HIGHEST_PRIORITY_TASK();
     ab4:	4b18      	ldr	r3, [pc, #96]	@ (b18 <vTaskSwitchContext+0x80>)
     ab6:	681b      	ldr	r3, [r3, #0]
     ab8:	607b      	str	r3, [r7, #4]
        __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
     aba:	687b      	ldr	r3, [r7, #4]
     abc:	fab3 f383 	clz	r3, r3
     ac0:	70fb      	strb	r3, [r7, #3]
        return ucReturn;
     ac2:	78fb      	ldrb	r3, [r7, #3]
     ac4:	f1c3 031f 	rsb	r3, r3, #31
     ac8:	60fb      	str	r3, [r7, #12]
     aca:	68fa      	ldr	r2, [r7, #12]
     acc:	4613      	mov	r3, r2
     ace:	009b      	lsls	r3, r3, #2
     ad0:	4413      	add	r3, r2
     ad2:	009b      	lsls	r3, r3, #2
     ad4:	4a11      	ldr	r2, [pc, #68]	@ (b1c <vTaskSwitchContext+0x84>)
     ad6:	4413      	add	r3, r2
     ad8:	60bb      	str	r3, [r7, #8]
     ada:	68bb      	ldr	r3, [r7, #8]
     adc:	685b      	ldr	r3, [r3, #4]
     ade:	685a      	ldr	r2, [r3, #4]
     ae0:	68bb      	ldr	r3, [r7, #8]
     ae2:	605a      	str	r2, [r3, #4]
     ae4:	68bb      	ldr	r3, [r7, #8]
     ae6:	685a      	ldr	r2, [r3, #4]
     ae8:	68bb      	ldr	r3, [r7, #8]
     aea:	3308      	adds	r3, #8
     aec:	429a      	cmp	r2, r3
     aee:	d103      	bne.n	af8 <vTaskSwitchContext+0x60>
     af0:	68bb      	ldr	r3, [r7, #8]
     af2:	68da      	ldr	r2, [r3, #12]
     af4:	68bb      	ldr	r3, [r7, #8]
     af6:	605a      	str	r2, [r3, #4]
     af8:	68bb      	ldr	r3, [r7, #8]
     afa:	685b      	ldr	r3, [r3, #4]
     afc:	68db      	ldr	r3, [r3, #12]
     afe:	4a08      	ldr	r2, [pc, #32]	@ (b20 <vTaskSwitchContext+0x88>)
     b00:	6013      	str	r3, [r2, #0]
            portTASK_SWITCH_HOOK( pxCurrentTCB );
     b02:	4b07      	ldr	r3, [pc, #28]	@ (b20 <vTaskSwitchContext+0x88>)
     b04:	681b      	ldr	r3, [r3, #0]
    }
     b06:	bf00      	nop
     b08:	3714      	adds	r7, #20
     b0a:	46bd      	mov	sp, r7
     b0c:	bc80      	pop	{r7}
     b0e:	4770      	bx	lr
     b10:	00002460 	andeq	r2, r0, r0, ror #8
     b14:	0000244c 	andeq	r2, r0, ip, asr #8
     b18:	00002440 	andeq	r2, r0, r0, asr #8
     b1c:	00002390 	muleq	r0, r0, r3
     b20:	0000238c 	andeq	r2, r0, ip, lsl #7

00000b24 <vTaskPlaceOnEventList>:
#endif /* if ( configNUMBER_OF_CORES > 1 ) */
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
     b24:	b580      	push	{r7, lr}
     b26:	b082      	sub	sp, #8
     b28:	af00      	add	r7, sp, #0
     b2a:	6078      	str	r0, [r7, #4]
     b2c:	6039      	str	r1, [r7, #0]
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     b2e:	4b07      	ldr	r3, [pc, #28]	@ (b4c <vTaskPlaceOnEventList+0x28>)
     b30:	681b      	ldr	r3, [r3, #0]
     b32:	3318      	adds	r3, #24
     b34:	4619      	mov	r1, r3
     b36:	6878      	ldr	r0, [r7, #4]
     b38:	f001 f818 	bl	1b6c <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b3c:	2101      	movs	r1, #1
     b3e:	6838      	ldr	r0, [r7, #0]
     b40:	f000 ff26 	bl	1990 <prvAddCurrentTaskToDelayedList>

    traceRETURN_vTaskPlaceOnEventList();
}
     b44:	bf00      	nop
     b46:	3708      	adds	r7, #8
     b48:	46bd      	mov	sp, r7
     b4a:	bd80      	pop	{r7, pc}
     b4c:	0000238c 	andeq	r2, r0, ip, lsl #7

00000b50 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
     b50:	b580      	push	{r7, lr}
     b52:	b086      	sub	sp, #24
     b54:	af00      	add	r7, sp, #0
     b56:	60f8      	str	r0, [r7, #12]
     b58:	60b9      	str	r1, [r7, #8]
     b5a:	607a      	str	r2, [r7, #4]
    configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     b5c:	4b17      	ldr	r3, [pc, #92]	@ (bbc <vTaskPlaceOnUnorderedEventList+0x6c>)
     b5e:	681b      	ldr	r3, [r3, #0]
     b60:	68ba      	ldr	r2, [r7, #8]
     b62:	f042 4200 	orr.w	r2, r2, #2147483648	@ 0x80000000
     b66:	619a      	str	r2, [r3, #24]
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     b68:	68fb      	ldr	r3, [r7, #12]
     b6a:	685b      	ldr	r3, [r3, #4]
     b6c:	617b      	str	r3, [r7, #20]
     b6e:	4b13      	ldr	r3, [pc, #76]	@ (bbc <vTaskPlaceOnUnorderedEventList+0x6c>)
     b70:	681b      	ldr	r3, [r3, #0]
     b72:	697a      	ldr	r2, [r7, #20]
     b74:	61da      	str	r2, [r3, #28]
     b76:	4b11      	ldr	r3, [pc, #68]	@ (bbc <vTaskPlaceOnUnorderedEventList+0x6c>)
     b78:	681b      	ldr	r3, [r3, #0]
     b7a:	697a      	ldr	r2, [r7, #20]
     b7c:	6892      	ldr	r2, [r2, #8]
     b7e:	621a      	str	r2, [r3, #32]
     b80:	4b0e      	ldr	r3, [pc, #56]	@ (bbc <vTaskPlaceOnUnorderedEventList+0x6c>)
     b82:	681a      	ldr	r2, [r3, #0]
     b84:	697b      	ldr	r3, [r7, #20]
     b86:	689b      	ldr	r3, [r3, #8]
     b88:	3218      	adds	r2, #24
     b8a:	605a      	str	r2, [r3, #4]
     b8c:	4b0b      	ldr	r3, [pc, #44]	@ (bbc <vTaskPlaceOnUnorderedEventList+0x6c>)
     b8e:	681b      	ldr	r3, [r3, #0]
     b90:	f103 0218 	add.w	r2, r3, #24
     b94:	697b      	ldr	r3, [r7, #20]
     b96:	609a      	str	r2, [r3, #8]
     b98:	4b08      	ldr	r3, [pc, #32]	@ (bbc <vTaskPlaceOnUnorderedEventList+0x6c>)
     b9a:	681b      	ldr	r3, [r3, #0]
     b9c:	68fa      	ldr	r2, [r7, #12]
     b9e:	629a      	str	r2, [r3, #40]	@ 0x28
     ba0:	68fb      	ldr	r3, [r7, #12]
     ba2:	681b      	ldr	r3, [r3, #0]
     ba4:	1c5a      	adds	r2, r3, #1
     ba6:	68fb      	ldr	r3, [r7, #12]
     ba8:	601a      	str	r2, [r3, #0]

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     baa:	2101      	movs	r1, #1
     bac:	6878      	ldr	r0, [r7, #4]
     bae:	f000 feef 	bl	1990 <prvAddCurrentTaskToDelayedList>

    traceRETURN_vTaskPlaceOnUnorderedEventList();
}
     bb2:	bf00      	nop
     bb4:	3718      	adds	r7, #24
     bb6:	46bd      	mov	sp, r7
     bb8:	bd80      	pop	{r7, pc}
     bba:	bf00      	nop
     bbc:	0000238c 	andeq	r2, r0, ip, lsl #7

00000bc0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     bc0:	b480      	push	{r7}
     bc2:	b089      	sub	sp, #36	@ 0x24
     bc4:	af00      	add	r7, sp, #0
     bc6:	6078      	str	r0, [r7, #4]
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    /* MISRA Ref 11.5.3 [Void pointer assignment] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
    /* coverity[misra_c_2012_rule_11_5_violation] */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     bc8:	687b      	ldr	r3, [r7, #4]
     bca:	68db      	ldr	r3, [r3, #12]
     bcc:	68db      	ldr	r3, [r3, #12]
     bce:	61bb      	str	r3, [r7, #24]
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
     bd0:	69bb      	ldr	r3, [r7, #24]
     bd2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
     bd4:	617b      	str	r3, [r7, #20]
     bd6:	69bb      	ldr	r3, [r7, #24]
     bd8:	69db      	ldr	r3, [r3, #28]
     bda:	69ba      	ldr	r2, [r7, #24]
     bdc:	6a12      	ldr	r2, [r2, #32]
     bde:	609a      	str	r2, [r3, #8]
     be0:	69bb      	ldr	r3, [r7, #24]
     be2:	6a1b      	ldr	r3, [r3, #32]
     be4:	69ba      	ldr	r2, [r7, #24]
     be6:	69d2      	ldr	r2, [r2, #28]
     be8:	605a      	str	r2, [r3, #4]
     bea:	697b      	ldr	r3, [r7, #20]
     bec:	685a      	ldr	r2, [r3, #4]
     bee:	69bb      	ldr	r3, [r7, #24]
     bf0:	3318      	adds	r3, #24
     bf2:	429a      	cmp	r2, r3
     bf4:	d103      	bne.n	bfe <xTaskRemoveFromEventList+0x3e>
     bf6:	69bb      	ldr	r3, [r7, #24]
     bf8:	6a1a      	ldr	r2, [r3, #32]
     bfa:	697b      	ldr	r3, [r7, #20]
     bfc:	605a      	str	r2, [r3, #4]
     bfe:	69bb      	ldr	r3, [r7, #24]
     c00:	2200      	movs	r2, #0
     c02:	629a      	str	r2, [r3, #40]	@ 0x28
     c04:	697b      	ldr	r3, [r7, #20]
     c06:	681b      	ldr	r3, [r3, #0]
     c08:	1e5a      	subs	r2, r3, #1
     c0a:	697b      	ldr	r3, [r7, #20]
     c0c:	601a      	str	r2, [r3, #0]

    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     c0e:	4b4b      	ldr	r3, [pc, #300]	@ (d3c <xTaskRemoveFromEventList+0x17c>)
     c10:	681b      	ldr	r3, [r3, #0]
     c12:	2b00      	cmp	r3, #0
     c14:	d160      	bne.n	cd8 <xTaskRemoveFromEventList+0x118>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
     c16:	69bb      	ldr	r3, [r7, #24]
     c18:	695b      	ldr	r3, [r3, #20]
     c1a:	60fb      	str	r3, [r7, #12]
     c1c:	69bb      	ldr	r3, [r7, #24]
     c1e:	689b      	ldr	r3, [r3, #8]
     c20:	69ba      	ldr	r2, [r7, #24]
     c22:	68d2      	ldr	r2, [r2, #12]
     c24:	609a      	str	r2, [r3, #8]
     c26:	69bb      	ldr	r3, [r7, #24]
     c28:	68db      	ldr	r3, [r3, #12]
     c2a:	69ba      	ldr	r2, [r7, #24]
     c2c:	6892      	ldr	r2, [r2, #8]
     c2e:	605a      	str	r2, [r3, #4]
     c30:	68fb      	ldr	r3, [r7, #12]
     c32:	685a      	ldr	r2, [r3, #4]
     c34:	69bb      	ldr	r3, [r7, #24]
     c36:	3304      	adds	r3, #4
     c38:	429a      	cmp	r2, r3
     c3a:	d103      	bne.n	c44 <xTaskRemoveFromEventList+0x84>
     c3c:	69bb      	ldr	r3, [r7, #24]
     c3e:	68da      	ldr	r2, [r3, #12]
     c40:	68fb      	ldr	r3, [r7, #12]
     c42:	605a      	str	r2, [r3, #4]
     c44:	69bb      	ldr	r3, [r7, #24]
     c46:	2200      	movs	r2, #0
     c48:	615a      	str	r2, [r3, #20]
     c4a:	68fb      	ldr	r3, [r7, #12]
     c4c:	681b      	ldr	r3, [r3, #0]
     c4e:	1e5a      	subs	r2, r3, #1
     c50:	68fb      	ldr	r3, [r7, #12]
     c52:	601a      	str	r2, [r3, #0]
        prvAddTaskToReadyList( pxUnblockedTCB );
     c54:	69bb      	ldr	r3, [r7, #24]
     c56:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     c58:	2201      	movs	r2, #1
     c5a:	409a      	lsls	r2, r3
     c5c:	4b38      	ldr	r3, [pc, #224]	@ (d40 <xTaskRemoveFromEventList+0x180>)
     c5e:	681b      	ldr	r3, [r3, #0]
     c60:	4313      	orrs	r3, r2
     c62:	4a37      	ldr	r2, [pc, #220]	@ (d40 <xTaskRemoveFromEventList+0x180>)
     c64:	6013      	str	r3, [r2, #0]
     c66:	69bb      	ldr	r3, [r7, #24]
     c68:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     c6a:	4936      	ldr	r1, [pc, #216]	@ (d44 <xTaskRemoveFromEventList+0x184>)
     c6c:	4613      	mov	r3, r2
     c6e:	009b      	lsls	r3, r3, #2
     c70:	4413      	add	r3, r2
     c72:	009b      	lsls	r3, r3, #2
     c74:	440b      	add	r3, r1
     c76:	3304      	adds	r3, #4
     c78:	681b      	ldr	r3, [r3, #0]
     c7a:	60bb      	str	r3, [r7, #8]
     c7c:	69bb      	ldr	r3, [r7, #24]
     c7e:	68ba      	ldr	r2, [r7, #8]
     c80:	609a      	str	r2, [r3, #8]
     c82:	68bb      	ldr	r3, [r7, #8]
     c84:	689a      	ldr	r2, [r3, #8]
     c86:	69bb      	ldr	r3, [r7, #24]
     c88:	60da      	str	r2, [r3, #12]
     c8a:	68bb      	ldr	r3, [r7, #8]
     c8c:	689b      	ldr	r3, [r3, #8]
     c8e:	69ba      	ldr	r2, [r7, #24]
     c90:	3204      	adds	r2, #4
     c92:	605a      	str	r2, [r3, #4]
     c94:	69bb      	ldr	r3, [r7, #24]
     c96:	1d1a      	adds	r2, r3, #4
     c98:	68bb      	ldr	r3, [r7, #8]
     c9a:	609a      	str	r2, [r3, #8]
     c9c:	69bb      	ldr	r3, [r7, #24]
     c9e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     ca0:	4613      	mov	r3, r2
     ca2:	009b      	lsls	r3, r3, #2
     ca4:	4413      	add	r3, r2
     ca6:	009b      	lsls	r3, r3, #2
     ca8:	4a26      	ldr	r2, [pc, #152]	@ (d44 <xTaskRemoveFromEventList+0x184>)
     caa:	441a      	add	r2, r3
     cac:	69bb      	ldr	r3, [r7, #24]
     cae:	615a      	str	r2, [r3, #20]
     cb0:	69bb      	ldr	r3, [r7, #24]
     cb2:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     cb4:	4923      	ldr	r1, [pc, #140]	@ (d44 <xTaskRemoveFromEventList+0x184>)
     cb6:	4613      	mov	r3, r2
     cb8:	009b      	lsls	r3, r3, #2
     cba:	4413      	add	r3, r2
     cbc:	009b      	lsls	r3, r3, #2
     cbe:	440b      	add	r3, r1
     cc0:	681b      	ldr	r3, [r3, #0]
     cc2:	69ba      	ldr	r2, [r7, #24]
     cc4:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
     cc6:	1c59      	adds	r1, r3, #1
     cc8:	481e      	ldr	r0, [pc, #120]	@ (d44 <xTaskRemoveFromEventList+0x184>)
     cca:	4613      	mov	r3, r2
     ccc:	009b      	lsls	r3, r3, #2
     cce:	4413      	add	r3, r2
     cd0:	009b      	lsls	r3, r3, #2
     cd2:	4403      	add	r3, r0
     cd4:	6019      	str	r1, [r3, #0]
     cd6:	e01b      	b.n	d10 <xTaskRemoveFromEventList+0x150>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     cd8:	4b1b      	ldr	r3, [pc, #108]	@ (d48 <xTaskRemoveFromEventList+0x188>)
     cda:	685b      	ldr	r3, [r3, #4]
     cdc:	613b      	str	r3, [r7, #16]
     cde:	69bb      	ldr	r3, [r7, #24]
     ce0:	693a      	ldr	r2, [r7, #16]
     ce2:	61da      	str	r2, [r3, #28]
     ce4:	693b      	ldr	r3, [r7, #16]
     ce6:	689a      	ldr	r2, [r3, #8]
     ce8:	69bb      	ldr	r3, [r7, #24]
     cea:	621a      	str	r2, [r3, #32]
     cec:	693b      	ldr	r3, [r7, #16]
     cee:	689b      	ldr	r3, [r3, #8]
     cf0:	69ba      	ldr	r2, [r7, #24]
     cf2:	3218      	adds	r2, #24
     cf4:	605a      	str	r2, [r3, #4]
     cf6:	69bb      	ldr	r3, [r7, #24]
     cf8:	f103 0218 	add.w	r2, r3, #24
     cfc:	693b      	ldr	r3, [r7, #16]
     cfe:	609a      	str	r2, [r3, #8]
     d00:	69bb      	ldr	r3, [r7, #24]
     d02:	4a11      	ldr	r2, [pc, #68]	@ (d48 <xTaskRemoveFromEventList+0x188>)
     d04:	629a      	str	r2, [r3, #40]	@ 0x28
     d06:	4b10      	ldr	r3, [pc, #64]	@ (d48 <xTaskRemoveFromEventList+0x188>)
     d08:	681b      	ldr	r3, [r3, #0]
     d0a:	3301      	adds	r3, #1
     d0c:	4a0e      	ldr	r2, [pc, #56]	@ (d48 <xTaskRemoveFromEventList+0x188>)
     d0e:	6013      	str	r3, [r2, #0]
    }

    #if ( configNUMBER_OF_CORES == 1 )
    {
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     d10:	69bb      	ldr	r3, [r7, #24]
     d12:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     d14:	4b0d      	ldr	r3, [pc, #52]	@ (d4c <xTaskRemoveFromEventList+0x18c>)
     d16:	681b      	ldr	r3, [r3, #0]
     d18:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     d1a:	429a      	cmp	r2, r3
     d1c:	d905      	bls.n	d2a <xTaskRemoveFromEventList+0x16a>
        {
            /* Return true if the task removed from the event list has a higher
             * priority than the calling task.  This allows the calling task to know if
             * it should force a context switch now. */
            xReturn = pdTRUE;
     d1e:	2301      	movs	r3, #1
     d20:	61fb      	str	r3, [r7, #28]

            /* Mark that a yield is pending in case the user is not using the
             * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
            xYieldPendings[ 0 ] = pdTRUE;
     d22:	4b0b      	ldr	r3, [pc, #44]	@ (d50 <xTaskRemoveFromEventList+0x190>)
     d24:	2201      	movs	r2, #1
     d26:	601a      	str	r2, [r3, #0]
     d28:	e001      	b.n	d2e <xTaskRemoveFromEventList+0x16e>
        }
        else
        {
            xReturn = pdFALSE;
     d2a:	2300      	movs	r3, #0
     d2c:	61fb      	str	r3, [r7, #28]
        #endif /* #if ( configUSE_PREEMPTION == 1 ) */
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    traceRETURN_xTaskRemoveFromEventList( xReturn );
    return xReturn;
     d2e:	69fb      	ldr	r3, [r7, #28]
}
     d30:	4618      	mov	r0, r3
     d32:	3724      	adds	r7, #36	@ 0x24
     d34:	46bd      	mov	sp, r7
     d36:	bc80      	pop	{r7}
     d38:	4770      	bx	lr
     d3a:	bf00      	nop
     d3c:	00002460 	andeq	r2, r0, r0, ror #8
     d40:	00002440 	andeq	r2, r0, r0, asr #8
     d44:	00002390 	muleq	r0, r0, r3
     d48:	00002424 	andeq	r2, r0, r4, lsr #8
     d4c:	0000238c 	andeq	r2, r0, ip, lsl #7
     d50:	0000244c 	andeq	r2, r0, ip, asr #8

00000d54 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
     d54:	b480      	push	{r7}
     d56:	b087      	sub	sp, #28
     d58:	af00      	add	r7, sp, #0
     d5a:	6078      	str	r0, [r7, #4]
     d5c:	6039      	str	r1, [r7, #0]
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     d5e:	683b      	ldr	r3, [r7, #0]
     d60:	f043 4200 	orr.w	r2, r3, #2147483648	@ 0x80000000
     d64:	687b      	ldr	r3, [r7, #4]
     d66:	601a      	str	r2, [r3, #0]
    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    /* MISRA Ref 11.5.3 [Void pointer assignment] */
    /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
    /* coverity[misra_c_2012_rule_11_5_violation] */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem );
     d68:	687b      	ldr	r3, [r7, #4]
     d6a:	68db      	ldr	r3, [r3, #12]
     d6c:	617b      	str	r3, [r7, #20]
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
     d6e:	687b      	ldr	r3, [r7, #4]
     d70:	691b      	ldr	r3, [r3, #16]
     d72:	613b      	str	r3, [r7, #16]
     d74:	687b      	ldr	r3, [r7, #4]
     d76:	685b      	ldr	r3, [r3, #4]
     d78:	687a      	ldr	r2, [r7, #4]
     d7a:	6892      	ldr	r2, [r2, #8]
     d7c:	609a      	str	r2, [r3, #8]
     d7e:	687b      	ldr	r3, [r7, #4]
     d80:	689b      	ldr	r3, [r3, #8]
     d82:	687a      	ldr	r2, [r7, #4]
     d84:	6852      	ldr	r2, [r2, #4]
     d86:	605a      	str	r2, [r3, #4]
     d88:	693b      	ldr	r3, [r7, #16]
     d8a:	685b      	ldr	r3, [r3, #4]
     d8c:	687a      	ldr	r2, [r7, #4]
     d8e:	429a      	cmp	r2, r3
     d90:	d103      	bne.n	d9a <vTaskRemoveFromUnorderedEventList+0x46>
     d92:	687b      	ldr	r3, [r7, #4]
     d94:	689a      	ldr	r2, [r3, #8]
     d96:	693b      	ldr	r3, [r7, #16]
     d98:	605a      	str	r2, [r3, #4]
     d9a:	687b      	ldr	r3, [r7, #4]
     d9c:	2200      	movs	r2, #0
     d9e:	611a      	str	r2, [r3, #16]
     da0:	693b      	ldr	r3, [r7, #16]
     da2:	681b      	ldr	r3, [r3, #0]
     da4:	1e5a      	subs	r2, r3, #1
     da6:	693b      	ldr	r3, [r7, #16]
     da8:	601a      	str	r2, [r3, #0]
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
     daa:	697b      	ldr	r3, [r7, #20]
     dac:	695b      	ldr	r3, [r3, #20]
     dae:	60fb      	str	r3, [r7, #12]
     db0:	697b      	ldr	r3, [r7, #20]
     db2:	689b      	ldr	r3, [r3, #8]
     db4:	697a      	ldr	r2, [r7, #20]
     db6:	68d2      	ldr	r2, [r2, #12]
     db8:	609a      	str	r2, [r3, #8]
     dba:	697b      	ldr	r3, [r7, #20]
     dbc:	68db      	ldr	r3, [r3, #12]
     dbe:	697a      	ldr	r2, [r7, #20]
     dc0:	6892      	ldr	r2, [r2, #8]
     dc2:	605a      	str	r2, [r3, #4]
     dc4:	68fb      	ldr	r3, [r7, #12]
     dc6:	685a      	ldr	r2, [r3, #4]
     dc8:	697b      	ldr	r3, [r7, #20]
     dca:	3304      	adds	r3, #4
     dcc:	429a      	cmp	r2, r3
     dce:	d103      	bne.n	dd8 <vTaskRemoveFromUnorderedEventList+0x84>
     dd0:	697b      	ldr	r3, [r7, #20]
     dd2:	68da      	ldr	r2, [r3, #12]
     dd4:	68fb      	ldr	r3, [r7, #12]
     dd6:	605a      	str	r2, [r3, #4]
     dd8:	697b      	ldr	r3, [r7, #20]
     dda:	2200      	movs	r2, #0
     ddc:	615a      	str	r2, [r3, #20]
     dde:	68fb      	ldr	r3, [r7, #12]
     de0:	681b      	ldr	r3, [r3, #0]
     de2:	1e5a      	subs	r2, r3, #1
     de4:	68fb      	ldr	r3, [r7, #12]
     de6:	601a      	str	r2, [r3, #0]
    prvAddTaskToReadyList( pxUnblockedTCB );
     de8:	697b      	ldr	r3, [r7, #20]
     dea:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     dec:	2201      	movs	r2, #1
     dee:	409a      	lsls	r2, r3
     df0:	4b25      	ldr	r3, [pc, #148]	@ (e88 <vTaskRemoveFromUnorderedEventList+0x134>)
     df2:	681b      	ldr	r3, [r3, #0]
     df4:	4313      	orrs	r3, r2
     df6:	4a24      	ldr	r2, [pc, #144]	@ (e88 <vTaskRemoveFromUnorderedEventList+0x134>)
     df8:	6013      	str	r3, [r2, #0]
     dfa:	697b      	ldr	r3, [r7, #20]
     dfc:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     dfe:	4923      	ldr	r1, [pc, #140]	@ (e8c <vTaskRemoveFromUnorderedEventList+0x138>)
     e00:	4613      	mov	r3, r2
     e02:	009b      	lsls	r3, r3, #2
     e04:	4413      	add	r3, r2
     e06:	009b      	lsls	r3, r3, #2
     e08:	440b      	add	r3, r1
     e0a:	3304      	adds	r3, #4
     e0c:	681b      	ldr	r3, [r3, #0]
     e0e:	60bb      	str	r3, [r7, #8]
     e10:	697b      	ldr	r3, [r7, #20]
     e12:	68ba      	ldr	r2, [r7, #8]
     e14:	609a      	str	r2, [r3, #8]
     e16:	68bb      	ldr	r3, [r7, #8]
     e18:	689a      	ldr	r2, [r3, #8]
     e1a:	697b      	ldr	r3, [r7, #20]
     e1c:	60da      	str	r2, [r3, #12]
     e1e:	68bb      	ldr	r3, [r7, #8]
     e20:	689b      	ldr	r3, [r3, #8]
     e22:	697a      	ldr	r2, [r7, #20]
     e24:	3204      	adds	r2, #4
     e26:	605a      	str	r2, [r3, #4]
     e28:	697b      	ldr	r3, [r7, #20]
     e2a:	1d1a      	adds	r2, r3, #4
     e2c:	68bb      	ldr	r3, [r7, #8]
     e2e:	609a      	str	r2, [r3, #8]
     e30:	697b      	ldr	r3, [r7, #20]
     e32:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     e34:	4613      	mov	r3, r2
     e36:	009b      	lsls	r3, r3, #2
     e38:	4413      	add	r3, r2
     e3a:	009b      	lsls	r3, r3, #2
     e3c:	4a13      	ldr	r2, [pc, #76]	@ (e8c <vTaskRemoveFromUnorderedEventList+0x138>)
     e3e:	441a      	add	r2, r3
     e40:	697b      	ldr	r3, [r7, #20]
     e42:	615a      	str	r2, [r3, #20]
     e44:	697b      	ldr	r3, [r7, #20]
     e46:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     e48:	4910      	ldr	r1, [pc, #64]	@ (e8c <vTaskRemoveFromUnorderedEventList+0x138>)
     e4a:	4613      	mov	r3, r2
     e4c:	009b      	lsls	r3, r3, #2
     e4e:	4413      	add	r3, r2
     e50:	009b      	lsls	r3, r3, #2
     e52:	440b      	add	r3, r1
     e54:	681b      	ldr	r3, [r3, #0]
     e56:	697a      	ldr	r2, [r7, #20]
     e58:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
     e5a:	1c59      	adds	r1, r3, #1
     e5c:	480b      	ldr	r0, [pc, #44]	@ (e8c <vTaskRemoveFromUnorderedEventList+0x138>)
     e5e:	4613      	mov	r3, r2
     e60:	009b      	lsls	r3, r3, #2
     e62:	4413      	add	r3, r2
     e64:	009b      	lsls	r3, r3, #2
     e66:	4403      	add	r3, r0
     e68:	6019      	str	r1, [r3, #0]

    #if ( configNUMBER_OF_CORES == 1 )
    {
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     e6a:	697b      	ldr	r3, [r7, #20]
     e6c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
     e6e:	4b08      	ldr	r3, [pc, #32]	@ (e90 <vTaskRemoveFromUnorderedEventList+0x13c>)
     e70:	681b      	ldr	r3, [r3, #0]
     e72:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
     e74:	429a      	cmp	r2, r3
     e76:	d902      	bls.n	e7e <vTaskRemoveFromUnorderedEventList+0x12a>
        {
            /* The unblocked task has a priority above that of the calling task, so
             * a context switch is required.  This function is called with the
             * scheduler suspended so xYieldPending is set so the context switch
             * occurs immediately that the scheduler is resumed (unsuspended). */
            xYieldPendings[ 0 ] = pdTRUE;
     e78:	4b06      	ldr	r3, [pc, #24]	@ (e94 <vTaskRemoveFromUnorderedEventList+0x140>)
     e7a:	2201      	movs	r2, #1
     e7c:	601a      	str	r2, [r3, #0]
        #endif
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    traceRETURN_vTaskRemoveFromUnorderedEventList();
}
     e7e:	bf00      	nop
     e80:	371c      	adds	r7, #28
     e82:	46bd      	mov	sp, r7
     e84:	bc80      	pop	{r7}
     e86:	4770      	bx	lr
     e88:	00002440 	andeq	r2, r0, r0, asr #8
     e8c:	00002390 	muleq	r0, r0, r3
     e90:	0000238c 	andeq	r2, r0, ip, lsl #7
     e94:	0000244c 	andeq	r2, r0, ip, asr #8

00000e98 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
     e98:	b580      	push	{r7, lr}
     e9a:	b082      	sub	sp, #8
     e9c:	af00      	add	r7, sp, #0
     e9e:	6078      	str	r0, [r7, #4]
    traceENTER_vTaskSetTimeOutState( pxTimeOut );

    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
     ea0:	f001 f9d6 	bl	2250 <vPortEnterCritical>
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
     ea4:	4b06      	ldr	r3, [pc, #24]	@ (ec0 <vTaskSetTimeOutState+0x28>)
     ea6:	681a      	ldr	r2, [r3, #0]
     ea8:	687b      	ldr	r3, [r7, #4]
     eaa:	601a      	str	r2, [r3, #0]
        pxTimeOut->xTimeOnEntering = xTickCount;
     eac:	4b05      	ldr	r3, [pc, #20]	@ (ec4 <vTaskSetTimeOutState+0x2c>)
     eae:	681a      	ldr	r2, [r3, #0]
     eb0:	687b      	ldr	r3, [r7, #4]
     eb2:	605a      	str	r2, [r3, #4]
    }
    taskEXIT_CRITICAL();
     eb4:	f001 f9e6 	bl	2284 <vPortExitCritical>

    traceRETURN_vTaskSetTimeOutState();
}
     eb8:	bf00      	nop
     eba:	3708      	adds	r7, #8
     ebc:	46bd      	mov	sp, r7
     ebe:	bd80      	pop	{r7, pc}
     ec0:	00002450 	andeq	r2, r0, r0, asr r4
     ec4:	0000243c 	andeq	r2, r0, ip, lsr r4

00000ec8 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
     ec8:	b480      	push	{r7}
     eca:	b083      	sub	sp, #12
     ecc:	af00      	add	r7, sp, #0
     ece:	6078      	str	r0, [r7, #4]
    traceENTER_vTaskInternalSetTimeOutState( pxTimeOut );

    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
     ed0:	4b06      	ldr	r3, [pc, #24]	@ (eec <vTaskInternalSetTimeOutState+0x24>)
     ed2:	681a      	ldr	r2, [r3, #0]
     ed4:	687b      	ldr	r3, [r7, #4]
     ed6:	601a      	str	r2, [r3, #0]
    pxTimeOut->xTimeOnEntering = xTickCount;
     ed8:	4b05      	ldr	r3, [pc, #20]	@ (ef0 <vTaskInternalSetTimeOutState+0x28>)
     eda:	681a      	ldr	r2, [r3, #0]
     edc:	687b      	ldr	r3, [r7, #4]
     ede:	605a      	str	r2, [r3, #4]

    traceRETURN_vTaskInternalSetTimeOutState();
}
     ee0:	bf00      	nop
     ee2:	370c      	adds	r7, #12
     ee4:	46bd      	mov	sp, r7
     ee6:	bc80      	pop	{r7}
     ee8:	4770      	bx	lr
     eea:	bf00      	nop
     eec:	00002450 	andeq	r2, r0, r0, asr r4
     ef0:	0000243c 	andeq	r2, r0, ip, lsr r4

00000ef4 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
     ef4:	b580      	push	{r7, lr}
     ef6:	b086      	sub	sp, #24
     ef8:	af00      	add	r7, sp, #0
     efa:	6078      	str	r0, [r7, #4]
     efc:	6039      	str	r1, [r7, #0]
    traceENTER_xTaskCheckForTimeOut( pxTimeOut, pxTicksToWait );

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
     efe:	f001 f9a7 	bl	2250 <vPortEnterCritical>
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
     f02:	4b1b      	ldr	r3, [pc, #108]	@ (f70 <xTaskCheckForTimeOut+0x7c>)
     f04:	681b      	ldr	r3, [r3, #0]
     f06:	613b      	str	r3, [r7, #16]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     f08:	687b      	ldr	r3, [r7, #4]
     f0a:	685b      	ldr	r3, [r3, #4]
     f0c:	693a      	ldr	r2, [r7, #16]
     f0e:	1ad3      	subs	r3, r2, r3
     f10:	60fb      	str	r3, [r7, #12]
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) )
     f12:	687b      	ldr	r3, [r7, #4]
     f14:	681a      	ldr	r2, [r3, #0]
     f16:	4b17      	ldr	r3, [pc, #92]	@ (f74 <xTaskCheckForTimeOut+0x80>)
     f18:	681b      	ldr	r3, [r3, #0]
     f1a:	429a      	cmp	r2, r3
     f1c:	d00a      	beq.n	f34 <xTaskCheckForTimeOut+0x40>
     f1e:	687b      	ldr	r3, [r7, #4]
     f20:	685b      	ldr	r3, [r3, #4]
     f22:	693a      	ldr	r2, [r7, #16]
     f24:	429a      	cmp	r2, r3
     f26:	d305      	bcc.n	f34 <xTaskCheckForTimeOut+0x40>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
     f28:	2301      	movs	r3, #1
     f2a:	617b      	str	r3, [r7, #20]
            *pxTicksToWait = ( TickType_t ) 0;
     f2c:	683b      	ldr	r3, [r7, #0]
     f2e:	2200      	movs	r2, #0
     f30:	601a      	str	r2, [r3, #0]
     f32:	e015      	b.n	f60 <xTaskCheckForTimeOut+0x6c>
        }
        else if( xElapsedTime < *pxTicksToWait )
     f34:	683b      	ldr	r3, [r7, #0]
     f36:	681b      	ldr	r3, [r3, #0]
     f38:	68fa      	ldr	r2, [r7, #12]
     f3a:	429a      	cmp	r2, r3
     f3c:	d20b      	bcs.n	f56 <xTaskCheckForTimeOut+0x62>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
     f3e:	683b      	ldr	r3, [r7, #0]
     f40:	681a      	ldr	r2, [r3, #0]
     f42:	68fb      	ldr	r3, [r7, #12]
     f44:	1ad2      	subs	r2, r2, r3
     f46:	683b      	ldr	r3, [r7, #0]
     f48:	601a      	str	r2, [r3, #0]
            vTaskInternalSetTimeOutState( pxTimeOut );
     f4a:	6878      	ldr	r0, [r7, #4]
     f4c:	f7ff ffbc 	bl	ec8 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
     f50:	2300      	movs	r3, #0
     f52:	617b      	str	r3, [r7, #20]
     f54:	e004      	b.n	f60 <xTaskCheckForTimeOut+0x6c>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
     f56:	683b      	ldr	r3, [r7, #0]
     f58:	2200      	movs	r2, #0
     f5a:	601a      	str	r2, [r3, #0]
            xReturn = pdTRUE;
     f5c:	2301      	movs	r3, #1
     f5e:	617b      	str	r3, [r7, #20]
        }
    }
    taskEXIT_CRITICAL();
     f60:	f001 f990 	bl	2284 <vPortExitCritical>

    traceRETURN_xTaskCheckForTimeOut( xReturn );

    return xReturn;
     f64:	697b      	ldr	r3, [r7, #20]
}
     f66:	4618      	mov	r0, r3
     f68:	3718      	adds	r7, #24
     f6a:	46bd      	mov	sp, r7
     f6c:	bd80      	pop	{r7, pc}
     f6e:	bf00      	nop
     f70:	0000243c 	andeq	r2, r0, ip, lsr r4
     f74:	00002450 	andeq	r2, r0, r0, asr r4

00000f78 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
     f78:	b480      	push	{r7}
     f7a:	af00      	add	r7, sp, #0
    traceENTER_vTaskMissedYield();

    /* Must be called from within a critical section. */
    xYieldPendings[ portGET_CORE_ID() ] = pdTRUE;
     f7c:	4b03      	ldr	r3, [pc, #12]	@ (f8c <vTaskMissedYield+0x14>)
     f7e:	2201      	movs	r2, #1
     f80:	601a      	str	r2, [r3, #0]

    traceRETURN_vTaskMissedYield();
}
     f82:	bf00      	nop
     f84:	46bd      	mov	sp, r7
     f86:	bc80      	pop	{r7}
     f88:	4770      	bx	lr
     f8a:	bf00      	nop
     f8c:	0000244c 	andeq	r2, r0, ip, asr #8

00000f90 <prvIdleTask>:
 * void prvIdleTask( void *pvParameters );
 *
 */

static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
     f90:	b580      	push	{r7, lr}
     f92:	b082      	sub	sp, #8
     f94:	af00      	add	r7, sp, #0
     f96:	6078      	str	r0, [r7, #4]

    for( ; configCONTROL_INFINITE_LOOP(); )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
     f98:	f000 f848 	bl	102c <prvCheckTasksWaitingTermination>
             * A critical region is not required here as we are just reading from
             * the list, and an occasional incorrect value will not matter.  If
             * the ready list at the idle priority contains one more task than the
             * number of idle tasks, which is equal to the configured numbers of cores
             * then a task other than the idle task is ready to execute. */
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) configNUMBER_OF_CORES )
     f9c:	4b06      	ldr	r3, [pc, #24]	@ (fb8 <prvIdleTask+0x28>)
     f9e:	681b      	ldr	r3, [r3, #0]
     fa0:	2b01      	cmp	r3, #1
     fa2:	d9f9      	bls.n	f98 <prvIdleTask+0x8>
            {
                taskYIELD();
     fa4:	4b05      	ldr	r3, [pc, #20]	@ (fbc <prvIdleTask+0x2c>)
     fa6:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
     faa:	601a      	str	r2, [r3, #0]
     fac:	f3bf 8f4f 	dsb	sy
     fb0:	f3bf 8f6f 	isb	sy
        prvCheckTasksWaitingTermination();
     fb4:	e7f0      	b.n	f98 <prvIdleTask+0x8>
     fb6:	bf00      	nop
     fb8:	00002390 	muleq	r0, r0, r3
     fbc:	e000ed04 	and	lr, r0, r4, lsl #26

00000fc0 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
     fc0:	b580      	push	{r7, lr}
     fc2:	b082      	sub	sp, #8
     fc4:	af00      	add	r7, sp, #0
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
     fc6:	2300      	movs	r3, #0
     fc8:	607b      	str	r3, [r7, #4]
     fca:	e00c      	b.n	fe6 <prvInitialiseTaskLists+0x26>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     fcc:	687a      	ldr	r2, [r7, #4]
     fce:	4613      	mov	r3, r2
     fd0:	009b      	lsls	r3, r3, #2
     fd2:	4413      	add	r3, r2
     fd4:	009b      	lsls	r3, r3, #2
     fd6:	4a0f      	ldr	r2, [pc, #60]	@ (1014 <prvInitialiseTaskLists+0x54>)
     fd8:	4413      	add	r3, r2
     fda:	4618      	mov	r0, r3
     fdc:	f000 fd78 	bl	1ad0 <vListInitialise>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
     fe0:	687b      	ldr	r3, [r7, #4]
     fe2:	3301      	adds	r3, #1
     fe4:	607b      	str	r3, [r7, #4]
     fe6:	687b      	ldr	r3, [r7, #4]
     fe8:	2b04      	cmp	r3, #4
     fea:	d9ef      	bls.n	fcc <prvInitialiseTaskLists+0xc>
    }

    vListInitialise( &xDelayedTaskList1 );
     fec:	480a      	ldr	r0, [pc, #40]	@ (1018 <prvInitialiseTaskLists+0x58>)
     fee:	f000 fd6f 	bl	1ad0 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
     ff2:	480a      	ldr	r0, [pc, #40]	@ (101c <prvInitialiseTaskLists+0x5c>)
     ff4:	f000 fd6c 	bl	1ad0 <vListInitialise>
    vListInitialise( &xPendingReadyList );
     ff8:	4809      	ldr	r0, [pc, #36]	@ (1020 <prvInitialiseTaskLists+0x60>)
     ffa:	f000 fd69 	bl	1ad0 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
     ffe:	4b09      	ldr	r3, [pc, #36]	@ (1024 <prvInitialiseTaskLists+0x64>)
    1000:	4a05      	ldr	r2, [pc, #20]	@ (1018 <prvInitialiseTaskLists+0x58>)
    1002:	601a      	str	r2, [r3, #0]
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1004:	4b08      	ldr	r3, [pc, #32]	@ (1028 <prvInitialiseTaskLists+0x68>)
    1006:	4a05      	ldr	r2, [pc, #20]	@ (101c <prvInitialiseTaskLists+0x5c>)
    1008:	601a      	str	r2, [r3, #0]
}
    100a:	bf00      	nop
    100c:	3708      	adds	r7, #8
    100e:	46bd      	mov	sp, r7
    1010:	bd80      	pop	{r7, pc}
    1012:	bf00      	nop
    1014:	00002390 	muleq	r0, r0, r3
    1018:	000023f4 	strdeq	r2, [r0], -r4
    101c:	00002408 	andeq	r2, r0, r8, lsl #8
    1020:	00002424 	andeq	r2, r0, r4, lsr #8
    1024:	0000241c 	andeq	r2, r0, ip, lsl r4
    1028:	00002420 	andeq	r2, r0, r0, lsr #8

0000102c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    102c:	b480      	push	{r7}
    102e:	af00      	add	r7, sp, #0
            }
            #endif /* #if( configNUMBER_OF_CORES == 1 ) */
        }
    }
    #endif /* INCLUDE_vTaskDelete */
}
    1030:	bf00      	nop
    1032:	46bd      	mov	sp, r7
    1034:	bc80      	pop	{r7}
    1036:	4770      	bx	lr

00001038 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    1038:	b480      	push	{r7}
    103a:	af00      	add	r7, sp, #0
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    103c:	4b09      	ldr	r3, [pc, #36]	@ (1064 <prvResetNextTaskUnblockTime+0x2c>)
    103e:	681b      	ldr	r3, [r3, #0]
    1040:	681b      	ldr	r3, [r3, #0]
    1042:	2b00      	cmp	r3, #0
    1044:	d104      	bne.n	1050 <prvResetNextTaskUnblockTime+0x18>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    1046:	4b08      	ldr	r3, [pc, #32]	@ (1068 <prvResetNextTaskUnblockTime+0x30>)
    1048:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
    104c:	601a      	str	r2, [r3, #0]
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    }
}
    104e:	e005      	b.n	105c <prvResetNextTaskUnblockTime+0x24>
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    1050:	4b04      	ldr	r3, [pc, #16]	@ (1064 <prvResetNextTaskUnblockTime+0x2c>)
    1052:	681b      	ldr	r3, [r3, #0]
    1054:	68db      	ldr	r3, [r3, #12]
    1056:	681b      	ldr	r3, [r3, #0]
    1058:	4a03      	ldr	r2, [pc, #12]	@ (1068 <prvResetNextTaskUnblockTime+0x30>)
    105a:	6013      	str	r3, [r2, #0]
}
    105c:	bf00      	nop
    105e:	46bd      	mov	sp, r7
    1060:	bc80      	pop	{r7}
    1062:	4770      	bx	lr
    1064:	0000241c 	andeq	r2, r0, ip, lsl r4
    1068:	00002458 	andeq	r2, r0, r8, asr r4

0000106c <xTaskGetCurrentTaskHandle>:

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_RECURSIVE_MUTEXES == 1 ) ) || ( configNUMBER_OF_CORES > 1 )

    #if ( configNUMBER_OF_CORES == 1 )
        TaskHandle_t xTaskGetCurrentTaskHandle( void )
        {
    106c:	b480      	push	{r7}
    106e:	b083      	sub	sp, #12
    1070:	af00      	add	r7, sp, #0
            traceENTER_xTaskGetCurrentTaskHandle();

            /* A critical section is not required as this is not called from
             * an interrupt and the current TCB will always be the same for any
             * individual execution thread. */
            xReturn = pxCurrentTCB;
    1072:	4b04      	ldr	r3, [pc, #16]	@ (1084 <xTaskGetCurrentTaskHandle+0x18>)
    1074:	681b      	ldr	r3, [r3, #0]
    1076:	607b      	str	r3, [r7, #4]

            traceRETURN_xTaskGetCurrentTaskHandle( xReturn );

            return xReturn;
    1078:	687b      	ldr	r3, [r7, #4]
        }
    107a:	4618      	mov	r0, r3
    107c:	370c      	adds	r7, #12
    107e:	46bd      	mov	sp, r7
    1080:	bc80      	pop	{r7}
    1082:	4770      	bx	lr
    1084:	0000238c 	andeq	r2, r0, ip, lsl #7

00001088 <xTaskGetCurrentTaskHandleForCore>:
            return xReturn;
        }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    TaskHandle_t xTaskGetCurrentTaskHandleForCore( BaseType_t xCoreID )
    {
    1088:	b480      	push	{r7}
    108a:	b085      	sub	sp, #20
    108c:	af00      	add	r7, sp, #0
    108e:	6078      	str	r0, [r7, #4]
        TaskHandle_t xReturn = NULL;
    1090:	2300      	movs	r3, #0
    1092:	60fb      	str	r3, [r7, #12]

        traceENTER_xTaskGetCurrentTaskHandleForCore( xCoreID );

        if( taskVALID_CORE_ID( xCoreID ) != pdFALSE )
    1094:	687b      	ldr	r3, [r7, #4]
    1096:	2b00      	cmp	r3, #0
    1098:	db05      	blt.n	10a6 <xTaskGetCurrentTaskHandleForCore+0x1e>
    109a:	687b      	ldr	r3, [r7, #4]
    109c:	2b00      	cmp	r3, #0
    109e:	dc02      	bgt.n	10a6 <xTaskGetCurrentTaskHandleForCore+0x1e>
        {
            #if ( configNUMBER_OF_CORES == 1 )
                xReturn = pxCurrentTCB;
    10a0:	4b04      	ldr	r3, [pc, #16]	@ (10b4 <xTaskGetCurrentTaskHandleForCore+0x2c>)
    10a2:	681b      	ldr	r3, [r3, #0]
    10a4:	60fb      	str	r3, [r7, #12]
            #endif /* #if ( configNUMBER_OF_CORES == 1 ) */
        }

        traceRETURN_xTaskGetCurrentTaskHandleForCore( xReturn );

        return xReturn;
    10a6:	68fb      	ldr	r3, [r7, #12]
    }
    10a8:	4618      	mov	r0, r3
    10aa:	3714      	adds	r7, #20
    10ac:	46bd      	mov	sp, r7
    10ae:	bc80      	pop	{r7}
    10b0:	4770      	bx	lr
    10b2:	bf00      	nop
    10b4:	0000238c 	andeq	r2, r0, ip, lsl #7

000010b8 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    10b8:	b480      	push	{r7}
    10ba:	b083      	sub	sp, #12
    10bc:	af00      	add	r7, sp, #0
    TickType_t uxReturn;

    traceENTER_uxTaskResetEventItemValue();

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    10be:	4b09      	ldr	r3, [pc, #36]	@ (10e4 <uxTaskResetEventItemValue+0x2c>)
    10c0:	681b      	ldr	r3, [r3, #0]
    10c2:	699b      	ldr	r3, [r3, #24]
    10c4:	607b      	str	r3, [r7, #4]

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) );
    10c6:	4b07      	ldr	r3, [pc, #28]	@ (10e4 <uxTaskResetEventItemValue+0x2c>)
    10c8:	681b      	ldr	r3, [r3, #0]
    10ca:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    10cc:	4b05      	ldr	r3, [pc, #20]	@ (10e4 <uxTaskResetEventItemValue+0x2c>)
    10ce:	681b      	ldr	r3, [r3, #0]
    10d0:	f1c2 0205 	rsb	r2, r2, #5
    10d4:	619a      	str	r2, [r3, #24]

    traceRETURN_uxTaskResetEventItemValue( uxReturn );

    return uxReturn;
    10d6:	687b      	ldr	r3, [r7, #4]
}
    10d8:	4618      	mov	r0, r3
    10da:	370c      	adds	r7, #12
    10dc:	46bd      	mov	sp, r7
    10de:	bc80      	pop	{r7}
    10e0:	4770      	bx	lr
    10e2:	bf00      	nop
    10e4:	0000238c 	andeq	r2, r0, ip, lsl #7

000010e8 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWaitOn,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    10e8:	b580      	push	{r7, lr}
    10ea:	b088      	sub	sp, #32
    10ec:	af00      	add	r7, sp, #0
    10ee:	60f8      	str	r0, [r7, #12]
    10f0:	60b9      	str	r1, [r7, #8]
    10f2:	607a      	str	r2, [r7, #4]
        uint32_t ulReturn;
        BaseType_t xAlreadyYielded, xShouldBlock = pdFALSE;
    10f4:	2300      	movs	r3, #0
    10f6:	61fb      	str	r3, [r7, #28]

        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If the notification count is zero, and if we are willing to wait for a
         * notification, then block the task and wait. */
        if( ( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0U ) && ( xTicksToWait > ( TickType_t ) 0 ) )
    10f8:	4b35      	ldr	r3, [pc, #212]	@ (11d0 <ulTaskGenericNotifyTake+0xe8>)
    10fa:	681a      	ldr	r2, [r3, #0]
    10fc:	68fb      	ldr	r3, [r7, #12]
    10fe:	3310      	adds	r3, #16
    1100:	009b      	lsls	r3, r3, #2
    1102:	4413      	add	r3, r2
    1104:	685b      	ldr	r3, [r3, #4]
    1106:	2b00      	cmp	r3, #0
    1108:	d132      	bne.n	1170 <ulTaskGenericNotifyTake+0x88>
    110a:	687b      	ldr	r3, [r7, #4]
    110c:	2b00      	cmp	r3, #0
    110e:	d02f      	beq.n	1170 <ulTaskGenericNotifyTake+0x88>
        {
            /* We suspend the scheduler here as prvAddCurrentTaskToDelayedList is a
             * non-deterministic operation. */
            vTaskSuspendAll();
    1110:	f7ff fa5c 	bl	5cc <vTaskSuspendAll>
            {
                /* We MUST enter a critical section to atomically check if a notification
                 * has occurred and set the flag to indicate that we are waiting for
                 * a notification. If we do not do so, a notification sent from an ISR
                 * will get lost. */
                taskENTER_CRITICAL();
    1114:	f001 f89c 	bl	2250 <vPortEnterCritical>
                {
                    /* Only block if the notification count is not already non-zero. */
                    if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0U )
    1118:	4b2d      	ldr	r3, [pc, #180]	@ (11d0 <ulTaskGenericNotifyTake+0xe8>)
    111a:	681a      	ldr	r2, [r3, #0]
    111c:	68fb      	ldr	r3, [r7, #12]
    111e:	3310      	adds	r3, #16
    1120:	009b      	lsls	r3, r3, #2
    1122:	4413      	add	r3, r2
    1124:	685b      	ldr	r3, [r3, #4]
    1126:	2b00      	cmp	r3, #0
    1128:	d108      	bne.n	113c <ulTaskGenericNotifyTake+0x54>
                    {
                        /* Mark this task as waiting for a notification. */
                        pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
    112a:	4b29      	ldr	r3, [pc, #164]	@ (11d0 <ulTaskGenericNotifyTake+0xe8>)
    112c:	681a      	ldr	r2, [r3, #0]
    112e:	68fb      	ldr	r3, [r7, #12]
    1130:	4413      	add	r3, r2
    1132:	3348      	adds	r3, #72	@ 0x48
    1134:	2201      	movs	r2, #1
    1136:	701a      	strb	r2, [r3, #0]

                        /* Arrange to wait for a notification. */
                        xShouldBlock = pdTRUE;
    1138:	2301      	movs	r3, #1
    113a:	61fb      	str	r3, [r7, #28]
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                taskEXIT_CRITICAL();
    113c:	f001 f8a2 	bl	2284 <vPortExitCritical>

                /* We are now out of the critical section but the scheduler is still
                 * suspended, so we are safe to do non-deterministic operations such
                 * as prvAddCurrentTaskToDelayedList. */
                if( xShouldBlock == pdTRUE )
    1140:	69fb      	ldr	r3, [r7, #28]
    1142:	2b01      	cmp	r3, #1
    1144:	d103      	bne.n	114e <ulTaskGenericNotifyTake+0x66>
                {
                    traceTASK_NOTIFY_TAKE_BLOCK( uxIndexToWaitOn );
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1146:	2101      	movs	r1, #1
    1148:	6878      	ldr	r0, [r7, #4]
    114a:	f000 fc21 	bl	1990 <prvAddCurrentTaskToDelayedList>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            xAlreadyYielded = xTaskResumeAll();
    114e:	f7ff fa4b 	bl	5e8 <xTaskResumeAll>
    1152:	61b8      	str	r0, [r7, #24]

            /* Force a reschedule if xTaskResumeAll has not already done so. */
            if( ( xShouldBlock == pdTRUE ) && ( xAlreadyYielded == pdFALSE ) )
    1154:	69fb      	ldr	r3, [r7, #28]
    1156:	2b01      	cmp	r3, #1
    1158:	d10a      	bne.n	1170 <ulTaskGenericNotifyTake+0x88>
    115a:	69bb      	ldr	r3, [r7, #24]
    115c:	2b00      	cmp	r3, #0
    115e:	d107      	bne.n	1170 <ulTaskGenericNotifyTake+0x88>
            {
                taskYIELD_WITHIN_API();
    1160:	4b1c      	ldr	r3, [pc, #112]	@ (11d4 <ulTaskGenericNotifyTake+0xec>)
    1162:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    1166:	601a      	str	r2, [r3, #0]
    1168:	f3bf 8f4f 	dsb	sy
    116c:	f3bf 8f6f 	isb	sy
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        taskENTER_CRITICAL();
    1170:	f001 f86e 	bl	2250 <vPortEnterCritical>
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWaitOn );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];
    1174:	4b16      	ldr	r3, [pc, #88]	@ (11d0 <ulTaskGenericNotifyTake+0xe8>)
    1176:	681a      	ldr	r2, [r3, #0]
    1178:	68fb      	ldr	r3, [r7, #12]
    117a:	3310      	adds	r3, #16
    117c:	009b      	lsls	r3, r3, #2
    117e:	4413      	add	r3, r2
    1180:	685b      	ldr	r3, [r3, #4]
    1182:	617b      	str	r3, [r7, #20]

            if( ulReturn != 0U )
    1184:	697b      	ldr	r3, [r7, #20]
    1186:	2b00      	cmp	r3, #0
    1188:	d014      	beq.n	11b4 <ulTaskGenericNotifyTake+0xcc>
            {
                if( xClearCountOnExit != pdFALSE )
    118a:	68bb      	ldr	r3, [r7, #8]
    118c:	2b00      	cmp	r3, #0
    118e:	d008      	beq.n	11a2 <ulTaskGenericNotifyTake+0xba>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ( uint32_t ) 0U;
    1190:	4b0f      	ldr	r3, [pc, #60]	@ (11d0 <ulTaskGenericNotifyTake+0xe8>)
    1192:	681a      	ldr	r2, [r3, #0]
    1194:	68fb      	ldr	r3, [r7, #12]
    1196:	3310      	adds	r3, #16
    1198:	009b      	lsls	r3, r3, #2
    119a:	4413      	add	r3, r2
    119c:	2200      	movs	r2, #0
    119e:	605a      	str	r2, [r3, #4]
    11a0:	e008      	b.n	11b4 <ulTaskGenericNotifyTake+0xcc>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ulReturn - ( uint32_t ) 1;
    11a2:	4b0b      	ldr	r3, [pc, #44]	@ (11d0 <ulTaskGenericNotifyTake+0xe8>)
    11a4:	6819      	ldr	r1, [r3, #0]
    11a6:	697b      	ldr	r3, [r7, #20]
    11a8:	1e5a      	subs	r2, r3, #1
    11aa:	68fb      	ldr	r3, [r7, #12]
    11ac:	3310      	adds	r3, #16
    11ae:	009b      	lsls	r3, r3, #2
    11b0:	440b      	add	r3, r1
    11b2:	605a      	str	r2, [r3, #4]
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;
    11b4:	4b06      	ldr	r3, [pc, #24]	@ (11d0 <ulTaskGenericNotifyTake+0xe8>)
    11b6:	681a      	ldr	r2, [r3, #0]
    11b8:	68fb      	ldr	r3, [r7, #12]
    11ba:	4413      	add	r3, r2
    11bc:	3348      	adds	r3, #72	@ 0x48
    11be:	2200      	movs	r2, #0
    11c0:	701a      	strb	r2, [r3, #0]
        }
        taskEXIT_CRITICAL();
    11c2:	f001 f85f 	bl	2284 <vPortExitCritical>

        traceRETURN_ulTaskGenericNotifyTake( ulReturn );

        return ulReturn;
    11c6:	697b      	ldr	r3, [r7, #20]
    }
    11c8:	4618      	mov	r0, r3
    11ca:	3720      	adds	r7, #32
    11cc:	46bd      	mov	sp, r7
    11ce:	bd80      	pop	{r7, pc}
    11d0:	0000238c 	andeq	r2, r0, ip, lsl #7
    11d4:	e000ed04 	and	lr, r0, r4, lsl #26

000011d8 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWaitOn,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    11d8:	b580      	push	{r7, lr}
    11da:	b088      	sub	sp, #32
    11dc:	af00      	add	r7, sp, #0
    11de:	60f8      	str	r0, [r7, #12]
    11e0:	60b9      	str	r1, [r7, #8]
    11e2:	607a      	str	r2, [r7, #4]
    11e4:	603b      	str	r3, [r7, #0]
        BaseType_t xReturn, xAlreadyYielded, xShouldBlock = pdFALSE;
    11e6:	2300      	movs	r3, #0
    11e8:	61bb      	str	r3, [r7, #24]

        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If the task hasn't received a notification, and if we are willing to wait
         * for it, then block the task and wait. */
        if( ( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED ) && ( xTicksToWait > ( TickType_t ) 0 ) )
    11ea:	4b42      	ldr	r3, [pc, #264]	@ (12f4 <xTaskGenericNotifyWait+0x11c>)
    11ec:	681a      	ldr	r2, [r3, #0]
    11ee:	68fb      	ldr	r3, [r7, #12]
    11f0:	4413      	add	r3, r2
    11f2:	3348      	adds	r3, #72	@ 0x48
    11f4:	781b      	ldrb	r3, [r3, #0]
    11f6:	b2db      	uxtb	r3, r3
    11f8:	2b02      	cmp	r3, #2
    11fa:	d041      	beq.n	1280 <xTaskGenericNotifyWait+0xa8>
    11fc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    11fe:	2b00      	cmp	r3, #0
    1200:	d03e      	beq.n	1280 <xTaskGenericNotifyWait+0xa8>
        {
            /* We suspend the scheduler here as prvAddCurrentTaskToDelayedList is a
             * non-deterministic operation. */
            vTaskSuspendAll();
    1202:	f7ff f9e3 	bl	5cc <vTaskSuspendAll>
            {
                /* We MUST enter a critical section to atomically check and update the
                 * task notification value. If we do not do so, a notification from
                 * an ISR will get lost. */
                taskENTER_CRITICAL();
    1206:	f001 f823 	bl	2250 <vPortEnterCritical>
                {
                    /* Only block if a notification is not already pending. */
                    if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )
    120a:	4b3a      	ldr	r3, [pc, #232]	@ (12f4 <xTaskGenericNotifyWait+0x11c>)
    120c:	681a      	ldr	r2, [r3, #0]
    120e:	68fb      	ldr	r3, [r7, #12]
    1210:	4413      	add	r3, r2
    1212:	3348      	adds	r3, #72	@ 0x48
    1214:	781b      	ldrb	r3, [r3, #0]
    1216:	b2db      	uxtb	r3, r3
    1218:	2b02      	cmp	r3, #2
    121a:	d017      	beq.n	124c <xTaskGenericNotifyWait+0x74>
                    {
                        /* Clear bits in the task's notification value as bits may get
                         * set by the notifying task or interrupt. This can be used
                         * to clear the value to zero. */
                        pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnEntry;
    121c:	4b35      	ldr	r3, [pc, #212]	@ (12f4 <xTaskGenericNotifyWait+0x11c>)
    121e:	681a      	ldr	r2, [r3, #0]
    1220:	68fb      	ldr	r3, [r7, #12]
    1222:	3310      	adds	r3, #16
    1224:	009b      	lsls	r3, r3, #2
    1226:	4413      	add	r3, r2
    1228:	6859      	ldr	r1, [r3, #4]
    122a:	68bb      	ldr	r3, [r7, #8]
    122c:	43db      	mvns	r3, r3
    122e:	4019      	ands	r1, r3
    1230:	68fb      	ldr	r3, [r7, #12]
    1232:	3310      	adds	r3, #16
    1234:	009b      	lsls	r3, r3, #2
    1236:	4413      	add	r3, r2
    1238:	6059      	str	r1, [r3, #4]

                        /* Mark this task as waiting for a notification. */
                        pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
    123a:	4b2e      	ldr	r3, [pc, #184]	@ (12f4 <xTaskGenericNotifyWait+0x11c>)
    123c:	681a      	ldr	r2, [r3, #0]
    123e:	68fb      	ldr	r3, [r7, #12]
    1240:	4413      	add	r3, r2
    1242:	3348      	adds	r3, #72	@ 0x48
    1244:	2201      	movs	r2, #1
    1246:	701a      	strb	r2, [r3, #0]

                        /* Arrange to wait for a notification. */
                        xShouldBlock = pdTRUE;
    1248:	2301      	movs	r3, #1
    124a:	61bb      	str	r3, [r7, #24]
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                taskEXIT_CRITICAL();
    124c:	f001 f81a 	bl	2284 <vPortExitCritical>

                /* We are now out of the critical section but the scheduler is still
                 * suspended, so we are safe to do non-deterministic operations such
                 * as prvAddCurrentTaskToDelayedList. */
                if( xShouldBlock == pdTRUE )
    1250:	69bb      	ldr	r3, [r7, #24]
    1252:	2b01      	cmp	r3, #1
    1254:	d103      	bne.n	125e <xTaskGenericNotifyWait+0x86>
                {
                    traceTASK_NOTIFY_WAIT_BLOCK( uxIndexToWaitOn );
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1256:	2101      	movs	r1, #1
    1258:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
    125a:	f000 fb99 	bl	1990 <prvAddCurrentTaskToDelayedList>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            xAlreadyYielded = xTaskResumeAll();
    125e:	f7ff f9c3 	bl	5e8 <xTaskResumeAll>
    1262:	6178      	str	r0, [r7, #20]

            /* Force a reschedule if xTaskResumeAll has not already done so. */
            if( ( xShouldBlock == pdTRUE ) && ( xAlreadyYielded == pdFALSE ) )
    1264:	69bb      	ldr	r3, [r7, #24]
    1266:	2b01      	cmp	r3, #1
    1268:	d10a      	bne.n	1280 <xTaskGenericNotifyWait+0xa8>
    126a:	697b      	ldr	r3, [r7, #20]
    126c:	2b00      	cmp	r3, #0
    126e:	d107      	bne.n	1280 <xTaskGenericNotifyWait+0xa8>
            {
                taskYIELD_WITHIN_API();
    1270:	4b21      	ldr	r3, [pc, #132]	@ (12f8 <xTaskGenericNotifyWait+0x120>)
    1272:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    1276:	601a      	str	r2, [r3, #0]
    1278:	f3bf 8f4f 	dsb	sy
    127c:	f3bf 8f6f 	isb	sy
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        taskENTER_CRITICAL();
    1280:	f000 ffe6 	bl	2250 <vPortEnterCritical>
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWaitOn );

            if( pulNotificationValue != NULL )
    1284:	683b      	ldr	r3, [r7, #0]
    1286:	2b00      	cmp	r3, #0
    1288:	d008      	beq.n	129c <xTaskGenericNotifyWait+0xc4>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];
    128a:	4b1a      	ldr	r3, [pc, #104]	@ (12f4 <xTaskGenericNotifyWait+0x11c>)
    128c:	681a      	ldr	r2, [r3, #0]
    128e:	68fb      	ldr	r3, [r7, #12]
    1290:	3310      	adds	r3, #16
    1292:	009b      	lsls	r3, r3, #2
    1294:	4413      	add	r3, r2
    1296:	685a      	ldr	r2, [r3, #4]
    1298:	683b      	ldr	r3, [r7, #0]
    129a:	601a      	str	r2, [r3, #0]

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )
    129c:	4b15      	ldr	r3, [pc, #84]	@ (12f4 <xTaskGenericNotifyWait+0x11c>)
    129e:	681a      	ldr	r2, [r3, #0]
    12a0:	68fb      	ldr	r3, [r7, #12]
    12a2:	4413      	add	r3, r2
    12a4:	3348      	adds	r3, #72	@ 0x48
    12a6:	781b      	ldrb	r3, [r3, #0]
    12a8:	b2db      	uxtb	r3, r3
    12aa:	2b02      	cmp	r3, #2
    12ac:	d002      	beq.n	12b4 <xTaskGenericNotifyWait+0xdc>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    12ae:	2300      	movs	r3, #0
    12b0:	61fb      	str	r3, [r7, #28]
    12b2:	e010      	b.n	12d6 <xTaskGenericNotifyWait+0xfe>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnExit;
    12b4:	4b0f      	ldr	r3, [pc, #60]	@ (12f4 <xTaskGenericNotifyWait+0x11c>)
    12b6:	681a      	ldr	r2, [r3, #0]
    12b8:	68fb      	ldr	r3, [r7, #12]
    12ba:	3310      	adds	r3, #16
    12bc:	009b      	lsls	r3, r3, #2
    12be:	4413      	add	r3, r2
    12c0:	6859      	ldr	r1, [r3, #4]
    12c2:	687b      	ldr	r3, [r7, #4]
    12c4:	43db      	mvns	r3, r3
    12c6:	4019      	ands	r1, r3
    12c8:	68fb      	ldr	r3, [r7, #12]
    12ca:	3310      	adds	r3, #16
    12cc:	009b      	lsls	r3, r3, #2
    12ce:	4413      	add	r3, r2
    12d0:	6059      	str	r1, [r3, #4]
                xReturn = pdTRUE;
    12d2:	2301      	movs	r3, #1
    12d4:	61fb      	str	r3, [r7, #28]
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;
    12d6:	4b07      	ldr	r3, [pc, #28]	@ (12f4 <xTaskGenericNotifyWait+0x11c>)
    12d8:	681a      	ldr	r2, [r3, #0]
    12da:	68fb      	ldr	r3, [r7, #12]
    12dc:	4413      	add	r3, r2
    12de:	3348      	adds	r3, #72	@ 0x48
    12e0:	2200      	movs	r2, #0
    12e2:	701a      	strb	r2, [r3, #0]
        }
        taskEXIT_CRITICAL();
    12e4:	f000 ffce 	bl	2284 <vPortExitCritical>

        traceRETURN_xTaskGenericNotifyWait( xReturn );

        return xReturn;
    12e8:	69fb      	ldr	r3, [r7, #28]
    }
    12ea:	4618      	mov	r0, r3
    12ec:	3720      	adds	r7, #32
    12ee:	46bd      	mov	sp, r7
    12f0:	bd80      	pop	{r7, pc}
    12f2:	bf00      	nop
    12f4:	0000238c 	andeq	r2, r0, ip, lsl #7
    12f8:	e000ed04 	and	lr, r0, r4, lsl #26

000012fc <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    12fc:	b580      	push	{r7, lr}
    12fe:	b08a      	sub	sp, #40	@ 0x28
    1300:	af00      	add	r7, sp, #0
    1302:	60f8      	str	r0, [r7, #12]
    1304:	60b9      	str	r1, [r7, #8]
    1306:	607a      	str	r2, [r7, #4]
    1308:	70fb      	strb	r3, [r7, #3]
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    130a:	2301      	movs	r3, #1
    130c:	627b      	str	r3, [r7, #36]	@ 0x24

        traceENTER_xTaskGenericNotify( xTaskToNotify, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue );

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    130e:	68fb      	ldr	r3, [r7, #12]
    1310:	623b      	str	r3, [r7, #32]

        taskENTER_CRITICAL();
    1312:	f000 ff9d 	bl	2250 <vPortEnterCritical>
        {
            if( pulPreviousNotificationValue != NULL )
    1316:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1318:	2b00      	cmp	r3, #0
    131a:	d007      	beq.n	132c <xTaskGenericNotify+0x30>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    131c:	6a3a      	ldr	r2, [r7, #32]
    131e:	68bb      	ldr	r3, [r7, #8]
    1320:	3310      	adds	r3, #16
    1322:	009b      	lsls	r3, r3, #2
    1324:	4413      	add	r3, r2
    1326:	685a      	ldr	r2, [r3, #4]
    1328:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    132a:	601a      	str	r2, [r3, #0]
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    132c:	6a3a      	ldr	r2, [r7, #32]
    132e:	68bb      	ldr	r3, [r7, #8]
    1330:	4413      	add	r3, r2
    1332:	3348      	adds	r3, #72	@ 0x48
    1334:	781b      	ldrb	r3, [r3, #0]
    1336:	77fb      	strb	r3, [r7, #31]

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1338:	6a3a      	ldr	r2, [r7, #32]
    133a:	68bb      	ldr	r3, [r7, #8]
    133c:	4413      	add	r3, r2
    133e:	3348      	adds	r3, #72	@ 0x48
    1340:	2202      	movs	r2, #2
    1342:	701a      	strb	r2, [r3, #0]

            switch( eAction )
    1344:	78fb      	ldrb	r3, [r7, #3]
    1346:	2b04      	cmp	r3, #4
    1348:	d83f      	bhi.n	13ca <xTaskGenericNotify+0xce>
    134a:	a201      	add	r2, pc, #4	@ (adr r2, 1350 <xTaskGenericNotify+0x54>)
    134c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1350:	000013cb 	andeq	r1, r0, fp, asr #7
    1354:	00001365 	andeq	r1, r0, r5, ror #6
    1358:	00001383 	andeq	r1, r0, r3, lsl #7
    135c:	0000139f 	muleq	r0, pc, r3	@ <UNPREDICTABLE>
    1360:	000013af 	andeq	r1, r0, pc, lsr #7
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    1364:	6a3a      	ldr	r2, [r7, #32]
    1366:	68bb      	ldr	r3, [r7, #8]
    1368:	3310      	adds	r3, #16
    136a:	009b      	lsls	r3, r3, #2
    136c:	4413      	add	r3, r2
    136e:	685a      	ldr	r2, [r3, #4]
    1370:	687b      	ldr	r3, [r7, #4]
    1372:	431a      	orrs	r2, r3
    1374:	6a39      	ldr	r1, [r7, #32]
    1376:	68bb      	ldr	r3, [r7, #8]
    1378:	3310      	adds	r3, #16
    137a:	009b      	lsls	r3, r3, #2
    137c:	440b      	add	r3, r1
    137e:	605a      	str	r2, [r3, #4]
                    break;
    1380:	e024      	b.n	13cc <xTaskGenericNotify+0xd0>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    1382:	6a3a      	ldr	r2, [r7, #32]
    1384:	68bb      	ldr	r3, [r7, #8]
    1386:	3310      	adds	r3, #16
    1388:	009b      	lsls	r3, r3, #2
    138a:	4413      	add	r3, r2
    138c:	685b      	ldr	r3, [r3, #4]
    138e:	1c5a      	adds	r2, r3, #1
    1390:	6a39      	ldr	r1, [r7, #32]
    1392:	68bb      	ldr	r3, [r7, #8]
    1394:	3310      	adds	r3, #16
    1396:	009b      	lsls	r3, r3, #2
    1398:	440b      	add	r3, r1
    139a:	605a      	str	r2, [r3, #4]
                    break;
    139c:	e016      	b.n	13cc <xTaskGenericNotify+0xd0>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    139e:	6a3a      	ldr	r2, [r7, #32]
    13a0:	68bb      	ldr	r3, [r7, #8]
    13a2:	3310      	adds	r3, #16
    13a4:	009b      	lsls	r3, r3, #2
    13a6:	4413      	add	r3, r2
    13a8:	687a      	ldr	r2, [r7, #4]
    13aa:	605a      	str	r2, [r3, #4]
                    break;
    13ac:	e00e      	b.n	13cc <xTaskGenericNotify+0xd0>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    13ae:	7ffb      	ldrb	r3, [r7, #31]
    13b0:	2b02      	cmp	r3, #2
    13b2:	d007      	beq.n	13c4 <xTaskGenericNotify+0xc8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    13b4:	6a3a      	ldr	r2, [r7, #32]
    13b6:	68bb      	ldr	r3, [r7, #8]
    13b8:	3310      	adds	r3, #16
    13ba:	009b      	lsls	r3, r3, #2
    13bc:	4413      	add	r3, r2
    13be:	687a      	ldr	r2, [r7, #4]
    13c0:	605a      	str	r2, [r3, #4]
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
    13c2:	e003      	b.n	13cc <xTaskGenericNotify+0xd0>
                        xReturn = pdFAIL;
    13c4:	2300      	movs	r3, #0
    13c6:	627b      	str	r3, [r7, #36]	@ 0x24
                    break;
    13c8:	e000      	b.n	13cc <xTaskGenericNotify+0xd0>
                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );

                    break;
    13ca:	bf00      	nop

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    13cc:	7ffb      	ldrb	r3, [r7, #31]
    13ce:	2b01      	cmp	r3, #1
    13d0:	d16e      	bne.n	14b0 <xTaskGenericNotify+0x1b4>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    13d2:	6a3b      	ldr	r3, [r7, #32]
    13d4:	695b      	ldr	r3, [r3, #20]
    13d6:	61bb      	str	r3, [r7, #24]
    13d8:	6a3b      	ldr	r3, [r7, #32]
    13da:	689b      	ldr	r3, [r3, #8]
    13dc:	6a3a      	ldr	r2, [r7, #32]
    13de:	68d2      	ldr	r2, [r2, #12]
    13e0:	609a      	str	r2, [r3, #8]
    13e2:	6a3b      	ldr	r3, [r7, #32]
    13e4:	68db      	ldr	r3, [r3, #12]
    13e6:	6a3a      	ldr	r2, [r7, #32]
    13e8:	6892      	ldr	r2, [r2, #8]
    13ea:	605a      	str	r2, [r3, #4]
    13ec:	69bb      	ldr	r3, [r7, #24]
    13ee:	685a      	ldr	r2, [r3, #4]
    13f0:	6a3b      	ldr	r3, [r7, #32]
    13f2:	3304      	adds	r3, #4
    13f4:	429a      	cmp	r2, r3
    13f6:	d103      	bne.n	1400 <xTaskGenericNotify+0x104>
    13f8:	6a3b      	ldr	r3, [r7, #32]
    13fa:	68da      	ldr	r2, [r3, #12]
    13fc:	69bb      	ldr	r3, [r7, #24]
    13fe:	605a      	str	r2, [r3, #4]
    1400:	6a3b      	ldr	r3, [r7, #32]
    1402:	2200      	movs	r2, #0
    1404:	615a      	str	r2, [r3, #20]
    1406:	69bb      	ldr	r3, [r7, #24]
    1408:	681b      	ldr	r3, [r3, #0]
    140a:	1e5a      	subs	r2, r3, #1
    140c:	69bb      	ldr	r3, [r7, #24]
    140e:	601a      	str	r2, [r3, #0]
                prvAddTaskToReadyList( pxTCB );
    1410:	6a3b      	ldr	r3, [r7, #32]
    1412:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
    1414:	2201      	movs	r2, #1
    1416:	409a      	lsls	r2, r3
    1418:	4b29      	ldr	r3, [pc, #164]	@ (14c0 <xTaskGenericNotify+0x1c4>)
    141a:	681b      	ldr	r3, [r3, #0]
    141c:	4313      	orrs	r3, r2
    141e:	4a28      	ldr	r2, [pc, #160]	@ (14c0 <xTaskGenericNotify+0x1c4>)
    1420:	6013      	str	r3, [r2, #0]
    1422:	6a3b      	ldr	r3, [r7, #32]
    1424:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    1426:	4927      	ldr	r1, [pc, #156]	@ (14c4 <xTaskGenericNotify+0x1c8>)
    1428:	4613      	mov	r3, r2
    142a:	009b      	lsls	r3, r3, #2
    142c:	4413      	add	r3, r2
    142e:	009b      	lsls	r3, r3, #2
    1430:	440b      	add	r3, r1
    1432:	3304      	adds	r3, #4
    1434:	681b      	ldr	r3, [r3, #0]
    1436:	617b      	str	r3, [r7, #20]
    1438:	6a3b      	ldr	r3, [r7, #32]
    143a:	697a      	ldr	r2, [r7, #20]
    143c:	609a      	str	r2, [r3, #8]
    143e:	697b      	ldr	r3, [r7, #20]
    1440:	689a      	ldr	r2, [r3, #8]
    1442:	6a3b      	ldr	r3, [r7, #32]
    1444:	60da      	str	r2, [r3, #12]
    1446:	697b      	ldr	r3, [r7, #20]
    1448:	689b      	ldr	r3, [r3, #8]
    144a:	6a3a      	ldr	r2, [r7, #32]
    144c:	3204      	adds	r2, #4
    144e:	605a      	str	r2, [r3, #4]
    1450:	6a3b      	ldr	r3, [r7, #32]
    1452:	1d1a      	adds	r2, r3, #4
    1454:	697b      	ldr	r3, [r7, #20]
    1456:	609a      	str	r2, [r3, #8]
    1458:	6a3b      	ldr	r3, [r7, #32]
    145a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    145c:	4613      	mov	r3, r2
    145e:	009b      	lsls	r3, r3, #2
    1460:	4413      	add	r3, r2
    1462:	009b      	lsls	r3, r3, #2
    1464:	4a17      	ldr	r2, [pc, #92]	@ (14c4 <xTaskGenericNotify+0x1c8>)
    1466:	441a      	add	r2, r3
    1468:	6a3b      	ldr	r3, [r7, #32]
    146a:	615a      	str	r2, [r3, #20]
    146c:	6a3b      	ldr	r3, [r7, #32]
    146e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    1470:	4914      	ldr	r1, [pc, #80]	@ (14c4 <xTaskGenericNotify+0x1c8>)
    1472:	4613      	mov	r3, r2
    1474:	009b      	lsls	r3, r3, #2
    1476:	4413      	add	r3, r2
    1478:	009b      	lsls	r3, r3, #2
    147a:	440b      	add	r3, r1
    147c:	681b      	ldr	r3, [r3, #0]
    147e:	6a3a      	ldr	r2, [r7, #32]
    1480:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
    1482:	1c59      	adds	r1, r3, #1
    1484:	480f      	ldr	r0, [pc, #60]	@ (14c4 <xTaskGenericNotify+0x1c8>)
    1486:	4613      	mov	r3, r2
    1488:	009b      	lsls	r3, r3, #2
    148a:	4413      	add	r3, r2
    148c:	009b      	lsls	r3, r3, #2
    148e:	4403      	add	r3, r0
    1490:	6019      	str	r1, [r3, #0]
                }
                #endif

                /* Check if the notified task has a priority above the currently
                 * executing task. */
                taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB );
    1492:	4b0d      	ldr	r3, [pc, #52]	@ (14c8 <xTaskGenericNotify+0x1cc>)
    1494:	681b      	ldr	r3, [r3, #0]
    1496:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    1498:	6a3b      	ldr	r3, [r7, #32]
    149a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
    149c:	429a      	cmp	r2, r3
    149e:	d207      	bcs.n	14b0 <xTaskGenericNotify+0x1b4>
    14a0:	4b0a      	ldr	r3, [pc, #40]	@ (14cc <xTaskGenericNotify+0x1d0>)
    14a2:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    14a6:	601a      	str	r2, [r3, #0]
    14a8:	f3bf 8f4f 	dsb	sy
    14ac:	f3bf 8f6f 	isb	sy
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    14b0:	f000 fee8 	bl	2284 <vPortExitCritical>

        traceRETURN_xTaskGenericNotify( xReturn );

        return xReturn;
    14b4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    }
    14b6:	4618      	mov	r0, r3
    14b8:	3728      	adds	r7, #40	@ 0x28
    14ba:	46bd      	mov	sp, r7
    14bc:	bd80      	pop	{r7, pc}
    14be:	bf00      	nop
    14c0:	00002440 	andeq	r2, r0, r0, asr #8
    14c4:	00002390 	muleq	r0, r0, r3
    14c8:	0000238c 	andeq	r2, r0, ip, lsl #7
    14cc:	e000ed04 	and	lr, r0, r4, lsl #26

000014d0 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    14d0:	b480      	push	{r7}
    14d2:	b08f      	sub	sp, #60	@ 0x3c
    14d4:	af00      	add	r7, sp, #0
    14d6:	60f8      	str	r0, [r7, #12]
    14d8:	60b9      	str	r1, [r7, #8]
    14da:	607a      	str	r2, [r7, #4]
    14dc:	70fb      	strb	r3, [r7, #3]
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    14de:	2301      	movs	r3, #1
    14e0:	637b      	str	r3, [r7, #52]	@ 0x34
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    14e2:	68fb      	ldr	r3, [r7, #12]
    14e4:	633b      	str	r3, [r7, #48]	@ 0x30

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
    uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

    __asm volatile
    14e6:	f3ef 8211 	mrs	r2, BASEPRI
    14ea:	f04f 0301 	mov.w	r3, #1
    14ee:	f383 8811 	msr	BASEPRI, r3
    14f2:	f3bf 8f6f 	isb	sy
    14f6:	f3bf 8f4f 	dsb	sy
    14fa:	61ba      	str	r2, [r7, #24]
    14fc:	617b      	str	r3, [r7, #20]
        : "=r" ( ulOriginalBASEPRI ), "=r" ( ulNewBASEPRI ) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
    );

    /* This return will not be reached but is necessary to prevent compiler
     * warnings. */
    return ulOriginalBASEPRI;
    14fe:	69bb      	ldr	r3, [r7, #24]

        /* MISRA Ref 4.7.1 [Return value shall be checked] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#dir-47 */
        /* coverity[misra_c_2012_directive_4_7_violation] */
        uxSavedInterruptStatus = ( UBaseType_t ) taskENTER_CRITICAL_FROM_ISR();
    1500:	62fb      	str	r3, [r7, #44]	@ 0x2c
        {
            if( pulPreviousNotificationValue != NULL )
    1502:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
    1504:	2b00      	cmp	r3, #0
    1506:	d007      	beq.n	1518 <xTaskGenericNotifyFromISR+0x48>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    1508:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    150a:	68bb      	ldr	r3, [r7, #8]
    150c:	3310      	adds	r3, #16
    150e:	009b      	lsls	r3, r3, #2
    1510:	4413      	add	r3, r2
    1512:	685a      	ldr	r2, [r3, #4]
    1514:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
    1516:	601a      	str	r2, [r3, #0]
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    1518:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    151a:	68bb      	ldr	r3, [r7, #8]
    151c:	4413      	add	r3, r2
    151e:	3348      	adds	r3, #72	@ 0x48
    1520:	781b      	ldrb	r3, [r3, #0]
    1522:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1526:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    1528:	68bb      	ldr	r3, [r7, #8]
    152a:	4413      	add	r3, r2
    152c:	3348      	adds	r3, #72	@ 0x48
    152e:	2202      	movs	r2, #2
    1530:	701a      	strb	r2, [r3, #0]

            switch( eAction )
    1532:	78fb      	ldrb	r3, [r7, #3]
    1534:	2b04      	cmp	r3, #4
    1536:	d841      	bhi.n	15bc <xTaskGenericNotifyFromISR+0xec>
    1538:	a201      	add	r2, pc, #4	@ (adr r2, 1540 <xTaskGenericNotifyFromISR+0x70>)
    153a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    153e:	bf00      	nop
    1540:	000015bd 			@ <UNDEFINED> instruction: 0x000015bd
    1544:	00001555 	andeq	r1, r0, r5, asr r5
    1548:	00001573 	andeq	r1, r0, r3, ror r5
    154c:	0000158f 	andeq	r1, r0, pc, lsl #11
    1550:	0000159f 	muleq	r0, pc, r5	@ <UNPREDICTABLE>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    1554:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    1556:	68bb      	ldr	r3, [r7, #8]
    1558:	3310      	adds	r3, #16
    155a:	009b      	lsls	r3, r3, #2
    155c:	4413      	add	r3, r2
    155e:	685a      	ldr	r2, [r3, #4]
    1560:	687b      	ldr	r3, [r7, #4]
    1562:	431a      	orrs	r2, r3
    1564:	6b39      	ldr	r1, [r7, #48]	@ 0x30
    1566:	68bb      	ldr	r3, [r7, #8]
    1568:	3310      	adds	r3, #16
    156a:	009b      	lsls	r3, r3, #2
    156c:	440b      	add	r3, r1
    156e:	605a      	str	r2, [r3, #4]
                    break;
    1570:	e025      	b.n	15be <xTaskGenericNotifyFromISR+0xee>

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    1572:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    1574:	68bb      	ldr	r3, [r7, #8]
    1576:	3310      	adds	r3, #16
    1578:	009b      	lsls	r3, r3, #2
    157a:	4413      	add	r3, r2
    157c:	685b      	ldr	r3, [r3, #4]
    157e:	1c5a      	adds	r2, r3, #1
    1580:	6b39      	ldr	r1, [r7, #48]	@ 0x30
    1582:	68bb      	ldr	r3, [r7, #8]
    1584:	3310      	adds	r3, #16
    1586:	009b      	lsls	r3, r3, #2
    1588:	440b      	add	r3, r1
    158a:	605a      	str	r2, [r3, #4]
                    break;
    158c:	e017      	b.n	15be <xTaskGenericNotifyFromISR+0xee>

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    158e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    1590:	68bb      	ldr	r3, [r7, #8]
    1592:	3310      	adds	r3, #16
    1594:	009b      	lsls	r3, r3, #2
    1596:	4413      	add	r3, r2
    1598:	687a      	ldr	r2, [r7, #4]
    159a:	605a      	str	r2, [r3, #4]
                    break;
    159c:	e00f      	b.n	15be <xTaskGenericNotifyFromISR+0xee>

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    159e:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
    15a2:	2b02      	cmp	r3, #2
    15a4:	d007      	beq.n	15b6 <xTaskGenericNotifyFromISR+0xe6>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    15a6:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    15a8:	68bb      	ldr	r3, [r7, #8]
    15aa:	3310      	adds	r3, #16
    15ac:	009b      	lsls	r3, r3, #2
    15ae:	4413      	add	r3, r2
    15b0:	687a      	ldr	r2, [r7, #4]
    15b2:	605a      	str	r2, [r3, #4]
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
                    }

                    break;
    15b4:	e003      	b.n	15be <xTaskGenericNotifyFromISR+0xee>
                        xReturn = pdFAIL;
    15b6:	2300      	movs	r3, #0
    15b8:	637b      	str	r3, [r7, #52]	@ 0x34
                    break;
    15ba:	e000      	b.n	15be <xTaskGenericNotifyFromISR+0xee>

                    /* Should not get here if all enums are handled.
                     * Artificially force an assert by testing a value the
                     * compiler can't assume is const. */
                    configASSERT( xTickCount == ( TickType_t ) 0 );
                    break;
    15bc:	bf00      	nop

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    15be:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
    15c2:	2b01      	cmp	r3, #1
    15c4:	f040 8091 	bne.w	16ea <xTaskGenericNotifyFromISR+0x21a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
    15c8:	4b4e      	ldr	r3, [pc, #312]	@ (1704 <xTaskGenericNotifyFromISR+0x234>)
    15ca:	681b      	ldr	r3, [r3, #0]
    15cc:	2b00      	cmp	r3, #0
    15ce:	d160      	bne.n	1692 <xTaskGenericNotifyFromISR+0x1c2>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    15d0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    15d2:	695b      	ldr	r3, [r3, #20]
    15d4:	623b      	str	r3, [r7, #32]
    15d6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    15d8:	689b      	ldr	r3, [r3, #8]
    15da:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    15dc:	68d2      	ldr	r2, [r2, #12]
    15de:	609a      	str	r2, [r3, #8]
    15e0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    15e2:	68db      	ldr	r3, [r3, #12]
    15e4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    15e6:	6892      	ldr	r2, [r2, #8]
    15e8:	605a      	str	r2, [r3, #4]
    15ea:	6a3b      	ldr	r3, [r7, #32]
    15ec:	685a      	ldr	r2, [r3, #4]
    15ee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    15f0:	3304      	adds	r3, #4
    15f2:	429a      	cmp	r2, r3
    15f4:	d103      	bne.n	15fe <xTaskGenericNotifyFromISR+0x12e>
    15f6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    15f8:	68da      	ldr	r2, [r3, #12]
    15fa:	6a3b      	ldr	r3, [r7, #32]
    15fc:	605a      	str	r2, [r3, #4]
    15fe:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1600:	2200      	movs	r2, #0
    1602:	615a      	str	r2, [r3, #20]
    1604:	6a3b      	ldr	r3, [r7, #32]
    1606:	681b      	ldr	r3, [r3, #0]
    1608:	1e5a      	subs	r2, r3, #1
    160a:	6a3b      	ldr	r3, [r7, #32]
    160c:	601a      	str	r2, [r3, #0]
                    prvAddTaskToReadyList( pxTCB );
    160e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1610:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
    1612:	2201      	movs	r2, #1
    1614:	409a      	lsls	r2, r3
    1616:	4b3c      	ldr	r3, [pc, #240]	@ (1708 <xTaskGenericNotifyFromISR+0x238>)
    1618:	681b      	ldr	r3, [r3, #0]
    161a:	4313      	orrs	r3, r2
    161c:	4a3a      	ldr	r2, [pc, #232]	@ (1708 <xTaskGenericNotifyFromISR+0x238>)
    161e:	6013      	str	r3, [r2, #0]
    1620:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1622:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    1624:	4939      	ldr	r1, [pc, #228]	@ (170c <xTaskGenericNotifyFromISR+0x23c>)
    1626:	4613      	mov	r3, r2
    1628:	009b      	lsls	r3, r3, #2
    162a:	4413      	add	r3, r2
    162c:	009b      	lsls	r3, r3, #2
    162e:	440b      	add	r3, r1
    1630:	3304      	adds	r3, #4
    1632:	681b      	ldr	r3, [r3, #0]
    1634:	61fb      	str	r3, [r7, #28]
    1636:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1638:	69fa      	ldr	r2, [r7, #28]
    163a:	609a      	str	r2, [r3, #8]
    163c:	69fb      	ldr	r3, [r7, #28]
    163e:	689a      	ldr	r2, [r3, #8]
    1640:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1642:	60da      	str	r2, [r3, #12]
    1644:	69fb      	ldr	r3, [r7, #28]
    1646:	689b      	ldr	r3, [r3, #8]
    1648:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    164a:	3204      	adds	r2, #4
    164c:	605a      	str	r2, [r3, #4]
    164e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1650:	1d1a      	adds	r2, r3, #4
    1652:	69fb      	ldr	r3, [r7, #28]
    1654:	609a      	str	r2, [r3, #8]
    1656:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1658:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    165a:	4613      	mov	r3, r2
    165c:	009b      	lsls	r3, r3, #2
    165e:	4413      	add	r3, r2
    1660:	009b      	lsls	r3, r3, #2
    1662:	4a2a      	ldr	r2, [pc, #168]	@ (170c <xTaskGenericNotifyFromISR+0x23c>)
    1664:	441a      	add	r2, r3
    1666:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    1668:	615a      	str	r2, [r3, #20]
    166a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    166c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    166e:	4927      	ldr	r1, [pc, #156]	@ (170c <xTaskGenericNotifyFromISR+0x23c>)
    1670:	4613      	mov	r3, r2
    1672:	009b      	lsls	r3, r3, #2
    1674:	4413      	add	r3, r2
    1676:	009b      	lsls	r3, r3, #2
    1678:	440b      	add	r3, r1
    167a:	681b      	ldr	r3, [r3, #0]
    167c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    167e:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
    1680:	1c59      	adds	r1, r3, #1
    1682:	4822      	ldr	r0, [pc, #136]	@ (170c <xTaskGenericNotifyFromISR+0x23c>)
    1684:	4613      	mov	r3, r2
    1686:	009b      	lsls	r3, r3, #2
    1688:	4413      	add	r3, r2
    168a:	009b      	lsls	r3, r3, #2
    168c:	4403      	add	r3, r0
    168e:	6019      	str	r1, [r3, #0]
    1690:	e01b      	b.n	16ca <xTaskGenericNotifyFromISR+0x1fa>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1692:	4b1f      	ldr	r3, [pc, #124]	@ (1710 <xTaskGenericNotifyFromISR+0x240>)
    1694:	685b      	ldr	r3, [r3, #4]
    1696:	627b      	str	r3, [r7, #36]	@ 0x24
    1698:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    169a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
    169c:	61da      	str	r2, [r3, #28]
    169e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    16a0:	689a      	ldr	r2, [r3, #8]
    16a2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    16a4:	621a      	str	r2, [r3, #32]
    16a6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    16a8:	689b      	ldr	r3, [r3, #8]
    16aa:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
    16ac:	3218      	adds	r2, #24
    16ae:	605a      	str	r2, [r3, #4]
    16b0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    16b2:	f103 0218 	add.w	r2, r3, #24
    16b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    16b8:	609a      	str	r2, [r3, #8]
    16ba:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    16bc:	4a14      	ldr	r2, [pc, #80]	@ (1710 <xTaskGenericNotifyFromISR+0x240>)
    16be:	629a      	str	r2, [r3, #40]	@ 0x28
    16c0:	4b13      	ldr	r3, [pc, #76]	@ (1710 <xTaskGenericNotifyFromISR+0x240>)
    16c2:	681b      	ldr	r3, [r3, #0]
    16c4:	3301      	adds	r3, #1
    16c6:	4a12      	ldr	r2, [pc, #72]	@ (1710 <xTaskGenericNotifyFromISR+0x240>)
    16c8:	6013      	str	r3, [r2, #0]
                }

                #if ( configNUMBER_OF_CORES == 1 )
                {
                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    16ca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    16cc:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    16ce:	4b11      	ldr	r3, [pc, #68]	@ (1714 <xTaskGenericNotifyFromISR+0x244>)
    16d0:	681b      	ldr	r3, [r3, #0]
    16d2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
    16d4:	429a      	cmp	r2, r3
    16d6:	d908      	bls.n	16ea <xTaskGenericNotifyFromISR+0x21a>
                    {
                        /* The notified task has a priority above the currently
                         * executing task so a yield is required. */
                        if( pxHigherPriorityTaskWoken != NULL )
    16d8:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
    16da:	2b00      	cmp	r3, #0
    16dc:	d002      	beq.n	16e4 <xTaskGenericNotifyFromISR+0x214>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    16de:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
    16e0:	2201      	movs	r2, #1
    16e2:	601a      	str	r2, [r3, #0]
                        }

                        /* Mark that a yield is pending in case the user is not
                         * using the "xHigherPriorityTaskWoken" parameter to an ISR
                         * safe FreeRTOS function. */
                        xYieldPendings[ 0 ] = pdTRUE;
    16e4:	4b0c      	ldr	r3, [pc, #48]	@ (1718 <xTaskGenericNotifyFromISR+0x248>)
    16e6:	2201      	movs	r2, #1
    16e8:	601a      	str	r2, [r3, #0]
    16ea:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
    16ec:	613b      	str	r3, [r7, #16]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
    __asm volatile
    16ee:	693b      	ldr	r3, [r7, #16]
    16f0:	f383 8811 	msr	BASEPRI, r3
    (
        "   msr basepri, %0 " ::"r" ( ulNewMaskValue ) : "memory"
    );
}
    16f4:	bf00      	nop
        }
        taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );

        traceRETURN_xTaskGenericNotifyFromISR( xReturn );

        return xReturn;
    16f6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    }
    16f8:	4618      	mov	r0, r3
    16fa:	373c      	adds	r7, #60	@ 0x3c
    16fc:	46bd      	mov	sp, r7
    16fe:	bc80      	pop	{r7}
    1700:	4770      	bx	lr
    1702:	bf00      	nop
    1704:	00002460 	andeq	r2, r0, r0, ror #8
    1708:	00002440 	andeq	r2, r0, r0, asr #8
    170c:	00002390 	muleq	r0, r0, r3
    1710:	00002424 	andeq	r2, r0, r4, lsr #8
    1714:	0000238c 	andeq	r2, r0, ip, lsl #7
    1718:	0000244c 	andeq	r2, r0, ip, asr #8

0000171c <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    171c:	b480      	push	{r7}
    171e:	b08f      	sub	sp, #60	@ 0x3c
    1720:	af00      	add	r7, sp, #0
    1722:	60f8      	str	r0, [r7, #12]
    1724:	60b9      	str	r1, [r7, #8]
    1726:	607a      	str	r2, [r7, #4]
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    1728:	68fb      	ldr	r3, [r7, #12]
    172a:	637b      	str	r3, [r7, #52]	@ 0x34
    __asm volatile
    172c:	f3ef 8211 	mrs	r2, BASEPRI
    1730:	f04f 0301 	mov.w	r3, #1
    1734:	f383 8811 	msr	BASEPRI, r3
    1738:	f3bf 8f6f 	isb	sy
    173c:	f3bf 8f4f 	dsb	sy
    1740:	61fa      	str	r2, [r7, #28]
    1742:	61bb      	str	r3, [r7, #24]
    return ulOriginalBASEPRI;
    1744:	69fb      	ldr	r3, [r7, #28]

        /* MISRA Ref 4.7.1 [Return value shall be checked] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#dir-47 */
        /* coverity[misra_c_2012_directive_4_7_violation] */
        uxSavedInterruptStatus = ( UBaseType_t ) taskENTER_CRITICAL_FROM_ISR();
    1746:	633b      	str	r3, [r7, #48]	@ 0x30
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    1748:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
    174a:	68bb      	ldr	r3, [r7, #8]
    174c:	4413      	add	r3, r2
    174e:	3348      	adds	r3, #72	@ 0x48
    1750:	781b      	ldrb	r3, [r3, #0]
    1752:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1756:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
    1758:	68bb      	ldr	r3, [r7, #8]
    175a:	4413      	add	r3, r2
    175c:	3348      	adds	r3, #72	@ 0x48
    175e:	2202      	movs	r2, #2
    1760:	701a      	strb	r2, [r3, #0]

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    1762:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
    1764:	68bb      	ldr	r3, [r7, #8]
    1766:	3310      	adds	r3, #16
    1768:	009b      	lsls	r3, r3, #2
    176a:	4413      	add	r3, r2
    176c:	685b      	ldr	r3, [r3, #4]
    176e:	1c5a      	adds	r2, r3, #1
    1770:	6b79      	ldr	r1, [r7, #52]	@ 0x34
    1772:	68bb      	ldr	r3, [r7, #8]
    1774:	3310      	adds	r3, #16
    1776:	009b      	lsls	r3, r3, #2
    1778:	440b      	add	r3, r1
    177a:	605a      	str	r2, [r3, #4]

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    177c:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
    1780:	2b01      	cmp	r3, #1
    1782:	f040 8091 	bne.w	18a8 <vTaskGenericNotifyGiveFromISR+0x18c>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
    1786:	4b4e      	ldr	r3, [pc, #312]	@ (18c0 <vTaskGenericNotifyGiveFromISR+0x1a4>)
    1788:	681b      	ldr	r3, [r3, #0]
    178a:	2b00      	cmp	r3, #0
    178c:	d160      	bne.n	1850 <vTaskGenericNotifyGiveFromISR+0x134>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    178e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    1790:	695b      	ldr	r3, [r3, #20]
    1792:	627b      	str	r3, [r7, #36]	@ 0x24
    1794:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    1796:	689b      	ldr	r3, [r3, #8]
    1798:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
    179a:	68d2      	ldr	r2, [r2, #12]
    179c:	609a      	str	r2, [r3, #8]
    179e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    17a0:	68db      	ldr	r3, [r3, #12]
    17a2:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
    17a4:	6892      	ldr	r2, [r2, #8]
    17a6:	605a      	str	r2, [r3, #4]
    17a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    17aa:	685a      	ldr	r2, [r3, #4]
    17ac:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    17ae:	3304      	adds	r3, #4
    17b0:	429a      	cmp	r2, r3
    17b2:	d103      	bne.n	17bc <vTaskGenericNotifyGiveFromISR+0xa0>
    17b4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    17b6:	68da      	ldr	r2, [r3, #12]
    17b8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    17ba:	605a      	str	r2, [r3, #4]
    17bc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    17be:	2200      	movs	r2, #0
    17c0:	615a      	str	r2, [r3, #20]
    17c2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    17c4:	681b      	ldr	r3, [r3, #0]
    17c6:	1e5a      	subs	r2, r3, #1
    17c8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
    17ca:	601a      	str	r2, [r3, #0]
                    prvAddTaskToReadyList( pxTCB );
    17cc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    17ce:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
    17d0:	2201      	movs	r2, #1
    17d2:	409a      	lsls	r2, r3
    17d4:	4b3b      	ldr	r3, [pc, #236]	@ (18c4 <vTaskGenericNotifyGiveFromISR+0x1a8>)
    17d6:	681b      	ldr	r3, [r3, #0]
    17d8:	4313      	orrs	r3, r2
    17da:	4a3a      	ldr	r2, [pc, #232]	@ (18c4 <vTaskGenericNotifyGiveFromISR+0x1a8>)
    17dc:	6013      	str	r3, [r2, #0]
    17de:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    17e0:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    17e2:	4939      	ldr	r1, [pc, #228]	@ (18c8 <vTaskGenericNotifyGiveFromISR+0x1ac>)
    17e4:	4613      	mov	r3, r2
    17e6:	009b      	lsls	r3, r3, #2
    17e8:	4413      	add	r3, r2
    17ea:	009b      	lsls	r3, r3, #2
    17ec:	440b      	add	r3, r1
    17ee:	3304      	adds	r3, #4
    17f0:	681b      	ldr	r3, [r3, #0]
    17f2:	623b      	str	r3, [r7, #32]
    17f4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    17f6:	6a3a      	ldr	r2, [r7, #32]
    17f8:	609a      	str	r2, [r3, #8]
    17fa:	6a3b      	ldr	r3, [r7, #32]
    17fc:	689a      	ldr	r2, [r3, #8]
    17fe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    1800:	60da      	str	r2, [r3, #12]
    1802:	6a3b      	ldr	r3, [r7, #32]
    1804:	689b      	ldr	r3, [r3, #8]
    1806:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
    1808:	3204      	adds	r2, #4
    180a:	605a      	str	r2, [r3, #4]
    180c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    180e:	1d1a      	adds	r2, r3, #4
    1810:	6a3b      	ldr	r3, [r7, #32]
    1812:	609a      	str	r2, [r3, #8]
    1814:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    1816:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    1818:	4613      	mov	r3, r2
    181a:	009b      	lsls	r3, r3, #2
    181c:	4413      	add	r3, r2
    181e:	009b      	lsls	r3, r3, #2
    1820:	4a29      	ldr	r2, [pc, #164]	@ (18c8 <vTaskGenericNotifyGiveFromISR+0x1ac>)
    1822:	441a      	add	r2, r3
    1824:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    1826:	615a      	str	r2, [r3, #20]
    1828:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    182a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    182c:	4926      	ldr	r1, [pc, #152]	@ (18c8 <vTaskGenericNotifyGiveFromISR+0x1ac>)
    182e:	4613      	mov	r3, r2
    1830:	009b      	lsls	r3, r3, #2
    1832:	4413      	add	r3, r2
    1834:	009b      	lsls	r3, r3, #2
    1836:	440b      	add	r3, r1
    1838:	681b      	ldr	r3, [r3, #0]
    183a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
    183c:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
    183e:	1c59      	adds	r1, r3, #1
    1840:	4821      	ldr	r0, [pc, #132]	@ (18c8 <vTaskGenericNotifyGiveFromISR+0x1ac>)
    1842:	4613      	mov	r3, r2
    1844:	009b      	lsls	r3, r3, #2
    1846:	4413      	add	r3, r2
    1848:	009b      	lsls	r3, r3, #2
    184a:	4403      	add	r3, r0
    184c:	6019      	str	r1, [r3, #0]
    184e:	e01b      	b.n	1888 <vTaskGenericNotifyGiveFromISR+0x16c>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1850:	4b1e      	ldr	r3, [pc, #120]	@ (18cc <vTaskGenericNotifyGiveFromISR+0x1b0>)
    1852:	685b      	ldr	r3, [r3, #4]
    1854:	62bb      	str	r3, [r7, #40]	@ 0x28
    1856:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    1858:	6aba      	ldr	r2, [r7, #40]	@ 0x28
    185a:	61da      	str	r2, [r3, #28]
    185c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    185e:	689a      	ldr	r2, [r3, #8]
    1860:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    1862:	621a      	str	r2, [r3, #32]
    1864:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    1866:	689b      	ldr	r3, [r3, #8]
    1868:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
    186a:	3218      	adds	r2, #24
    186c:	605a      	str	r2, [r3, #4]
    186e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    1870:	f103 0218 	add.w	r2, r3, #24
    1874:	6abb      	ldr	r3, [r7, #40]	@ 0x28
    1876:	609a      	str	r2, [r3, #8]
    1878:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    187a:	4a14      	ldr	r2, [pc, #80]	@ (18cc <vTaskGenericNotifyGiveFromISR+0x1b0>)
    187c:	629a      	str	r2, [r3, #40]	@ 0x28
    187e:	4b13      	ldr	r3, [pc, #76]	@ (18cc <vTaskGenericNotifyGiveFromISR+0x1b0>)
    1880:	681b      	ldr	r3, [r3, #0]
    1882:	3301      	adds	r3, #1
    1884:	4a11      	ldr	r2, [pc, #68]	@ (18cc <vTaskGenericNotifyGiveFromISR+0x1b0>)
    1886:	6013      	str	r3, [r2, #0]
                }

                #if ( configNUMBER_OF_CORES == 1 )
                {
                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1888:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
    188a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
    188c:	4b10      	ldr	r3, [pc, #64]	@ (18d0 <vTaskGenericNotifyGiveFromISR+0x1b4>)
    188e:	681b      	ldr	r3, [r3, #0]
    1890:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
    1892:	429a      	cmp	r2, r3
    1894:	d908      	bls.n	18a8 <vTaskGenericNotifyGiveFromISR+0x18c>
                    {
                        /* The notified task has a priority above the currently
                         * executing task so a yield is required. */
                        if( pxHigherPriorityTaskWoken != NULL )
    1896:	687b      	ldr	r3, [r7, #4]
    1898:	2b00      	cmp	r3, #0
    189a:	d002      	beq.n	18a2 <vTaskGenericNotifyGiveFromISR+0x186>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    189c:	687b      	ldr	r3, [r7, #4]
    189e:	2201      	movs	r2, #1
    18a0:	601a      	str	r2, [r3, #0]
                        }

                        /* Mark that a yield is pending in case the user is not
                         * using the "xHigherPriorityTaskWoken" parameter in an ISR
                         * safe FreeRTOS function. */
                        xYieldPendings[ 0 ] = pdTRUE;
    18a2:	4b0c      	ldr	r3, [pc, #48]	@ (18d4 <vTaskGenericNotifyGiveFromISR+0x1b8>)
    18a4:	2201      	movs	r2, #1
    18a6:	601a      	str	r2, [r3, #0]
    18a8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
    18aa:	617b      	str	r3, [r7, #20]
    __asm volatile
    18ac:	697b      	ldr	r3, [r7, #20]
    18ae:	f383 8811 	msr	BASEPRI, r3
}
    18b2:	bf00      	nop
            }
        }
        taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );

        traceRETURN_vTaskGenericNotifyGiveFromISR();
    }
    18b4:	bf00      	nop
    18b6:	373c      	adds	r7, #60	@ 0x3c
    18b8:	46bd      	mov	sp, r7
    18ba:	bc80      	pop	{r7}
    18bc:	4770      	bx	lr
    18be:	bf00      	nop
    18c0:	00002460 	andeq	r2, r0, r0, ror #8
    18c4:	00002440 	andeq	r2, r0, r0, asr #8
    18c8:	00002390 	muleq	r0, r0, r3
    18cc:	00002424 	andeq	r2, r0, r4, lsr #8
    18d0:	0000238c 	andeq	r2, r0, ip, lsl #7
    18d4:	0000244c 	andeq	r2, r0, ip, asr #8

000018d8 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    18d8:	b580      	push	{r7, lr}
    18da:	b084      	sub	sp, #16
    18dc:	af00      	add	r7, sp, #0
    18de:	6078      	str	r0, [r7, #4]
    18e0:	6039      	str	r1, [r7, #0]

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    18e2:	687b      	ldr	r3, [r7, #4]
    18e4:	2b00      	cmp	r3, #0
    18e6:	d102      	bne.n	18ee <xTaskGenericNotifyStateClear+0x16>
    18e8:	4b10      	ldr	r3, [pc, #64]	@ (192c <xTaskGenericNotifyStateClear+0x54>)
    18ea:	681b      	ldr	r3, [r3, #0]
    18ec:	e000      	b.n	18f0 <xTaskGenericNotifyStateClear+0x18>
    18ee:	687b      	ldr	r3, [r7, #4]
    18f0:	60bb      	str	r3, [r7, #8]
        configASSERT( pxTCB != NULL );

        taskENTER_CRITICAL();
    18f2:	f000 fcad 	bl	2250 <vPortEnterCritical>
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    18f6:	68ba      	ldr	r2, [r7, #8]
    18f8:	683b      	ldr	r3, [r7, #0]
    18fa:	4413      	add	r3, r2
    18fc:	3348      	adds	r3, #72	@ 0x48
    18fe:	781b      	ldrb	r3, [r3, #0]
    1900:	b2db      	uxtb	r3, r3
    1902:	2b02      	cmp	r3, #2
    1904:	d108      	bne.n	1918 <xTaskGenericNotifyStateClear+0x40>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    1906:	68ba      	ldr	r2, [r7, #8]
    1908:	683b      	ldr	r3, [r7, #0]
    190a:	4413      	add	r3, r2
    190c:	3348      	adds	r3, #72	@ 0x48
    190e:	2200      	movs	r2, #0
    1910:	701a      	strb	r2, [r3, #0]
                xReturn = pdPASS;
    1912:	2301      	movs	r3, #1
    1914:	60fb      	str	r3, [r7, #12]
    1916:	e001      	b.n	191c <xTaskGenericNotifyStateClear+0x44>
            }
            else
            {
                xReturn = pdFAIL;
    1918:	2300      	movs	r3, #0
    191a:	60fb      	str	r3, [r7, #12]
            }
        }
        taskEXIT_CRITICAL();
    191c:	f000 fcb2 	bl	2284 <vPortExitCritical>

        traceRETURN_xTaskGenericNotifyStateClear( xReturn );

        return xReturn;
    1920:	68fb      	ldr	r3, [r7, #12]
    }
    1922:	4618      	mov	r0, r3
    1924:	3710      	adds	r7, #16
    1926:	46bd      	mov	sp, r7
    1928:	bd80      	pop	{r7, pc}
    192a:	bf00      	nop
    192c:	0000238c 	andeq	r2, r0, ip, lsl #7

00001930 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    1930:	b580      	push	{r7, lr}
    1932:	b086      	sub	sp, #24
    1934:	af00      	add	r7, sp, #0
    1936:	60f8      	str	r0, [r7, #12]
    1938:	60b9      	str	r1, [r7, #8]
    193a:	607a      	str	r2, [r7, #4]

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    193c:	68fb      	ldr	r3, [r7, #12]
    193e:	2b00      	cmp	r3, #0
    1940:	d102      	bne.n	1948 <ulTaskGenericNotifyValueClear+0x18>
    1942:	4b12      	ldr	r3, [pc, #72]	@ (198c <ulTaskGenericNotifyValueClear+0x5c>)
    1944:	681b      	ldr	r3, [r3, #0]
    1946:	e000      	b.n	194a <ulTaskGenericNotifyValueClear+0x1a>
    1948:	68fb      	ldr	r3, [r7, #12]
    194a:	617b      	str	r3, [r7, #20]
        configASSERT( pxTCB != NULL );

        taskENTER_CRITICAL();
    194c:	f000 fc80 	bl	2250 <vPortEnterCritical>
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    1950:	697a      	ldr	r2, [r7, #20]
    1952:	68bb      	ldr	r3, [r7, #8]
    1954:	3310      	adds	r3, #16
    1956:	009b      	lsls	r3, r3, #2
    1958:	4413      	add	r3, r2
    195a:	685b      	ldr	r3, [r3, #4]
    195c:	613b      	str	r3, [r7, #16]
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    195e:	697a      	ldr	r2, [r7, #20]
    1960:	68bb      	ldr	r3, [r7, #8]
    1962:	3310      	adds	r3, #16
    1964:	009b      	lsls	r3, r3, #2
    1966:	4413      	add	r3, r2
    1968:	685a      	ldr	r2, [r3, #4]
    196a:	687b      	ldr	r3, [r7, #4]
    196c:	43db      	mvns	r3, r3
    196e:	401a      	ands	r2, r3
    1970:	6979      	ldr	r1, [r7, #20]
    1972:	68bb      	ldr	r3, [r7, #8]
    1974:	3310      	adds	r3, #16
    1976:	009b      	lsls	r3, r3, #2
    1978:	440b      	add	r3, r1
    197a:	605a      	str	r2, [r3, #4]
        }
        taskEXIT_CRITICAL();
    197c:	f000 fc82 	bl	2284 <vPortExitCritical>

        traceRETURN_ulTaskGenericNotifyValueClear( ulReturn );

        return ulReturn;
    1980:	693b      	ldr	r3, [r7, #16]
    }
    1982:	4618      	mov	r0, r3
    1984:	3718      	adds	r7, #24
    1986:	46bd      	mov	sp, r7
    1988:	bd80      	pop	{r7, pc}
    198a:	bf00      	nop
    198c:	0000238c 	andeq	r2, r0, ip, lsl #7

00001990 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    1990:	b580      	push	{r7, lr}
    1992:	b086      	sub	sp, #24
    1994:	af00      	add	r7, sp, #0
    1996:	6078      	str	r0, [r7, #4]
    1998:	6039      	str	r1, [r7, #0]
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    199a:	4b22      	ldr	r3, [pc, #136]	@ (1a24 <prvAddCurrentTaskToDelayedList+0x94>)
    199c:	681b      	ldr	r3, [r3, #0]
    199e:	617b      	str	r3, [r7, #20]
    List_t * const pxDelayedList = pxDelayedTaskList;
    19a0:	4b21      	ldr	r3, [pc, #132]	@ (1a28 <prvAddCurrentTaskToDelayedList+0x98>)
    19a2:	681b      	ldr	r3, [r3, #0]
    19a4:	613b      	str	r3, [r7, #16]
    List_t * const pxOverflowDelayedList = pxOverflowDelayedTaskList;
    19a6:	4b21      	ldr	r3, [pc, #132]	@ (1a2c <prvAddCurrentTaskToDelayedList+0x9c>)
    19a8:	681b      	ldr	r3, [r3, #0]
    19aa:	60fb      	str	r3, [r7, #12]
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    19ac:	4b20      	ldr	r3, [pc, #128]	@ (1a30 <prvAddCurrentTaskToDelayedList+0xa0>)
    19ae:	681b      	ldr	r3, [r3, #0]
    19b0:	3304      	adds	r3, #4
    19b2:	4618      	mov	r0, r3
    19b4:	f000 f912 	bl	1bdc <uxListRemove>
    19b8:	4603      	mov	r3, r0
    19ba:	2b00      	cmp	r3, #0
    19bc:	d10b      	bne.n	19d6 <prvAddCurrentTaskToDelayedList+0x46>
    {
        /* The current task must be in a ready list, so there is no need to
         * check, and the port reset macro can be called directly. */
        portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    19be:	4b1c      	ldr	r3, [pc, #112]	@ (1a30 <prvAddCurrentTaskToDelayedList+0xa0>)
    19c0:	681b      	ldr	r3, [r3, #0]
    19c2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
    19c4:	2201      	movs	r2, #1
    19c6:	fa02 f303 	lsl.w	r3, r2, r3
    19ca:	43da      	mvns	r2, r3
    19cc:	4b19      	ldr	r3, [pc, #100]	@ (1a34 <prvAddCurrentTaskToDelayedList+0xa4>)
    19ce:	681b      	ldr	r3, [r3, #0]
    19d0:	4013      	ands	r3, r2
    19d2:	4a18      	ldr	r2, [pc, #96]	@ (1a34 <prvAddCurrentTaskToDelayedList+0xa4>)
    19d4:	6013      	str	r3, [r2, #0]
    #else /* INCLUDE_vTaskSuspend */
    {
        /* Calculate the time at which the task should be woken if the event
         * does not occur.  This may overflow but this doesn't matter, the kernel
         * will manage it correctly. */
        xTimeToWake = xConstTickCount + xTicksToWait;
    19d6:	697a      	ldr	r2, [r7, #20]
    19d8:	687b      	ldr	r3, [r7, #4]
    19da:	4413      	add	r3, r2
    19dc:	60bb      	str	r3, [r7, #8]

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    19de:	4b14      	ldr	r3, [pc, #80]	@ (1a30 <prvAddCurrentTaskToDelayedList+0xa0>)
    19e0:	681b      	ldr	r3, [r3, #0]
    19e2:	68ba      	ldr	r2, [r7, #8]
    19e4:	605a      	str	r2, [r3, #4]

        if( xTimeToWake < xConstTickCount )
    19e6:	68ba      	ldr	r2, [r7, #8]
    19e8:	697b      	ldr	r3, [r7, #20]
    19ea:	429a      	cmp	r2, r3
    19ec:	d207      	bcs.n	19fe <prvAddCurrentTaskToDelayedList+0x6e>
        {
            traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
            /* Wake time has overflowed.  Place this item in the overflow list. */
            vListInsert( pxOverflowDelayedList, &( pxCurrentTCB->xStateListItem ) );
    19ee:	4b10      	ldr	r3, [pc, #64]	@ (1a30 <prvAddCurrentTaskToDelayedList+0xa0>)
    19f0:	681b      	ldr	r3, [r3, #0]
    19f2:	3304      	adds	r3, #4
    19f4:	4619      	mov	r1, r3
    19f6:	68f8      	ldr	r0, [r7, #12]
    19f8:	f000 f8b8 	bl	1b6c <vListInsert>

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
    19fc:	e00e      	b.n	1a1c <prvAddCurrentTaskToDelayedList+0x8c>
            vListInsert( pxDelayedList, &( pxCurrentTCB->xStateListItem ) );
    19fe:	4b0c      	ldr	r3, [pc, #48]	@ (1a30 <prvAddCurrentTaskToDelayedList+0xa0>)
    1a00:	681b      	ldr	r3, [r3, #0]
    1a02:	3304      	adds	r3, #4
    1a04:	4619      	mov	r1, r3
    1a06:	6938      	ldr	r0, [r7, #16]
    1a08:	f000 f8b0 	bl	1b6c <vListInsert>
            if( xTimeToWake < xNextTaskUnblockTime )
    1a0c:	4b0a      	ldr	r3, [pc, #40]	@ (1a38 <prvAddCurrentTaskToDelayedList+0xa8>)
    1a0e:	681b      	ldr	r3, [r3, #0]
    1a10:	68ba      	ldr	r2, [r7, #8]
    1a12:	429a      	cmp	r2, r3
    1a14:	d202      	bcs.n	1a1c <prvAddCurrentTaskToDelayedList+0x8c>
                xNextTaskUnblockTime = xTimeToWake;
    1a16:	4a08      	ldr	r2, [pc, #32]	@ (1a38 <prvAddCurrentTaskToDelayedList+0xa8>)
    1a18:	68bb      	ldr	r3, [r7, #8]
    1a1a:	6013      	str	r3, [r2, #0]
}
    1a1c:	bf00      	nop
    1a1e:	3718      	adds	r7, #24
    1a20:	46bd      	mov	sp, r7
    1a22:	bd80      	pop	{r7, pc}
    1a24:	0000243c 	andeq	r2, r0, ip, lsr r4
    1a28:	0000241c 	andeq	r2, r0, ip, lsl r4
    1a2c:	00002420 	andeq	r2, r0, r0, lsr #8
    1a30:	0000238c 	andeq	r2, r0, ip, lsl #7
    1a34:	00002440 	andeq	r2, r0, r0, asr #8
    1a38:	00002458 	andeq	r2, r0, r8, asr r4

00001a3c <vTaskResetState>:
 * Reset the state in this file. This state is normally initialized at start up.
 * This function must be called by the application before restarting the
 * scheduler.
 */
void vTaskResetState( void )
{
    1a3c:	b480      	push	{r7}
    1a3e:	b083      	sub	sp, #12
    1a40:	af00      	add	r7, sp, #0
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
    1a42:	4b18      	ldr	r3, [pc, #96]	@ (1aa4 <vTaskResetState+0x68>)
    1a44:	2200      	movs	r2, #0
    1a46:	601a      	str	r2, [r3, #0]
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
    1a48:	4b17      	ldr	r3, [pc, #92]	@ (1aa8 <vTaskResetState+0x6c>)
    1a4a:	2200      	movs	r2, #0
    1a4c:	601a      	str	r2, [r3, #0]
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    1a4e:	4b17      	ldr	r3, [pc, #92]	@ (1aac <vTaskResetState+0x70>)
    1a50:	2200      	movs	r2, #0
    1a52:	601a      	str	r2, [r3, #0]
    uxTopReadyPriority = tskIDLE_PRIORITY;
    1a54:	4b16      	ldr	r3, [pc, #88]	@ (1ab0 <vTaskResetState+0x74>)
    1a56:	2200      	movs	r2, #0
    1a58:	601a      	str	r2, [r3, #0]
    xSchedulerRunning = pdFALSE;
    1a5a:	4b16      	ldr	r3, [pc, #88]	@ (1ab4 <vTaskResetState+0x78>)
    1a5c:	2200      	movs	r2, #0
    1a5e:	601a      	str	r2, [r3, #0]
    xPendedTicks = ( TickType_t ) 0U;
    1a60:	4b15      	ldr	r3, [pc, #84]	@ (1ab8 <vTaskResetState+0x7c>)
    1a62:	2200      	movs	r2, #0
    1a64:	601a      	str	r2, [r3, #0]

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    1a66:	2300      	movs	r3, #0
    1a68:	607b      	str	r3, [r7, #4]
    1a6a:	e007      	b.n	1a7c <vTaskResetState+0x40>
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
    1a6c:	4a13      	ldr	r2, [pc, #76]	@ (1abc <vTaskResetState+0x80>)
    1a6e:	687b      	ldr	r3, [r7, #4]
    1a70:	2100      	movs	r1, #0
    1a72:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    1a76:	687b      	ldr	r3, [r7, #4]
    1a78:	3301      	adds	r3, #1
    1a7a:	607b      	str	r3, [r7, #4]
    1a7c:	687b      	ldr	r3, [r7, #4]
    1a7e:	2b00      	cmp	r3, #0
    1a80:	ddf4      	ble.n	1a6c <vTaskResetState+0x30>
    }

    xNumOfOverflows = ( BaseType_t ) 0;
    1a82:	4b0f      	ldr	r3, [pc, #60]	@ (1ac0 <vTaskResetState+0x84>)
    1a84:	2200      	movs	r2, #0
    1a86:	601a      	str	r2, [r3, #0]
    uxTaskNumber = ( UBaseType_t ) 0U;
    1a88:	4b0e      	ldr	r3, [pc, #56]	@ (1ac4 <vTaskResetState+0x88>)
    1a8a:	2200      	movs	r2, #0
    1a8c:	601a      	str	r2, [r3, #0]
    xNextTaskUnblockTime = ( TickType_t ) 0U;
    1a8e:	4b0e      	ldr	r3, [pc, #56]	@ (1ac8 <vTaskResetState+0x8c>)
    1a90:	2200      	movs	r2, #0
    1a92:	601a      	str	r2, [r3, #0]

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
    1a94:	4b0d      	ldr	r3, [pc, #52]	@ (1acc <vTaskResetState+0x90>)
    1a96:	2200      	movs	r2, #0
    1a98:	601a      	str	r2, [r3, #0]
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
    1a9a:	bf00      	nop
    1a9c:	370c      	adds	r7, #12
    1a9e:	46bd      	mov	sp, r7
    1aa0:	bc80      	pop	{r7}
    1aa2:	4770      	bx	lr
    1aa4:	0000238c 	andeq	r2, r0, ip, lsl #7
    1aa8:	00002438 	andeq	r2, r0, r8, lsr r4
    1aac:	0000243c 	andeq	r2, r0, ip, lsr r4
    1ab0:	00002440 	andeq	r2, r0, r0, asr #8
    1ab4:	00002444 	andeq	r2, r0, r4, asr #8
    1ab8:	00002448 	andeq	r2, r0, r8, asr #8
    1abc:	0000244c 	andeq	r2, r0, ip, asr #8
    1ac0:	00002450 	andeq	r2, r0, r0, asr r4
    1ac4:	00002454 	andeq	r2, r0, r4, asr r4
    1ac8:	00002458 	andeq	r2, r0, r8, asr r4
    1acc:	00002460 	andeq	r2, r0, r0, ror #8

00001ad0 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1ad0:	b480      	push	{r7}
    1ad2:	b083      	sub	sp, #12
    1ad4:	af00      	add	r7, sp, #0
    1ad6:	6078      	str	r0, [r7, #4]
    traceENTER_vListInitialise( pxList );

    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );
    1ad8:	687b      	ldr	r3, [r7, #4]
    1ada:	f103 0208 	add.w	r2, r3, #8
    1ade:	687b      	ldr	r3, [r7, #4]
    1ae0:	605a      	str	r2, [r3, #4]

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    1ae2:	687b      	ldr	r3, [r7, #4]
    1ae4:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
    1ae8:	609a      	str	r2, [r3, #8]

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );
    1aea:	687b      	ldr	r3, [r7, #4]
    1aec:	f103 0208 	add.w	r2, r3, #8
    1af0:	687b      	ldr	r3, [r7, #4]
    1af2:	60da      	str	r2, [r3, #12]
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );
    1af4:	687b      	ldr	r3, [r7, #4]
    1af6:	f103 0208 	add.w	r2, r3, #8
    1afa:	687b      	ldr	r3, [r7, #4]
    1afc:	611a      	str	r2, [r3, #16]
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1afe:	687b      	ldr	r3, [r7, #4]
    1b00:	2200      	movs	r2, #0
    1b02:	601a      	str	r2, [r3, #0]
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );

    traceRETURN_vListInitialise();
}
    1b04:	bf00      	nop
    1b06:	370c      	adds	r7, #12
    1b08:	46bd      	mov	sp, r7
    1b0a:	bc80      	pop	{r7}
    1b0c:	4770      	bx	lr

00001b0e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1b0e:	b480      	push	{r7}
    1b10:	b083      	sub	sp, #12
    1b12:	af00      	add	r7, sp, #0
    1b14:	6078      	str	r0, [r7, #4]
    traceENTER_vListInitialiseItem( pxItem );

    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    1b16:	687b      	ldr	r3, [r7, #4]
    1b18:	2200      	movs	r2, #0
    1b1a:	611a      	str	r2, [r3, #16]
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );

    traceRETURN_vListInitialiseItem();
}
    1b1c:	bf00      	nop
    1b1e:	370c      	adds	r7, #12
    1b20:	46bd      	mov	sp, r7
    1b22:	bc80      	pop	{r7}
    1b24:	4770      	bx	lr

00001b26 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    1b26:	b480      	push	{r7}
    1b28:	b085      	sub	sp, #20
    1b2a:	af00      	add	r7, sp, #0
    1b2c:	6078      	str	r0, [r7, #4]
    1b2e:	6039      	str	r1, [r7, #0]
    ListItem_t * const pxIndex = pxList->pxIndex;
    1b30:	687b      	ldr	r3, [r7, #4]
    1b32:	685b      	ldr	r3, [r3, #4]
    1b34:	60fb      	str	r3, [r7, #12]
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1b36:	683b      	ldr	r3, [r7, #0]
    1b38:	68fa      	ldr	r2, [r7, #12]
    1b3a:	605a      	str	r2, [r3, #4]
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1b3c:	68fb      	ldr	r3, [r7, #12]
    1b3e:	689a      	ldr	r2, [r3, #8]
    1b40:	683b      	ldr	r3, [r7, #0]
    1b42:	609a      	str	r2, [r3, #8]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1b44:	68fb      	ldr	r3, [r7, #12]
    1b46:	689b      	ldr	r3, [r3, #8]
    1b48:	683a      	ldr	r2, [r7, #0]
    1b4a:	605a      	str	r2, [r3, #4]
    pxIndex->pxPrevious = pxNewListItem;
    1b4c:	68fb      	ldr	r3, [r7, #12]
    1b4e:	683a      	ldr	r2, [r7, #0]
    1b50:	609a      	str	r2, [r3, #8]

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1b52:	683b      	ldr	r3, [r7, #0]
    1b54:	687a      	ldr	r2, [r7, #4]
    1b56:	611a      	str	r2, [r3, #16]

    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems + 1U );
    1b58:	687b      	ldr	r3, [r7, #4]
    1b5a:	681b      	ldr	r3, [r3, #0]
    1b5c:	1c5a      	adds	r2, r3, #1
    1b5e:	687b      	ldr	r3, [r7, #4]
    1b60:	601a      	str	r2, [r3, #0]

    traceRETURN_vListInsertEnd();
}
    1b62:	bf00      	nop
    1b64:	3714      	adds	r7, #20
    1b66:	46bd      	mov	sp, r7
    1b68:	bc80      	pop	{r7}
    1b6a:	4770      	bx	lr

00001b6c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    1b6c:	b480      	push	{r7}
    1b6e:	b085      	sub	sp, #20
    1b70:	af00      	add	r7, sp, #0
    1b72:	6078      	str	r0, [r7, #4]
    1b74:	6039      	str	r1, [r7, #0]
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1b76:	683b      	ldr	r3, [r7, #0]
    1b78:	681b      	ldr	r3, [r3, #0]
    1b7a:	60bb      	str	r3, [r7, #8]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1b7c:	68bb      	ldr	r3, [r7, #8]
    1b7e:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
    1b82:	d103      	bne.n	1b8c <vListInsert+0x20>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1b84:	687b      	ldr	r3, [r7, #4]
    1b86:	691b      	ldr	r3, [r3, #16]
    1b88:	60fb      	str	r3, [r7, #12]
    1b8a:	e00c      	b.n	1ba6 <vListInsert+0x3a>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1b8c:	687b      	ldr	r3, [r7, #4]
    1b8e:	3308      	adds	r3, #8
    1b90:	60fb      	str	r3, [r7, #12]
    1b92:	e002      	b.n	1b9a <vListInsert+0x2e>
    1b94:	68fb      	ldr	r3, [r7, #12]
    1b96:	685b      	ldr	r3, [r3, #4]
    1b98:	60fb      	str	r3, [r7, #12]
    1b9a:	68fb      	ldr	r3, [r7, #12]
    1b9c:	685b      	ldr	r3, [r3, #4]
    1b9e:	681b      	ldr	r3, [r3, #0]
    1ba0:	68ba      	ldr	r2, [r7, #8]
    1ba2:	429a      	cmp	r2, r3
    1ba4:	d2f6      	bcs.n	1b94 <vListInsert+0x28>
             * IF YOU FIND YOUR CODE STUCK HERE, SEE THE NOTE JUST ABOVE.
             */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1ba6:	68fb      	ldr	r3, [r7, #12]
    1ba8:	685a      	ldr	r2, [r3, #4]
    1baa:	683b      	ldr	r3, [r7, #0]
    1bac:	605a      	str	r2, [r3, #4]
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1bae:	683b      	ldr	r3, [r7, #0]
    1bb0:	685b      	ldr	r3, [r3, #4]
    1bb2:	683a      	ldr	r2, [r7, #0]
    1bb4:	609a      	str	r2, [r3, #8]
    pxNewListItem->pxPrevious = pxIterator;
    1bb6:	683b      	ldr	r3, [r7, #0]
    1bb8:	68fa      	ldr	r2, [r7, #12]
    1bba:	609a      	str	r2, [r3, #8]
    pxIterator->pxNext = pxNewListItem;
    1bbc:	68fb      	ldr	r3, [r7, #12]
    1bbe:	683a      	ldr	r2, [r7, #0]
    1bc0:	605a      	str	r2, [r3, #4]

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    1bc2:	683b      	ldr	r3, [r7, #0]
    1bc4:	687a      	ldr	r2, [r7, #4]
    1bc6:	611a      	str	r2, [r3, #16]

    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems + 1U );
    1bc8:	687b      	ldr	r3, [r7, #4]
    1bca:	681b      	ldr	r3, [r3, #0]
    1bcc:	1c5a      	adds	r2, r3, #1
    1bce:	687b      	ldr	r3, [r7, #4]
    1bd0:	601a      	str	r2, [r3, #0]

    traceRETURN_vListInsert();
}
    1bd2:	bf00      	nop
    1bd4:	3714      	adds	r7, #20
    1bd6:	46bd      	mov	sp, r7
    1bd8:	bc80      	pop	{r7}
    1bda:	4770      	bx	lr

00001bdc <uxListRemove>:
/*-----------------------------------------------------------*/


UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1bdc:	b480      	push	{r7}
    1bde:	b085      	sub	sp, #20
    1be0:	af00      	add	r7, sp, #0
    1be2:	6078      	str	r0, [r7, #4]
    /* The list item knows which list it is in.  Obtain the list from the list
     * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    1be4:	687b      	ldr	r3, [r7, #4]
    1be6:	691b      	ldr	r3, [r3, #16]
    1be8:	60fb      	str	r3, [r7, #12]

    traceENTER_uxListRemove( pxItemToRemove );

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1bea:	687b      	ldr	r3, [r7, #4]
    1bec:	685b      	ldr	r3, [r3, #4]
    1bee:	687a      	ldr	r2, [r7, #4]
    1bf0:	6892      	ldr	r2, [r2, #8]
    1bf2:	609a      	str	r2, [r3, #8]
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1bf4:	687b      	ldr	r3, [r7, #4]
    1bf6:	689b      	ldr	r3, [r3, #8]
    1bf8:	687a      	ldr	r2, [r7, #4]
    1bfa:	6852      	ldr	r2, [r2, #4]
    1bfc:	605a      	str	r2, [r3, #4]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    1bfe:	68fb      	ldr	r3, [r7, #12]
    1c00:	685b      	ldr	r3, [r3, #4]
    1c02:	687a      	ldr	r2, [r7, #4]
    1c04:	429a      	cmp	r2, r3
    1c06:	d103      	bne.n	1c10 <uxListRemove+0x34>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1c08:	687b      	ldr	r3, [r7, #4]
    1c0a:	689a      	ldr	r2, [r3, #8]
    1c0c:	68fb      	ldr	r3, [r7, #12]
    1c0e:	605a      	str	r2, [r3, #4]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    1c10:	687b      	ldr	r3, [r7, #4]
    1c12:	2200      	movs	r2, #0
    1c14:	611a      	str	r2, [r3, #16]
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems - 1U );
    1c16:	68fb      	ldr	r3, [r7, #12]
    1c18:	681b      	ldr	r3, [r3, #0]
    1c1a:	1e5a      	subs	r2, r3, #1
    1c1c:	68fb      	ldr	r3, [r7, #12]
    1c1e:	601a      	str	r2, [r3, #0]

    traceRETURN_uxListRemove( pxList->uxNumberOfItems );

    return pxList->uxNumberOfItems;
    1c20:	68fb      	ldr	r3, [r7, #12]
    1c22:	681b      	ldr	r3, [r3, #0]
}
    1c24:	4618      	mov	r0, r3
    1c26:	3714      	adds	r7, #20
    1c28:	46bd      	mov	sp, r7
    1c2a:	bc80      	pop	{r7}
    1c2c:	4770      	bx	lr
	...

00001c30 <pvPortMalloc>:
PRIVILEGED_DATA static size_t xNumberOfSuccessfulFrees = ( size_t ) 0U;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    1c30:	b580      	push	{r7, lr}
    1c32:	b088      	sub	sp, #32
    1c34:	af00      	add	r7, sp, #0
    1c36:	6078      	str	r0, [r7, #4]
    BlockLink_t * pxBlock;
    BlockLink_t * pxPreviousBlock;
    BlockLink_t * pxNewBlockLink;
    void * pvReturn = NULL;
    1c38:	2300      	movs	r3, #0
    1c3a:	617b      	str	r3, [r7, #20]
    size_t xAdditionalRequiredSize;
    size_t xAllocatedBlockSize = 0;
    1c3c:	2300      	movs	r3, #0
    1c3e:	613b      	str	r3, [r7, #16]

    if( xWantedSize > 0 )
    1c40:	687b      	ldr	r3, [r7, #4]
    1c42:	2b00      	cmp	r3, #0
    1c44:	d022      	beq.n	1c8c <pvPortMalloc+0x5c>
    {
        /* The wanted size must be increased so it can contain a BlockLink_t
         * structure in addition to the requested amount of bytes. */
        if( heapADD_WILL_OVERFLOW( xWantedSize, xHeapStructSize ) == 0 )
    1c46:	2308      	movs	r3, #8
    1c48:	43db      	mvns	r3, r3
    1c4a:	687a      	ldr	r2, [r7, #4]
    1c4c:	429a      	cmp	r2, r3
    1c4e:	d81b      	bhi.n	1c88 <pvPortMalloc+0x58>
        {
            xWantedSize += xHeapStructSize;
    1c50:	2208      	movs	r2, #8
    1c52:	687b      	ldr	r3, [r7, #4]
    1c54:	4413      	add	r3, r2
    1c56:	607b      	str	r3, [r7, #4]

            /* Ensure that blocks are always aligned to the required number
             * of bytes. */
            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
    1c58:	687b      	ldr	r3, [r7, #4]
    1c5a:	f003 0307 	and.w	r3, r3, #7
    1c5e:	2b00      	cmp	r3, #0
    1c60:	d014      	beq.n	1c8c <pvPortMalloc+0x5c>
            {
                /* Byte alignment required. */
                xAdditionalRequiredSize = portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK );
    1c62:	687b      	ldr	r3, [r7, #4]
    1c64:	f003 0307 	and.w	r3, r3, #7
    1c68:	f1c3 0308 	rsb	r3, r3, #8
    1c6c:	60fb      	str	r3, [r7, #12]

                if( heapADD_WILL_OVERFLOW( xWantedSize, xAdditionalRequiredSize ) == 0 )
    1c6e:	68fb      	ldr	r3, [r7, #12]
    1c70:	43db      	mvns	r3, r3
    1c72:	687a      	ldr	r2, [r7, #4]
    1c74:	429a      	cmp	r2, r3
    1c76:	d804      	bhi.n	1c82 <pvPortMalloc+0x52>
                {
                    xWantedSize += xAdditionalRequiredSize;
    1c78:	687a      	ldr	r2, [r7, #4]
    1c7a:	68fb      	ldr	r3, [r7, #12]
    1c7c:	4413      	add	r3, r2
    1c7e:	607b      	str	r3, [r7, #4]
    1c80:	e004      	b.n	1c8c <pvPortMalloc+0x5c>
                }
                else
                {
                    xWantedSize = 0;
    1c82:	2300      	movs	r3, #0
    1c84:	607b      	str	r3, [r7, #4]
    1c86:	e001      	b.n	1c8c <pvPortMalloc+0x5c>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else
        {
            xWantedSize = 0;
    1c88:	2300      	movs	r3, #0
    1c8a:	607b      	str	r3, [r7, #4]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    vTaskSuspendAll();
    1c8c:	f7fe fc9e 	bl	5cc <vTaskSuspendAll>
    {
        /* If this is the first call to malloc then the heap will require
         * initialisation to setup the list of free blocks. */
        if( pxEnd == NULL )
    1c90:	4b3b      	ldr	r3, [pc, #236]	@ (1d80 <pvPortMalloc+0x150>)
    1c92:	681b      	ldr	r3, [r3, #0]
    1c94:	2b00      	cmp	r3, #0
    1c96:	d101      	bne.n	1c9c <pvPortMalloc+0x6c>
        {
            prvHeapInit();
    1c98:	f000 f90e 	bl	1eb8 <prvHeapInit>

        /* Check the block size we are trying to allocate is not so large that the
         * top bit is set.  The top bit of the block size member of the BlockLink_t
         * structure is used to determine who owns the block - the application or
         * the kernel, so it must be free. */
        if( heapBLOCK_SIZE_IS_VALID( xWantedSize ) != 0 )
    1c9c:	687b      	ldr	r3, [r7, #4]
    1c9e:	2b00      	cmp	r3, #0
    1ca0:	db67      	blt.n	1d72 <pvPortMalloc+0x142>
        {
            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    1ca2:	687b      	ldr	r3, [r7, #4]
    1ca4:	2b00      	cmp	r3, #0
    1ca6:	d064      	beq.n	1d72 <pvPortMalloc+0x142>
    1ca8:	4b36      	ldr	r3, [pc, #216]	@ (1d84 <pvPortMalloc+0x154>)
    1caa:	681b      	ldr	r3, [r3, #0]
    1cac:	687a      	ldr	r2, [r7, #4]
    1cae:	429a      	cmp	r2, r3
    1cb0:	d85f      	bhi.n	1d72 <pvPortMalloc+0x142>
            {
                /* Traverse the list from the start (lowest address) block until
                 * one of adequate size is found. */
                pxPreviousBlock = &xStart;
    1cb2:	4b35      	ldr	r3, [pc, #212]	@ (1d88 <pvPortMalloc+0x158>)
    1cb4:	61bb      	str	r3, [r7, #24]
                pxBlock = heapPROTECT_BLOCK_POINTER( xStart.pxNextFreeBlock );
    1cb6:	4b34      	ldr	r3, [pc, #208]	@ (1d88 <pvPortMalloc+0x158>)
    1cb8:	681b      	ldr	r3, [r3, #0]
    1cba:	61fb      	str	r3, [r7, #28]
                heapVALIDATE_BLOCK_POINTER( pxBlock );

                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != heapPROTECT_BLOCK_POINTER( NULL ) ) )
    1cbc:	e004      	b.n	1cc8 <pvPortMalloc+0x98>
                {
                    pxPreviousBlock = pxBlock;
    1cbe:	69fb      	ldr	r3, [r7, #28]
    1cc0:	61bb      	str	r3, [r7, #24]
                    pxBlock = heapPROTECT_BLOCK_POINTER( pxBlock->pxNextFreeBlock );
    1cc2:	69fb      	ldr	r3, [r7, #28]
    1cc4:	681b      	ldr	r3, [r3, #0]
    1cc6:	61fb      	str	r3, [r7, #28]
                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != heapPROTECT_BLOCK_POINTER( NULL ) ) )
    1cc8:	69fb      	ldr	r3, [r7, #28]
    1cca:	685b      	ldr	r3, [r3, #4]
    1ccc:	687a      	ldr	r2, [r7, #4]
    1cce:	429a      	cmp	r2, r3
    1cd0:	d903      	bls.n	1cda <pvPortMalloc+0xaa>
    1cd2:	69fb      	ldr	r3, [r7, #28]
    1cd4:	681b      	ldr	r3, [r3, #0]
    1cd6:	2b00      	cmp	r3, #0
    1cd8:	d1f1      	bne.n	1cbe <pvPortMalloc+0x8e>
                    heapVALIDATE_BLOCK_POINTER( pxBlock );
                }

                /* If the end marker was reached then a block of adequate size
                 * was not found. */
                if( pxBlock != pxEnd )
    1cda:	4b29      	ldr	r3, [pc, #164]	@ (1d80 <pvPortMalloc+0x150>)
    1cdc:	681b      	ldr	r3, [r3, #0]
    1cde:	69fa      	ldr	r2, [r7, #28]
    1ce0:	429a      	cmp	r2, r3
    1ce2:	d046      	beq.n	1d72 <pvPortMalloc+0x142>
                {
                    /* Return the memory space pointed to - jumping over the
                     * BlockLink_t structure at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) heapPROTECT_BLOCK_POINTER( pxPreviousBlock->pxNextFreeBlock ) ) + xHeapStructSize );
    1ce4:	69bb      	ldr	r3, [r7, #24]
    1ce6:	681b      	ldr	r3, [r3, #0]
    1ce8:	2208      	movs	r2, #8
    1cea:	4413      	add	r3, r2
    1cec:	617b      	str	r3, [r7, #20]
                    heapVALIDATE_BLOCK_POINTER( pvReturn );

                    /* This block is being returned for use so must be taken out
                     * of the list of free blocks. */
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1cee:	69fb      	ldr	r3, [r7, #28]
    1cf0:	681a      	ldr	r2, [r3, #0]
    1cf2:	69bb      	ldr	r3, [r7, #24]
    1cf4:	601a      	str	r2, [r3, #0]

                    /* If the block is larger than required it can be split into
                     * two. */
                    configASSERT( heapSUBTRACT_WILL_UNDERFLOW( pxBlock->xBlockSize, xWantedSize ) == 0 );

                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1cf6:	69fb      	ldr	r3, [r7, #28]
    1cf8:	685a      	ldr	r2, [r3, #4]
    1cfa:	687b      	ldr	r3, [r7, #4]
    1cfc:	1ad2      	subs	r2, r2, r3
    1cfe:	2308      	movs	r3, #8
    1d00:	005b      	lsls	r3, r3, #1
    1d02:	429a      	cmp	r2, r3
    1d04:	d913      	bls.n	1d2e <pvPortMalloc+0xfe>
                    {
                        /* This block is to be split into two.  Create a new
                         * block following the number of bytes requested. The void
                         * cast is used to prevent byte alignment warnings from the
                         * compiler. */
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    1d06:	69fa      	ldr	r2, [r7, #28]
    1d08:	687b      	ldr	r3, [r7, #4]
    1d0a:	4413      	add	r3, r2
    1d0c:	60bb      	str	r3, [r7, #8]
                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

                        /* Calculate the sizes of two blocks split from the
                         * single block. */
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1d0e:	69fb      	ldr	r3, [r7, #28]
    1d10:	685a      	ldr	r2, [r3, #4]
    1d12:	687b      	ldr	r3, [r7, #4]
    1d14:	1ad2      	subs	r2, r2, r3
    1d16:	68bb      	ldr	r3, [r7, #8]
    1d18:	605a      	str	r2, [r3, #4]
                        pxBlock->xBlockSize = xWantedSize;
    1d1a:	69fb      	ldr	r3, [r7, #28]
    1d1c:	687a      	ldr	r2, [r7, #4]
    1d1e:	605a      	str	r2, [r3, #4]

                        /* Insert the new block into the list of free blocks. */
                        pxNewBlockLink->pxNextFreeBlock = pxPreviousBlock->pxNextFreeBlock;
    1d20:	69bb      	ldr	r3, [r7, #24]
    1d22:	681a      	ldr	r2, [r3, #0]
    1d24:	68bb      	ldr	r3, [r7, #8]
    1d26:	601a      	str	r2, [r3, #0]
                        pxPreviousBlock->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxNewBlockLink );
    1d28:	69bb      	ldr	r3, [r7, #24]
    1d2a:	68ba      	ldr	r2, [r7, #8]
    1d2c:	601a      	str	r2, [r3, #0]
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    xFreeBytesRemaining -= pxBlock->xBlockSize;
    1d2e:	4b15      	ldr	r3, [pc, #84]	@ (1d84 <pvPortMalloc+0x154>)
    1d30:	681a      	ldr	r2, [r3, #0]
    1d32:	69fb      	ldr	r3, [r7, #28]
    1d34:	685b      	ldr	r3, [r3, #4]
    1d36:	1ad3      	subs	r3, r2, r3
    1d38:	4a12      	ldr	r2, [pc, #72]	@ (1d84 <pvPortMalloc+0x154>)
    1d3a:	6013      	str	r3, [r2, #0]

                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    1d3c:	4b11      	ldr	r3, [pc, #68]	@ (1d84 <pvPortMalloc+0x154>)
    1d3e:	681a      	ldr	r2, [r3, #0]
    1d40:	4b12      	ldr	r3, [pc, #72]	@ (1d8c <pvPortMalloc+0x15c>)
    1d42:	681b      	ldr	r3, [r3, #0]
    1d44:	429a      	cmp	r2, r3
    1d46:	d203      	bcs.n	1d50 <pvPortMalloc+0x120>
                    {
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    1d48:	4b0e      	ldr	r3, [pc, #56]	@ (1d84 <pvPortMalloc+0x154>)
    1d4a:	681b      	ldr	r3, [r3, #0]
    1d4c:	4a0f      	ldr	r2, [pc, #60]	@ (1d8c <pvPortMalloc+0x15c>)
    1d4e:	6013      	str	r3, [r2, #0]
                    else
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    xAllocatedBlockSize = pxBlock->xBlockSize;
    1d50:	69fb      	ldr	r3, [r7, #28]
    1d52:	685b      	ldr	r3, [r3, #4]
    1d54:	613b      	str	r3, [r7, #16]

                    /* The block is being returned - it is allocated and owned
                     * by the application and has no "next" block. */
                    heapALLOCATE_BLOCK( pxBlock );
    1d56:	69fb      	ldr	r3, [r7, #28]
    1d58:	685b      	ldr	r3, [r3, #4]
    1d5a:	f043 4200 	orr.w	r2, r3, #2147483648	@ 0x80000000
    1d5e:	69fb      	ldr	r3, [r7, #28]
    1d60:	605a      	str	r2, [r3, #4]
                    pxBlock->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( NULL );
    1d62:	69fb      	ldr	r3, [r7, #28]
    1d64:	2200      	movs	r2, #0
    1d66:	601a      	str	r2, [r3, #0]
                    xNumberOfSuccessfulAllocations++;
    1d68:	4b09      	ldr	r3, [pc, #36]	@ (1d90 <pvPortMalloc+0x160>)
    1d6a:	681b      	ldr	r3, [r3, #0]
    1d6c:	3301      	adds	r3, #1
    1d6e:	4a08      	ldr	r2, [pc, #32]	@ (1d90 <pvPortMalloc+0x160>)
    1d70:	6013      	str	r3, [r2, #0]
        traceMALLOC( pvReturn, xAllocatedBlockSize );

        /* Prevent compiler warnings when trace macros are not used. */
        ( void ) xAllocatedBlockSize;
    }
    ( void ) xTaskResumeAll();
    1d72:	f7fe fc39 	bl	5e8 <xTaskResumeAll>
        }
    }
    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */

    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
    return pvReturn;
    1d76:	697b      	ldr	r3, [r7, #20]
}
    1d78:	4618      	mov	r0, r3
    1d7a:	3720      	adds	r7, #32
    1d7c:	46bd      	mov	sp, r7
    1d7e:	bd80      	pop	{r7, pc}
    1d80:	00004c6c 	andeq	r4, r0, ip, ror #24
    1d84:	00004c70 	andeq	r4, r0, r0, ror ip
    1d88:	00004c64 	andeq	r4, r0, r4, ror #24
    1d8c:	00004c74 	andeq	r4, r0, r4, ror ip
    1d90:	00004c78 	andeq	r4, r0, r8, ror ip

00001d94 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
    1d94:	b580      	push	{r7, lr}
    1d96:	b084      	sub	sp, #16
    1d98:	af00      	add	r7, sp, #0
    1d9a:	6078      	str	r0, [r7, #4]
    uint8_t * puc = ( uint8_t * ) pv;
    1d9c:	687b      	ldr	r3, [r7, #4]
    1d9e:	60fb      	str	r3, [r7, #12]
    BlockLink_t * pxLink;

    if( pv != NULL )
    1da0:	687b      	ldr	r3, [r7, #4]
    1da2:	2b00      	cmp	r3, #0
    1da4:	d027      	beq.n	1df6 <vPortFree+0x62>
    {
        /* The memory being freed will have an BlockLink_t structure immediately
         * before it. */
        puc -= xHeapStructSize;
    1da6:	2308      	movs	r3, #8
    1da8:	425b      	negs	r3, r3
    1daa:	68fa      	ldr	r2, [r7, #12]
    1dac:	4413      	add	r3, r2
    1dae:	60fb      	str	r3, [r7, #12]

        /* This casting is to keep the compiler from issuing warnings. */
        pxLink = ( void * ) puc;
    1db0:	68fb      	ldr	r3, [r7, #12]
    1db2:	60bb      	str	r3, [r7, #8]

        heapVALIDATE_BLOCK_POINTER( pxLink );
        configASSERT( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 );
        configASSERT( pxLink->pxNextFreeBlock == heapPROTECT_BLOCK_POINTER( NULL ) );

        if( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 )
    1db4:	68bb      	ldr	r3, [r7, #8]
    1db6:	685b      	ldr	r3, [r3, #4]
    1db8:	2b00      	cmp	r3, #0
    1dba:	da1c      	bge.n	1df6 <vPortFree+0x62>
        {
            if( pxLink->pxNextFreeBlock == heapPROTECT_BLOCK_POINTER( NULL ) )
    1dbc:	68bb      	ldr	r3, [r7, #8]
    1dbe:	681b      	ldr	r3, [r3, #0]
    1dc0:	2b00      	cmp	r3, #0
    1dc2:	d118      	bne.n	1df6 <vPortFree+0x62>
            {
                /* The block is being returned to the heap - it is no longer
                 * allocated. */
                heapFREE_BLOCK( pxLink );
    1dc4:	68bb      	ldr	r3, [r7, #8]
    1dc6:	685b      	ldr	r3, [r3, #4]
    1dc8:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
    1dcc:	68bb      	ldr	r3, [r7, #8]
    1dce:	605a      	str	r2, [r3, #4]
                        ( void ) memset( puc + xHeapStructSize, 0, pxLink->xBlockSize - xHeapStructSize );
                    }
                }
                #endif

                vTaskSuspendAll();
    1dd0:	f7fe fbfc 	bl	5cc <vTaskSuspendAll>
                {
                    /* Add this block to the list of free blocks. */
                    xFreeBytesRemaining += pxLink->xBlockSize;
    1dd4:	68bb      	ldr	r3, [r7, #8]
    1dd6:	685a      	ldr	r2, [r3, #4]
    1dd8:	4b09      	ldr	r3, [pc, #36]	@ (1e00 <vPortFree+0x6c>)
    1dda:	681b      	ldr	r3, [r3, #0]
    1ddc:	4413      	add	r3, r2
    1dde:	4a08      	ldr	r2, [pc, #32]	@ (1e00 <vPortFree+0x6c>)
    1de0:	6013      	str	r3, [r2, #0]
                    traceFREE( pv, pxLink->xBlockSize );
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    1de2:	68b8      	ldr	r0, [r7, #8]
    1de4:	f000 f8c2 	bl	1f6c <prvInsertBlockIntoFreeList>
                    xNumberOfSuccessfulFrees++;
    1de8:	4b06      	ldr	r3, [pc, #24]	@ (1e04 <vPortFree+0x70>)
    1dea:	681b      	ldr	r3, [r3, #0]
    1dec:	3301      	adds	r3, #1
    1dee:	4a05      	ldr	r2, [pc, #20]	@ (1e04 <vPortFree+0x70>)
    1df0:	6013      	str	r3, [r2, #0]
                }
                ( void ) xTaskResumeAll();
    1df2:	f7fe fbf9 	bl	5e8 <xTaskResumeAll>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
}
    1df6:	bf00      	nop
    1df8:	3710      	adds	r7, #16
    1dfa:	46bd      	mov	sp, r7
    1dfc:	bd80      	pop	{r7, pc}
    1dfe:	bf00      	nop
    1e00:	00004c70 	andeq	r4, r0, r0, ror ip
    1e04:	00004c7c 	andeq	r4, r0, ip, ror ip

00001e08 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1e08:	b480      	push	{r7}
    1e0a:	af00      	add	r7, sp, #0
    return xFreeBytesRemaining;
    1e0c:	4b02      	ldr	r3, [pc, #8]	@ (1e18 <xPortGetFreeHeapSize+0x10>)
    1e0e:	681b      	ldr	r3, [r3, #0]
}
    1e10:	4618      	mov	r0, r3
    1e12:	46bd      	mov	sp, r7
    1e14:	bc80      	pop	{r7}
    1e16:	4770      	bx	lr
    1e18:	00004c70 	andeq	r4, r0, r0, ror ip

00001e1c <xPortGetMinimumEverFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetMinimumEverFreeHeapSize( void )
{
    1e1c:	b480      	push	{r7}
    1e1e:	af00      	add	r7, sp, #0
    return xMinimumEverFreeBytesRemaining;
    1e20:	4b02      	ldr	r3, [pc, #8]	@ (1e2c <xPortGetMinimumEverFreeHeapSize+0x10>)
    1e22:	681b      	ldr	r3, [r3, #0]
}
    1e24:	4618      	mov	r0, r3
    1e26:	46bd      	mov	sp, r7
    1e28:	bc80      	pop	{r7}
    1e2a:	4770      	bx	lr
    1e2c:	00004c74 	andeq	r4, r0, r4, ror ip

00001e30 <xPortResetHeapMinimumEverFreeHeapSize>:
/*-----------------------------------------------------------*/

void xPortResetHeapMinimumEverFreeHeapSize( void )
{
    1e30:	b480      	push	{r7}
    1e32:	af00      	add	r7, sp, #0
    xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    1e34:	4b03      	ldr	r3, [pc, #12]	@ (1e44 <xPortResetHeapMinimumEverFreeHeapSize+0x14>)
    1e36:	681b      	ldr	r3, [r3, #0]
    1e38:	4a03      	ldr	r2, [pc, #12]	@ (1e48 <xPortResetHeapMinimumEverFreeHeapSize+0x18>)
    1e3a:	6013      	str	r3, [r2, #0]
}
    1e3c:	bf00      	nop
    1e3e:	46bd      	mov	sp, r7
    1e40:	bc80      	pop	{r7}
    1e42:	4770      	bx	lr
    1e44:	00004c70 	andeq	r4, r0, r0, ror ip
    1e48:	00004c74 	andeq	r4, r0, r4, ror ip

00001e4c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1e4c:	b480      	push	{r7}
    1e4e:	af00      	add	r7, sp, #0
    /* This just exists to keep the linker quiet. */
}
    1e50:	bf00      	nop
    1e52:	46bd      	mov	sp, r7
    1e54:	bc80      	pop	{r7}
    1e56:	4770      	bx	lr

00001e58 <pvPortCalloc>:
/*-----------------------------------------------------------*/

void * pvPortCalloc( size_t xNum,
                     size_t xSize )
{
    1e58:	b580      	push	{r7, lr}
    1e5a:	b084      	sub	sp, #16
    1e5c:	af00      	add	r7, sp, #0
    1e5e:	6078      	str	r0, [r7, #4]
    1e60:	6039      	str	r1, [r7, #0]
    void * pv = NULL;
    1e62:	2300      	movs	r3, #0
    1e64:	60fb      	str	r3, [r7, #12]

    if( heapMULTIPLY_WILL_OVERFLOW( xNum, xSize ) == 0 )
    1e66:	687b      	ldr	r3, [r7, #4]
    1e68:	2b00      	cmp	r3, #0
    1e6a:	d009      	beq.n	1e80 <pvPortCalloc+0x28>
    1e6c:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
    1e70:	687b      	ldr	r3, [r7, #4]
    1e72:	fbb2 f3f3 	udiv	r3, r2, r3
    1e76:	683a      	ldr	r2, [r7, #0]
    1e78:	429a      	cmp	r2, r3
    1e7a:	d901      	bls.n	1e80 <pvPortCalloc+0x28>
    1e7c:	2301      	movs	r3, #1
    1e7e:	e000      	b.n	1e82 <pvPortCalloc+0x2a>
    1e80:	2300      	movs	r3, #0
    1e82:	2b00      	cmp	r3, #0
    1e84:	d113      	bne.n	1eae <pvPortCalloc+0x56>
    {
        pv = pvPortMalloc( xNum * xSize );
    1e86:	687b      	ldr	r3, [r7, #4]
    1e88:	683a      	ldr	r2, [r7, #0]
    1e8a:	fb02 f303 	mul.w	r3, r2, r3
    1e8e:	4618      	mov	r0, r3
    1e90:	f7ff fece 	bl	1c30 <pvPortMalloc>
    1e94:	60f8      	str	r0, [r7, #12]

        if( pv != NULL )
    1e96:	68fb      	ldr	r3, [r7, #12]
    1e98:	2b00      	cmp	r3, #0
    1e9a:	d008      	beq.n	1eae <pvPortCalloc+0x56>
        {
            ( void ) memset( pv, 0, xNum * xSize );
    1e9c:	687b      	ldr	r3, [r7, #4]
    1e9e:	683a      	ldr	r2, [r7, #0]
    1ea0:	fb02 f303 	mul.w	r3, r2, r3
    1ea4:	461a      	mov	r2, r3
    1ea6:	2100      	movs	r1, #0
    1ea8:	68f8      	ldr	r0, [r7, #12]
    1eaa:	f7fe f97d 	bl	1a8 <memset>
        }
    }

    return pv;
    1eae:	68fb      	ldr	r3, [r7, #12]
}
    1eb0:	4618      	mov	r0, r3
    1eb2:	3710      	adds	r7, #16
    1eb4:	46bd      	mov	sp, r7
    1eb6:	bd80      	pop	{r7, pc}

00001eb8 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void ) /* PRIVILEGED_FUNCTION */
{
    1eb8:	b480      	push	{r7}
    1eba:	b085      	sub	sp, #20
    1ebc:	af00      	add	r7, sp, #0
    BlockLink_t * pxFirstFreeBlock;
    portPOINTER_SIZE_TYPE uxStartAddress, uxEndAddress;
    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
    1ebe:	f44f 5320 	mov.w	r3, #10240	@ 0x2800
    1ec2:	60bb      	str	r3, [r7, #8]

    /* Ensure the heap starts on a correctly aligned boundary. */
    uxStartAddress = ( portPOINTER_SIZE_TYPE ) ucHeap;
    1ec4:	4b24      	ldr	r3, [pc, #144]	@ (1f58 <prvHeapInit+0xa0>)
    1ec6:	60fb      	str	r3, [r7, #12]

    if( ( uxStartAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
    1ec8:	68fb      	ldr	r3, [r7, #12]
    1eca:	f003 0307 	and.w	r3, r3, #7
    1ece:	2b00      	cmp	r3, #0
    1ed0:	d00c      	beq.n	1eec <prvHeapInit+0x34>
    {
        uxStartAddress += ( portBYTE_ALIGNMENT - 1 );
    1ed2:	68fb      	ldr	r3, [r7, #12]
    1ed4:	3307      	adds	r3, #7
    1ed6:	60fb      	str	r3, [r7, #12]
        uxStartAddress &= ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK );
    1ed8:	68fb      	ldr	r3, [r7, #12]
    1eda:	f023 0307 	bic.w	r3, r3, #7
    1ede:	60fb      	str	r3, [r7, #12]
        xTotalHeapSize -= ( size_t ) ( uxStartAddress - ( portPOINTER_SIZE_TYPE ) ucHeap );
    1ee0:	68ba      	ldr	r2, [r7, #8]
    1ee2:	68fb      	ldr	r3, [r7, #12]
    1ee4:	1ad3      	subs	r3, r2, r3
    1ee6:	4a1c      	ldr	r2, [pc, #112]	@ (1f58 <prvHeapInit+0xa0>)
    1ee8:	4413      	add	r3, r2
    1eea:	60bb      	str	r3, [r7, #8]
    }
    #endif

    /* xStart is used to hold a pointer to the first item in the list of free
     * blocks.  The void cast is used to prevent compiler warnings. */
    xStart.pxNextFreeBlock = ( void * ) heapPROTECT_BLOCK_POINTER( uxStartAddress );
    1eec:	68fb      	ldr	r3, [r7, #12]
    1eee:	4a1b      	ldr	r2, [pc, #108]	@ (1f5c <prvHeapInit+0xa4>)
    1ef0:	6013      	str	r3, [r2, #0]
    xStart.xBlockSize = ( size_t ) 0;
    1ef2:	4b1a      	ldr	r3, [pc, #104]	@ (1f5c <prvHeapInit+0xa4>)
    1ef4:	2200      	movs	r2, #0
    1ef6:	605a      	str	r2, [r3, #4]

    /* pxEnd is used to mark the end of the list of free blocks and is inserted
     * at the end of the heap space. */
    uxEndAddress = uxStartAddress + ( portPOINTER_SIZE_TYPE ) xTotalHeapSize;
    1ef8:	68fa      	ldr	r2, [r7, #12]
    1efa:	68bb      	ldr	r3, [r7, #8]
    1efc:	4413      	add	r3, r2
    1efe:	607b      	str	r3, [r7, #4]
    uxEndAddress -= ( portPOINTER_SIZE_TYPE ) xHeapStructSize;
    1f00:	2208      	movs	r2, #8
    1f02:	687b      	ldr	r3, [r7, #4]
    1f04:	1a9b      	subs	r3, r3, r2
    1f06:	607b      	str	r3, [r7, #4]
    uxEndAddress &= ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK );
    1f08:	687b      	ldr	r3, [r7, #4]
    1f0a:	f023 0307 	bic.w	r3, r3, #7
    1f0e:	607b      	str	r3, [r7, #4]
    pxEnd = ( BlockLink_t * ) uxEndAddress;
    1f10:	687b      	ldr	r3, [r7, #4]
    1f12:	4a13      	ldr	r2, [pc, #76]	@ (1f60 <prvHeapInit+0xa8>)
    1f14:	6013      	str	r3, [r2, #0]
    pxEnd->xBlockSize = 0;
    1f16:	4b12      	ldr	r3, [pc, #72]	@ (1f60 <prvHeapInit+0xa8>)
    1f18:	681b      	ldr	r3, [r3, #0]
    1f1a:	2200      	movs	r2, #0
    1f1c:	605a      	str	r2, [r3, #4]
    pxEnd->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( NULL );
    1f1e:	4b10      	ldr	r3, [pc, #64]	@ (1f60 <prvHeapInit+0xa8>)
    1f20:	681b      	ldr	r3, [r3, #0]
    1f22:	2200      	movs	r2, #0
    1f24:	601a      	str	r2, [r3, #0]

    /* To start with there is a single free block that is sized to take up the
     * entire heap space, minus the space taken by pxEnd. */
    pxFirstFreeBlock = ( BlockLink_t * ) uxStartAddress;
    1f26:	68fb      	ldr	r3, [r7, #12]
    1f28:	603b      	str	r3, [r7, #0]
    pxFirstFreeBlock->xBlockSize = ( size_t ) ( uxEndAddress - ( portPOINTER_SIZE_TYPE ) pxFirstFreeBlock );
    1f2a:	683b      	ldr	r3, [r7, #0]
    1f2c:	687a      	ldr	r2, [r7, #4]
    1f2e:	1ad2      	subs	r2, r2, r3
    1f30:	683b      	ldr	r3, [r7, #0]
    1f32:	605a      	str	r2, [r3, #4]
    pxFirstFreeBlock->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxEnd );
    1f34:	4b0a      	ldr	r3, [pc, #40]	@ (1f60 <prvHeapInit+0xa8>)
    1f36:	681a      	ldr	r2, [r3, #0]
    1f38:	683b      	ldr	r3, [r7, #0]
    1f3a:	601a      	str	r2, [r3, #0]

    /* Only one block exists - and it covers the entire usable heap space. */
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    1f3c:	683b      	ldr	r3, [r7, #0]
    1f3e:	685b      	ldr	r3, [r3, #4]
    1f40:	4a08      	ldr	r2, [pc, #32]	@ (1f64 <prvHeapInit+0xac>)
    1f42:	6013      	str	r3, [r2, #0]
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    1f44:	683b      	ldr	r3, [r7, #0]
    1f46:	685b      	ldr	r3, [r3, #4]
    1f48:	4a07      	ldr	r2, [pc, #28]	@ (1f68 <prvHeapInit+0xb0>)
    1f4a:	6013      	str	r3, [r2, #0]
}
    1f4c:	bf00      	nop
    1f4e:	3714      	adds	r7, #20
    1f50:	46bd      	mov	sp, r7
    1f52:	bc80      	pop	{r7}
    1f54:	4770      	bx	lr
    1f56:	bf00      	nop
    1f58:	00002464 	andeq	r2, r0, r4, ror #8
    1f5c:	00004c64 	andeq	r4, r0, r4, ror #24
    1f60:	00004c6c 	andeq	r4, r0, ip, ror #24
    1f64:	00004c74 	andeq	r4, r0, r4, ror ip
    1f68:	00004c70 	andeq	r4, r0, r0, ror ip

00001f6c <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) /* PRIVILEGED_FUNCTION */
{
    1f6c:	b480      	push	{r7}
    1f6e:	b085      	sub	sp, #20
    1f70:	af00      	add	r7, sp, #0
    1f72:	6078      	str	r0, [r7, #4]
    BlockLink_t * pxIterator;
    uint8_t * puc;

    /* Iterate through the list until a block is found that has a higher address
     * than the block being inserted. */
    for( pxIterator = &xStart; heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) < pxBlockToInsert; pxIterator = heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
    1f74:	4b27      	ldr	r3, [pc, #156]	@ (2014 <prvInsertBlockIntoFreeList+0xa8>)
    1f76:	60fb      	str	r3, [r7, #12]
    1f78:	e002      	b.n	1f80 <prvInsertBlockIntoFreeList+0x14>
    1f7a:	68fb      	ldr	r3, [r7, #12]
    1f7c:	681b      	ldr	r3, [r3, #0]
    1f7e:	60fb      	str	r3, [r7, #12]
    1f80:	68fb      	ldr	r3, [r7, #12]
    1f82:	681b      	ldr	r3, [r3, #0]
    1f84:	687a      	ldr	r2, [r7, #4]
    1f86:	429a      	cmp	r2, r3
    1f88:	d8f7      	bhi.n	1f7a <prvInsertBlockIntoFreeList+0xe>
        heapVALIDATE_BLOCK_POINTER( pxIterator );
    }

    /* Do the block being inserted, and the block it is being inserted after
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxIterator;
    1f8a:	68fb      	ldr	r3, [r7, #12]
    1f8c:	60bb      	str	r3, [r7, #8]

    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    1f8e:	68fb      	ldr	r3, [r7, #12]
    1f90:	685b      	ldr	r3, [r3, #4]
    1f92:	68ba      	ldr	r2, [r7, #8]
    1f94:	4413      	add	r3, r2
    1f96:	687a      	ldr	r2, [r7, #4]
    1f98:	429a      	cmp	r2, r3
    1f9a:	d108      	bne.n	1fae <prvInsertBlockIntoFreeList+0x42>
    {
        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    1f9c:	68fb      	ldr	r3, [r7, #12]
    1f9e:	685a      	ldr	r2, [r3, #4]
    1fa0:	687b      	ldr	r3, [r7, #4]
    1fa2:	685b      	ldr	r3, [r3, #4]
    1fa4:	441a      	add	r2, r3
    1fa6:	68fb      	ldr	r3, [r7, #12]
    1fa8:	605a      	str	r2, [r3, #4]
        pxBlockToInsert = pxIterator;
    1faa:	68fb      	ldr	r3, [r7, #12]
    1fac:	607b      	str	r3, [r7, #4]
        mtCOVERAGE_TEST_MARKER();
    }

    /* Do the block being inserted, and the block it is being inserted before
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxBlockToInsert;
    1fae:	687b      	ldr	r3, [r7, #4]
    1fb0:	60bb      	str	r3, [r7, #8]

    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
    1fb2:	687b      	ldr	r3, [r7, #4]
    1fb4:	685b      	ldr	r3, [r3, #4]
    1fb6:	68ba      	ldr	r2, [r7, #8]
    1fb8:	441a      	add	r2, r3
    1fba:	68fb      	ldr	r3, [r7, #12]
    1fbc:	681b      	ldr	r3, [r3, #0]
    1fbe:	429a      	cmp	r2, r3
    1fc0:	d118      	bne.n	1ff4 <prvInsertBlockIntoFreeList+0x88>
    {
        if( heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) != pxEnd )
    1fc2:	68fb      	ldr	r3, [r7, #12]
    1fc4:	681a      	ldr	r2, [r3, #0]
    1fc6:	4b14      	ldr	r3, [pc, #80]	@ (2018 <prvInsertBlockIntoFreeList+0xac>)
    1fc8:	681b      	ldr	r3, [r3, #0]
    1fca:	429a      	cmp	r2, r3
    1fcc:	d00d      	beq.n	1fea <prvInsertBlockIntoFreeList+0x7e>
        {
            /* Form one big block from the two blocks. */
            pxBlockToInsert->xBlockSize += heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock )->xBlockSize;
    1fce:	687b      	ldr	r3, [r7, #4]
    1fd0:	685a      	ldr	r2, [r3, #4]
    1fd2:	68fb      	ldr	r3, [r7, #12]
    1fd4:	681b      	ldr	r3, [r3, #0]
    1fd6:	685b      	ldr	r3, [r3, #4]
    1fd8:	441a      	add	r2, r3
    1fda:	687b      	ldr	r3, [r7, #4]
    1fdc:	605a      	str	r2, [r3, #4]
            pxBlockToInsert->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock )->pxNextFreeBlock;
    1fde:	68fb      	ldr	r3, [r7, #12]
    1fe0:	681b      	ldr	r3, [r3, #0]
    1fe2:	681a      	ldr	r2, [r3, #0]
    1fe4:	687b      	ldr	r3, [r7, #4]
    1fe6:	601a      	str	r2, [r3, #0]
    1fe8:	e008      	b.n	1ffc <prvInsertBlockIntoFreeList+0x90>
        }
        else
        {
            pxBlockToInsert->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxEnd );
    1fea:	4b0b      	ldr	r3, [pc, #44]	@ (2018 <prvInsertBlockIntoFreeList+0xac>)
    1fec:	681a      	ldr	r2, [r3, #0]
    1fee:	687b      	ldr	r3, [r7, #4]
    1ff0:	601a      	str	r2, [r3, #0]
    1ff2:	e003      	b.n	1ffc <prvInsertBlockIntoFreeList+0x90>
        }
    }
    else
    {
        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    1ff4:	68fb      	ldr	r3, [r7, #12]
    1ff6:	681a      	ldr	r2, [r3, #0]
    1ff8:	687b      	ldr	r3, [r7, #4]
    1ffa:	601a      	str	r2, [r3, #0]

    /* If the block being inserted plugged a gap, so was merged with the block
     * before and the block after, then it's pxNextFreeBlock pointer will have
     * already been set, and should not be set here as that would make it point
     * to itself. */
    if( pxIterator != pxBlockToInsert )
    1ffc:	68fa      	ldr	r2, [r7, #12]
    1ffe:	687b      	ldr	r3, [r7, #4]
    2000:	429a      	cmp	r2, r3
    2002:	d002      	beq.n	200a <prvInsertBlockIntoFreeList+0x9e>
    {
        pxIterator->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxBlockToInsert );
    2004:	68fb      	ldr	r3, [r7, #12]
    2006:	687a      	ldr	r2, [r7, #4]
    2008:	601a      	str	r2, [r3, #0]
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    200a:	bf00      	nop
    200c:	3714      	adds	r7, #20
    200e:	46bd      	mov	sp, r7
    2010:	bc80      	pop	{r7}
    2012:	4770      	bx	lr
    2014:	00004c64 	andeq	r4, r0, r4, ror #24
    2018:	00004c6c 	andeq	r4, r0, ip, ror #24

0000201c <vPortGetHeapStats>:
/*-----------------------------------------------------------*/

void vPortGetHeapStats( HeapStats_t * pxHeapStats )
{
    201c:	b580      	push	{r7, lr}
    201e:	b086      	sub	sp, #24
    2020:	af00      	add	r7, sp, #0
    2022:	6078      	str	r0, [r7, #4]
    BlockLink_t * pxBlock;
    size_t xBlocks = 0, xMaxSize = 0, xMinSize = SIZE_MAX;
    2024:	2300      	movs	r3, #0
    2026:	613b      	str	r3, [r7, #16]
    2028:	2300      	movs	r3, #0
    202a:	60fb      	str	r3, [r7, #12]
    202c:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
    2030:	60bb      	str	r3, [r7, #8]

    vTaskSuspendAll();
    2032:	f7fe facb 	bl	5cc <vTaskSuspendAll>
    {
        pxBlock = heapPROTECT_BLOCK_POINTER( xStart.pxNextFreeBlock );
    2036:	4b22      	ldr	r3, [pc, #136]	@ (20c0 <vPortGetHeapStats+0xa4>)
    2038:	681b      	ldr	r3, [r3, #0]
    203a:	617b      	str	r3, [r7, #20]

        /* pxBlock will be NULL if the heap has not been initialised.  The heap
         * is initialised automatically when the first allocation is made. */
        if( pxBlock != NULL )
    203c:	697b      	ldr	r3, [r7, #20]
    203e:	2b00      	cmp	r3, #0
    2040:	d01b      	beq.n	207a <vPortGetHeapStats+0x5e>
        {
            while( pxBlock != pxEnd )
    2042:	e015      	b.n	2070 <vPortGetHeapStats+0x54>
            {
                /* Increment the number of blocks and record the largest block seen
                 * so far. */
                xBlocks++;
    2044:	693b      	ldr	r3, [r7, #16]
    2046:	3301      	adds	r3, #1
    2048:	613b      	str	r3, [r7, #16]

                if( pxBlock->xBlockSize > xMaxSize )
    204a:	697b      	ldr	r3, [r7, #20]
    204c:	685b      	ldr	r3, [r3, #4]
    204e:	68fa      	ldr	r2, [r7, #12]
    2050:	429a      	cmp	r2, r3
    2052:	d202      	bcs.n	205a <vPortGetHeapStats+0x3e>
                {
                    xMaxSize = pxBlock->xBlockSize;
    2054:	697b      	ldr	r3, [r7, #20]
    2056:	685b      	ldr	r3, [r3, #4]
    2058:	60fb      	str	r3, [r7, #12]
                }

                if( pxBlock->xBlockSize < xMinSize )
    205a:	697b      	ldr	r3, [r7, #20]
    205c:	685b      	ldr	r3, [r3, #4]
    205e:	68ba      	ldr	r2, [r7, #8]
    2060:	429a      	cmp	r2, r3
    2062:	d902      	bls.n	206a <vPortGetHeapStats+0x4e>
                {
                    xMinSize = pxBlock->xBlockSize;
    2064:	697b      	ldr	r3, [r7, #20]
    2066:	685b      	ldr	r3, [r3, #4]
    2068:	60bb      	str	r3, [r7, #8]
                }

                /* Move to the next block in the chain until the last block is
                 * reached. */
                pxBlock = heapPROTECT_BLOCK_POINTER( pxBlock->pxNextFreeBlock );
    206a:	697b      	ldr	r3, [r7, #20]
    206c:	681b      	ldr	r3, [r3, #0]
    206e:	617b      	str	r3, [r7, #20]
            while( pxBlock != pxEnd )
    2070:	4b14      	ldr	r3, [pc, #80]	@ (20c4 <vPortGetHeapStats+0xa8>)
    2072:	681b      	ldr	r3, [r3, #0]
    2074:	697a      	ldr	r2, [r7, #20]
    2076:	429a      	cmp	r2, r3
    2078:	d1e4      	bne.n	2044 <vPortGetHeapStats+0x28>
            }
        }
    }
    ( void ) xTaskResumeAll();
    207a:	f7fe fab5 	bl	5e8 <xTaskResumeAll>

    pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;
    207e:	687b      	ldr	r3, [r7, #4]
    2080:	68fa      	ldr	r2, [r7, #12]
    2082:	605a      	str	r2, [r3, #4]
    pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;
    2084:	687b      	ldr	r3, [r7, #4]
    2086:	68ba      	ldr	r2, [r7, #8]
    2088:	609a      	str	r2, [r3, #8]
    pxHeapStats->xNumberOfFreeBlocks = xBlocks;
    208a:	687b      	ldr	r3, [r7, #4]
    208c:	693a      	ldr	r2, [r7, #16]
    208e:	60da      	str	r2, [r3, #12]

    taskENTER_CRITICAL();
    2090:	f000 f8de 	bl	2250 <vPortEnterCritical>
    {
        pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;
    2094:	4b0c      	ldr	r3, [pc, #48]	@ (20c8 <vPortGetHeapStats+0xac>)
    2096:	681a      	ldr	r2, [r3, #0]
    2098:	687b      	ldr	r3, [r7, #4]
    209a:	601a      	str	r2, [r3, #0]
        pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;
    209c:	4b0b      	ldr	r3, [pc, #44]	@ (20cc <vPortGetHeapStats+0xb0>)
    209e:	681a      	ldr	r2, [r3, #0]
    20a0:	687b      	ldr	r3, [r7, #4]
    20a2:	615a      	str	r2, [r3, #20]
        pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;
    20a4:	4b0a      	ldr	r3, [pc, #40]	@ (20d0 <vPortGetHeapStats+0xb4>)
    20a6:	681a      	ldr	r2, [r3, #0]
    20a8:	687b      	ldr	r3, [r7, #4]
    20aa:	619a      	str	r2, [r3, #24]
        pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;
    20ac:	4b09      	ldr	r3, [pc, #36]	@ (20d4 <vPortGetHeapStats+0xb8>)
    20ae:	681a      	ldr	r2, [r3, #0]
    20b0:	687b      	ldr	r3, [r7, #4]
    20b2:	611a      	str	r2, [r3, #16]
    }
    taskEXIT_CRITICAL();
    20b4:	f000 f8e6 	bl	2284 <vPortExitCritical>
}
    20b8:	bf00      	nop
    20ba:	3718      	adds	r7, #24
    20bc:	46bd      	mov	sp, r7
    20be:	bd80      	pop	{r7, pc}
    20c0:	00004c64 	andeq	r4, r0, r4, ror #24
    20c4:	00004c6c 	andeq	r4, r0, ip, ror #24
    20c8:	00004c70 	andeq	r4, r0, r0, ror ip
    20cc:	00004c78 	andeq	r4, r0, r8, ror ip
    20d0:	00004c7c 	andeq	r4, r0, ip, ror ip
    20d4:	00004c74 	andeq	r4, r0, r4, ror ip

000020d8 <vPortHeapResetState>:
 * Reset the state in this file. This state is normally initialized at start up.
 * This function must be called by the application before restarting the
 * scheduler.
 */
void vPortHeapResetState( void )
{
    20d8:	b480      	push	{r7}
    20da:	af00      	add	r7, sp, #0
    pxEnd = NULL;
    20dc:	4b09      	ldr	r3, [pc, #36]	@ (2104 <vPortHeapResetState+0x2c>)
    20de:	2200      	movs	r2, #0
    20e0:	601a      	str	r2, [r3, #0]

    xFreeBytesRemaining = ( size_t ) 0U;
    20e2:	4b09      	ldr	r3, [pc, #36]	@ (2108 <vPortHeapResetState+0x30>)
    20e4:	2200      	movs	r2, #0
    20e6:	601a      	str	r2, [r3, #0]
    xMinimumEverFreeBytesRemaining = ( size_t ) 0U;
    20e8:	4b08      	ldr	r3, [pc, #32]	@ (210c <vPortHeapResetState+0x34>)
    20ea:	2200      	movs	r2, #0
    20ec:	601a      	str	r2, [r3, #0]
    xNumberOfSuccessfulAllocations = ( size_t ) 0U;
    20ee:	4b08      	ldr	r3, [pc, #32]	@ (2110 <vPortHeapResetState+0x38>)
    20f0:	2200      	movs	r2, #0
    20f2:	601a      	str	r2, [r3, #0]
    xNumberOfSuccessfulFrees = ( size_t ) 0U;
    20f4:	4b07      	ldr	r3, [pc, #28]	@ (2114 <vPortHeapResetState+0x3c>)
    20f6:	2200      	movs	r2, #0
    20f8:	601a      	str	r2, [r3, #0]
}
    20fa:	bf00      	nop
    20fc:	46bd      	mov	sp, r7
    20fe:	bc80      	pop	{r7}
    2100:	4770      	bx	lr
    2102:	bf00      	nop
    2104:	00004c6c 	andeq	r4, r0, ip, ror #24
    2108:	00004c70 	andeq	r4, r0, r0, ror ip
    210c:	00004c74 	andeq	r4, r0, r4, ror ip
    2110:	00004c78 	andeq	r4, r0, r8, ror ip
    2114:	00004c7c 	andeq	r4, r0, ip, ror ip

00002118 <pxPortInitialiseStack>:
 * See header file for description.
 */
StackType_t * pxPortInitialiseStack( StackType_t * pxTopOfStack,
                                     TaskFunction_t pxCode,
                                     void * pvParameters )
{
    2118:	b480      	push	{r7}
    211a:	b085      	sub	sp, #20
    211c:	af00      	add	r7, sp, #0
    211e:	60f8      	str	r0, [r7, #12]
    2120:	60b9      	str	r1, [r7, #8]
    2122:	607a      	str	r2, [r7, #4]
    /* Simulate the stack frame as it would be created by a context switch
     * interrupt. */
    pxTopOfStack--;                                                      /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
    2124:	68fb      	ldr	r3, [r7, #12]
    2126:	3b04      	subs	r3, #4
    2128:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = portINITIAL_XPSR;                                    /* xPSR */
    212a:	68fb      	ldr	r3, [r7, #12]
    212c:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
    2130:	601a      	str	r2, [r3, #0]
    pxTopOfStack--;
    2132:	68fb      	ldr	r3, [r7, #12]
    2134:	3b04      	subs	r3, #4
    2136:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK; /* PC */
    2138:	68bb      	ldr	r3, [r7, #8]
    213a:	f023 0201 	bic.w	r2, r3, #1
    213e:	68fb      	ldr	r3, [r7, #12]
    2140:	601a      	str	r2, [r3, #0]
    pxTopOfStack--;
    2142:	68fb      	ldr	r3, [r7, #12]
    2144:	3b04      	subs	r3, #4
    2146:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;             /* LR */
    2148:	4a08      	ldr	r2, [pc, #32]	@ (216c <pxPortInitialiseStack+0x54>)
    214a:	68fb      	ldr	r3, [r7, #12]
    214c:	601a      	str	r2, [r3, #0]
    pxTopOfStack -= 5;                                                   /* R12, R3, R2 and R1. */
    214e:	68fb      	ldr	r3, [r7, #12]
    2150:	3b14      	subs	r3, #20
    2152:	60fb      	str	r3, [r7, #12]
    *pxTopOfStack = ( StackType_t ) pvParameters;                        /* R0 */
    2154:	687a      	ldr	r2, [r7, #4]
    2156:	68fb      	ldr	r3, [r7, #12]
    2158:	601a      	str	r2, [r3, #0]
    pxTopOfStack -= 8;                                                   /* R11, R10, R9, R8, R7, R6, R5 and R4. */
    215a:	68fb      	ldr	r3, [r7, #12]
    215c:	3b20      	subs	r3, #32
    215e:	60fb      	str	r3, [r7, #12]

    return pxTopOfStack;
    2160:	68fb      	ldr	r3, [r7, #12]
}
    2162:	4618      	mov	r0, r3
    2164:	3714      	adds	r7, #20
    2166:	46bd      	mov	sp, r7
    2168:	bc80      	pop	{r7}
    216a:	4770      	bx	lr
    216c:	00002171 	andeq	r2, r0, r1, ror r1

00002170 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
    2170:	b480      	push	{r7}
    2172:	b083      	sub	sp, #12
    2174:	af00      	add	r7, sp, #0
    volatile uint32_t ulDummy = 0UL;
    2176:	2300      	movs	r3, #0
    2178:	603b      	str	r3, [r7, #0]
    __asm volatile
    217a:	f04f 0301 	mov.w	r3, #1
    217e:	f383 8811 	msr	BASEPRI, r3
    2182:	f3bf 8f6f 	isb	sy
    2186:	f3bf 8f4f 	dsb	sy
    218a:	607b      	str	r3, [r7, #4]
}
    218c:	bf00      	nop
     * Artificially force an assert() to be triggered if configASSERT() is
     * defined, then stop here so application writers can catch the error. */
    configASSERT( uxCriticalNesting == ~0UL );
    portDISABLE_INTERRUPTS();

    while( ulDummy == 0 )
    218e:	bf00      	nop
    2190:	683b      	ldr	r3, [r7, #0]
    2192:	2b00      	cmp	r3, #0
    2194:	d0fc      	beq.n	2190 <prvTaskExitError+0x20>
         * about code appearing after this function is called - making ulDummy
         * volatile makes the compiler think the function could return and
         * therefore not output an 'unreachable code' warning for code that appears
         * after it. */
    }
}
    2196:	bf00      	nop
    2198:	bf00      	nop
    219a:	370c      	adds	r7, #12
    219c:	46bd      	mov	sp, r7
    219e:	bc80      	pop	{r7}
    21a0:	4770      	bx	lr

000021a2 <vPortSVCHandler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
    __asm volatile (
    21a2:	4b08      	ldr	r3, [pc, #32]	@ (21c4 <vPortSVCHandler+0x22>)
    21a4:	6819      	ldr	r1, [r3, #0]
    21a6:	6808      	ldr	r0, [r1, #0]
    21a8:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
    21ac:	f380 8809 	msr	PSP, r0
    21b0:	f3bf 8f6f 	isb	sy
    21b4:	f04f 0000 	mov.w	r0, #0
    21b8:	f380 8811 	msr	BASEPRI, r0
    21bc:	f04e 0e0d 	orr.w	lr, lr, #13
    21c0:	4770      	bx	lr
    21c2:	238c0000 	orrcs	r0, ip, #0
    21c6:	bf000000 	svclt	0x00000000

000021ca <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
    __asm volatile (
    21ca:	4806      	ldr	r0, [pc, #24]	@ (21e4 <prvPortStartFirstTask+0x1a>)
    21cc:	6800      	ldr	r0, [r0, #0]
    21ce:	6800      	ldr	r0, [r0, #0]
    21d0:	f380 8808 	msr	MSP, r0
    21d4:	b662      	cpsie	i
    21d6:	b661      	cpsie	f
    21d8:	f3bf 8f4f 	dsb	sy
    21dc:	f3bf 8f6f 	isb	sy
    21e0:	df00      	svc	0
    21e2:	bf00      	nop
    21e4:	e000ed08 	and	lr, r0, r8, lsl #26
        " isb                   \n"
        " svc 0                 \n" /* System call to start first task. */
        " nop                   \n"
        " .ltorg                \n"
        );
}
    21e8:	bf00      	nop

000021ea <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
    21ea:	b580      	push	{r7, lr}
    21ec:	b082      	sub	sp, #8
    21ee:	af00      	add	r7, sp, #0
     * configCHECK_HANDLER_INSTALLATION to 0 in their FreeRTOSConfig.h. Direct
     * routing, which is validated here when configCHECK_HANDLER_INSTALLATION
     * is 1, should be preferred when possible. */
    #if ( configCHECK_HANDLER_INSTALLATION == 1 )
    {
        const portISR_t * const pxVectorTable = portSCB_VTOR_REG;
    21f0:	4b10      	ldr	r3, [pc, #64]	@ (2234 <xPortStartScheduler+0x4a>)
    21f2:	681b      	ldr	r3, [r3, #0]
    21f4:	607b      	str	r3, [r7, #4]
    }
    #endif /* configASSERT_DEFINED */

    /* Make PendSV and SysTick the lowest priority interrupts, and make SVCall
     * the highest priority. */
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
    21f6:	4b10      	ldr	r3, [pc, #64]	@ (2238 <xPortStartScheduler+0x4e>)
    21f8:	681b      	ldr	r3, [r3, #0]
    21fa:	4a0f      	ldr	r2, [pc, #60]	@ (2238 <xPortStartScheduler+0x4e>)
    21fc:	f443 037f 	orr.w	r3, r3, #16711680	@ 0xff0000
    2200:	6013      	str	r3, [r2, #0]
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
    2202:	4b0d      	ldr	r3, [pc, #52]	@ (2238 <xPortStartScheduler+0x4e>)
    2204:	681b      	ldr	r3, [r3, #0]
    2206:	4a0c      	ldr	r2, [pc, #48]	@ (2238 <xPortStartScheduler+0x4e>)
    2208:	f043 437f 	orr.w	r3, r3, #4278190080	@ 0xff000000
    220c:	6013      	str	r3, [r2, #0]
    portNVIC_SHPR2_REG = 0;
    220e:	4b0b      	ldr	r3, [pc, #44]	@ (223c <xPortStartScheduler+0x52>)
    2210:	2200      	movs	r2, #0
    2212:	601a      	str	r2, [r3, #0]

    /* Start the timer that generates the tick ISR.  Interrupts are disabled
     * here already. */
    vPortSetupTimerInterrupt();
    2214:	f000 f896 	bl	2344 <vPortSetupTimerInterrupt>

    /* Initialise the critical nesting count ready for the first task. */
    uxCriticalNesting = 0;
    2218:	4b09      	ldr	r3, [pc, #36]	@ (2240 <xPortStartScheduler+0x56>)
    221a:	2200      	movs	r2, #0
    221c:	601a      	str	r2, [r3, #0]

    /* Start the first task. */
    prvPortStartFirstTask();
    221e:	f7ff ffd4 	bl	21ca <prvPortStartFirstTask>
     * exit error function to prevent compiler warnings about a static function
     * not being called in the case that the application writer overrides this
     * functionality by defining configTASK_RETURN_ADDRESS.  Call
     * vTaskSwitchContext() so link time optimisation does not remove the
     * symbol. */
    vTaskSwitchContext();
    2222:	f7fe fc39 	bl	a98 <vTaskSwitchContext>
    prvTaskExitError();
    2226:	f7ff ffa3 	bl	2170 <prvTaskExitError>

    /* Should not get here! */
    return 0;
    222a:	2300      	movs	r3, #0
}
    222c:	4618      	mov	r0, r3
    222e:	3708      	adds	r7, #8
    2230:	46bd      	mov	sp, r7
    2232:	bd80      	pop	{r7, pc}
    2234:	e000ed08 	and	lr, r0, r8, lsl #26
    2238:	e000ed20 	and	lr, r0, r0, lsr #26
    223c:	e000ed1c 	and	lr, r0, ip, lsl sp
    2240:	00002388 	andeq	r2, r0, r8, lsl #7

00002244 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2244:	b480      	push	{r7}
    2246:	af00      	add	r7, sp, #0
    /* Not implemented in ports where there is nothing to return to.
     * Artificially force an assert. */
    configASSERT( uxCriticalNesting == 1000UL );
}
    2248:	bf00      	nop
    224a:	46bd      	mov	sp, r7
    224c:	bc80      	pop	{r7}
    224e:	4770      	bx	lr

00002250 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
    2250:	b480      	push	{r7}
    2252:	b083      	sub	sp, #12
    2254:	af00      	add	r7, sp, #0
    __asm volatile
    2256:	f04f 0301 	mov.w	r3, #1
    225a:	f383 8811 	msr	BASEPRI, r3
    225e:	f3bf 8f6f 	isb	sy
    2262:	f3bf 8f4f 	dsb	sy
    2266:	607b      	str	r3, [r7, #4]
}
    2268:	bf00      	nop
    portDISABLE_INTERRUPTS();
    uxCriticalNesting++;
    226a:	4b05      	ldr	r3, [pc, #20]	@ (2280 <vPortEnterCritical+0x30>)
    226c:	681b      	ldr	r3, [r3, #0]
    226e:	3301      	adds	r3, #1
    2270:	4a03      	ldr	r2, [pc, #12]	@ (2280 <vPortEnterCritical+0x30>)
    2272:	6013      	str	r3, [r2, #0]
     * assert function also uses a critical section. */
    if( uxCriticalNesting == 1 )
    {
        configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
    }
}
    2274:	bf00      	nop
    2276:	370c      	adds	r7, #12
    2278:	46bd      	mov	sp, r7
    227a:	bc80      	pop	{r7}
    227c:	4770      	bx	lr
    227e:	bf00      	nop
    2280:	00002388 	andeq	r2, r0, r8, lsl #7

00002284 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
    2284:	b480      	push	{r7}
    2286:	b083      	sub	sp, #12
    2288:	af00      	add	r7, sp, #0
    configASSERT( uxCriticalNesting );
    uxCriticalNesting--;
    228a:	4b0a      	ldr	r3, [pc, #40]	@ (22b4 <vPortExitCritical+0x30>)
    228c:	681b      	ldr	r3, [r3, #0]
    228e:	3b01      	subs	r3, #1
    2290:	4a08      	ldr	r2, [pc, #32]	@ (22b4 <vPortExitCritical+0x30>)
    2292:	6013      	str	r3, [r2, #0]

    if( uxCriticalNesting == 0 )
    2294:	4b07      	ldr	r3, [pc, #28]	@ (22b4 <vPortExitCritical+0x30>)
    2296:	681b      	ldr	r3, [r3, #0]
    2298:	2b00      	cmp	r3, #0
    229a:	d105      	bne.n	22a8 <vPortExitCritical+0x24>
    229c:	2300      	movs	r3, #0
    229e:	607b      	str	r3, [r7, #4]
    __asm volatile
    22a0:	687b      	ldr	r3, [r7, #4]
    22a2:	f383 8811 	msr	BASEPRI, r3
}
    22a6:	bf00      	nop
    {
        portENABLE_INTERRUPTS();
    }
}
    22a8:	bf00      	nop
    22aa:	370c      	adds	r7, #12
    22ac:	46bd      	mov	sp, r7
    22ae:	bc80      	pop	{r7}
    22b0:	4770      	bx	lr
    22b2:	bf00      	nop
    22b4:	00002388 	andeq	r2, r0, r8, lsl #7

000022b8 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
    /* This is a naked function. */

    __asm volatile
    22b8:	f3ef 8009 	mrs	r0, PSP
    22bc:	f3bf 8f6f 	isb	sy
    22c0:	4b0d      	ldr	r3, [pc, #52]	@ (22f8 <xPortPendSVHandler+0x40>)
    22c2:	681a      	ldr	r2, [r3, #0]
    22c4:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
    22c8:	6010      	str	r0, [r2, #0]
    22ca:	e92d 4008 	stmdb	sp!, {r3, lr}
    22ce:	f04f 0001 	mov.w	r0, #1
    22d2:	f380 8811 	msr	BASEPRI, r0
    22d6:	f7fe fbdf 	bl	a98 <vTaskSwitchContext>
    22da:	f04f 0000 	mov.w	r0, #0
    22de:	f380 8811 	msr	BASEPRI, r0
    22e2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    22e6:	6819      	ldr	r1, [r3, #0]
    22e8:	6808      	ldr	r0, [r1, #0]
    22ea:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
    22ee:	f380 8809 	msr	PSP, r0
    22f2:	f3bf 8f6f 	isb	sy
    22f6:	4770      	bx	lr
    22f8:	0000238c 	andeq	r2, r0, ip, lsl #7
        "   bx r14                              \n"
        "                                       \n"
        "   .ltorg                              \n"
        ::"i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
    );
}
    22fc:	bf00      	nop

000022fe <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
    22fe:	b580      	push	{r7, lr}
    2300:	b082      	sub	sp, #8
    2302:	af00      	add	r7, sp, #0
    __asm volatile
    2304:	f04f 0301 	mov.w	r3, #1
    2308:	f383 8811 	msr	BASEPRI, r3
    230c:	f3bf 8f6f 	isb	sy
    2310:	f3bf 8f4f 	dsb	sy
    2314:	607b      	str	r3, [r7, #4]
}
    2316:	bf00      	nop
     * known. */
    portDISABLE_INTERRUPTS();
    traceISR_ENTER();
    {
        /* Increment the RTOS tick. */
        if( xTaskIncrementTick() != pdFALSE )
    2318:	f7fe fab6 	bl	888 <xTaskIncrementTick>
    231c:	4603      	mov	r3, r0
    231e:	2b00      	cmp	r3, #0
    2320:	d003      	beq.n	232a <xPortSysTickHandler+0x2c>
        {
            traceISR_EXIT_TO_SCHEDULER();

            /* A context switch is required.  Context switching is performed in
             * the PendSV interrupt.  Pend the PendSV interrupt. */
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    2322:	4b07      	ldr	r3, [pc, #28]	@ (2340 <xPortSysTickHandler+0x42>)
    2324:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
    2328:	601a      	str	r2, [r3, #0]
    232a:	2300      	movs	r3, #0
    232c:	603b      	str	r3, [r7, #0]
    __asm volatile
    232e:	683b      	ldr	r3, [r7, #0]
    2330:	f383 8811 	msr	BASEPRI, r3
}
    2334:	bf00      	nop
        {
            traceISR_EXIT();
        }
    }
    portENABLE_INTERRUPTS();
}
    2336:	bf00      	nop
    2338:	3708      	adds	r7, #8
    233a:	46bd      	mov	sp, r7
    233c:	bd80      	pop	{r7, pc}
    233e:	bf00      	nop
    2340:	e000ed04 	and	lr, r0, r4, lsl #26

00002344 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__( ( weak ) ) void vPortSetupTimerInterrupt( void )
{
    2344:	b480      	push	{r7}
    2346:	af00      	add	r7, sp, #0
        ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
    }
    #endif /* configUSE_TICKLESS_IDLE */

    /* Stop and clear the SysTick. */
    portNVIC_SYSTICK_CTRL_REG = 0UL;
    2348:	4b07      	ldr	r3, [pc, #28]	@ (2368 <vPortSetupTimerInterrupt+0x24>)
    234a:	2200      	movs	r2, #0
    234c:	601a      	str	r2, [r3, #0]
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
    234e:	4b07      	ldr	r3, [pc, #28]	@ (236c <vPortSetupTimerInterrupt+0x28>)
    2350:	2200      	movs	r2, #0
    2352:	601a      	str	r2, [r3, #0]

    /* Configure SysTick to interrupt at the requested rate. */
    portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
    2354:	4b06      	ldr	r3, [pc, #24]	@ (2370 <vPortSetupTimerInterrupt+0x2c>)
    2356:	4a07      	ldr	r2, [pc, #28]	@ (2374 <vPortSetupTimerInterrupt+0x30>)
    2358:	601a      	str	r2, [r3, #0]
    portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT_CONFIG | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
    235a:	4b03      	ldr	r3, [pc, #12]	@ (2368 <vPortSetupTimerInterrupt+0x24>)
    235c:	2207      	movs	r2, #7
    235e:	601a      	str	r2, [r3, #0]
}
    2360:	bf00      	nop
    2362:	46bd      	mov	sp, r7
    2364:	bc80      	pop	{r7}
    2366:	4770      	bx	lr
    2368:	e000e010 	and	lr, r0, r0, lsl r0
    236c:	e000e018 	and	lr, r0, r8, lsl r0
    2370:	e000e014 	and	lr, r0, r4, lsl r0
    2374:	000c34ff 	strdeq	r3, [ip], -pc	@ <UNPREDICTABLE>

Disassembly of section .rodata:

00002378 <uxTopUsedPriority>:
static const volatile UBaseType_t uxTopUsedPriority = configMAX_PRIORITIES - 1U;
    2378:	00000004 	andeq	r0, r0, r4
    237c:	454c4449 	strbmi	r4, [ip, #-1097]	@ 0xfffffbb7
    2380:	00000000 	andeq	r0, r0, r0

00002384 <xHeapStructSize>:
static const size_t xHeapStructSize = ( sizeof( BlockLink_t ) + ( ( size_t ) ( portBYTE_ALIGNMENT - 1 ) ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
    2384:	00000008 	andeq	r0, r0, r8

Disassembly of section .data:

00002388 <uxCriticalNesting>:
static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;
    2388:	aaaaaaaa 	bge	feaace38 <__StackTop+0xdeaaae38>

Disassembly of section .ARM.attributes:

00000000 <.ARM.attributes>:
   0:	00002e41 	andeq	r2, r0, r1, asr #28
   4:	61656100 	cmnvs	r5, r0, lsl #2
   8:	01006962 	tsteq	r0, r2, ror #18
   c:	00000024 	andeq	r0, r0, r4, lsr #32
  10:	726f4305 	rsbvc	r4, pc, #335544320	@ 0x14000000
  14:	2d786574 	cfldr64cs	mvdx6, [r8, #-464]!	@ 0xfffffe30
  18:	0600334d 	streq	r3, [r0], -sp, asr #6
  1c:	094d070a 	stmdbeq	sp, {r1, r3, r8, r9, sl}^
  20:	14041202 	strne	r1, [r4], #-514	@ 0xfffffdfe
  24:	17011501 	strne	r1, [r1, -r1, lsl #10]
  28:	1a011803 	bne	4603c <xNumberOfSuccessfulFrees+0x413c0>
  2c:	Address 0x2c is out of bounds.


Disassembly of section .comment:

00000000 <.comment>:
   0:	3a434347 	bcc	10d0d24 <xNumberOfSuccessfulFrees+0x10cc0a8>
   4:	35312820 	ldrcc	r2, [r1, #-2080]!	@ 0xfffff7e0
   8:	2e33313a 	mrccs	1, 1, r3, cr3, cr10, {1}
   c:	65722e32 	ldrbvs	r2, [r2, #-3634]!	@ 0xfffff1ce
  10:	322d316c 	eorcc	r3, sp, #108, 2
  14:	33312029 	teqcc	r1, #41	@ 0x29
  18:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
  1c:	32303220 	eorscc	r3, r0, #32, 4
  20:	30303133 	eorscc	r3, r0, r3, lsr r1
  24:	Address 0x24 is out of bounds.


Disassembly of section .debug_line:

00000000 <.debug_line>:
       0:	00000030 	andeq	r0, r0, r0, lsr r0
       4:	001a0002 	andseq	r0, sl, r2
       8:	01020000 	mrseq	r0, (UNDEF: 2)
       c:	000a0efb 	strdeq	r0, [sl], -fp
      10:	01010101 	tsteq	r1, r1, lsl #2
      14:	01000000 	mrseq	r0, (UNDEF: 0)
      18:	6f6f6200 	svcvs	0x006f6200
      1c:	00532e74 	subseq	r2, r3, r4, ror lr
      20:	00000000 	andeq	r0, r0, r0
      24:	98020500 	stmdals	r2, {r8, sl}
      28:	03000001 	movweq	r0, #1
      2c:	021e010a 	andseq	r0, lr, #-2147483646	@ 0x80000002
      30:	01010001 	tsteq	r1, r1
      34:	0000005f 	andeq	r0, r0, pc, asr r0
      38:	00430003 	subeq	r0, r3, r3
      3c:	01020000 	mrseq	r0, (UNDEF: 2)
      40:	000d0efb 	strdeq	r0, [sp], -fp
      44:	01010101 	tsteq	r1, r1, lsl #2
      48:	01000000 	mrseq	r0, (UNDEF: 0)
      4c:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
      50:	72462f2e 	subvc	r2, r6, #46, 30	@ 0xb8
      54:	54526565 	ldrbpl	r6, [r2], #-1381	@ 0xfffffa9b
      58:	4b2d534f 	blmi	b54d9c <xNumberOfSuccessfulFrees+0xb50120>
      5c:	656e7265 	strbvs	r7, [lr, #-613]!	@ 0xfffffd9b
      60:	6e692f6c 	cdpvs	15, 6, cr2, cr9, cr12, {3}
      64:	64756c63 	ldrbtvs	r6, [r5], #-3171	@ 0xfffff39d
      68:	73000065 	movwvc	r0, #101	@ 0x65
      6c:	74726174 	ldrbtvc	r6, [r2], #-372	@ 0xfffffe8c
      70:	0000632e 	andeq	r6, r0, lr, lsr #6
      74:	61740000 	cmnvs	r4, r0
      78:	682e6b73 	stmdavs	lr!, {r0, r1, r4, r5, r6, r8, r9, fp, sp, lr}
      7c:	00000100 	andeq	r0, r0, r0, lsl #2
      80:	00010500 	andeq	r0, r1, r0, lsl #10
      84:	019c0205 	orrseq	r0, ip, r5, lsl #4
      88:	05160000 	ldreq	r0, [r6, #-0]
      8c:	052f2f05 	streq	r2, [pc, #-3845]!	@ fffff18f <__StackTop+0xdfffd18f>
      90:	01022101 	tsteq	r2, r1, lsl #2
      94:	56010100 	strpl	r0, [r1], -r0, lsl #2
      98:	03000000 	movweq	r0, #0
      9c:	00002600 	andeq	r2, r0, r0, lsl #12
      a0:	fb010200 	blx	408aa <xNumberOfSuccessfulFrees+0x3bc2e>
      a4:	01000d0e 	tsteq	r0, lr, lsl #26
      a8:	00010101 	andeq	r0, r1, r1, lsl #2
      ac:	00010000 	andeq	r0, r1, r0
      b0:	70000100 	andvc	r0, r0, r0, lsl #2
      b4:	4674726f 	ldrbtmi	r7, [r4], -pc, ror #4
      b8:	74636e75 	strbtvc	r6, [r3], #-3701	@ 0xfffff18b
      bc:	736e6f69 	cmnvc	lr, #420	@ 0x1a4
      c0:	0000632e 	andeq	r6, r0, lr, lsr #6
      c4:	05000000 	streq	r0, [r0, #-0]
      c8:	02050037 	andeq	r0, r5, #55	@ 0x37
      cc:	000001a8 	andeq	r0, r0, r8, lsr #3
      d0:	67140501 	ldrvs	r0, [r4, -r1, lsl #10]
      d4:	052f1305 	streq	r1, [pc, #-773]!	@ fffffdd7 <__StackTop+0xdfffddd7>
      d8:	0e05310a 	adfeqs	f3, f5, #2.0
      dc:	3d0c0521 	cfstr32cc	mvfx0, [ip, #-132]	@ 0xffffff7c
      e0:	053d0d05 	ldreq	r0, [sp, #-3333]!	@ 0xfffff2fb
      e4:	0c053910 			@ <UNDEFINED> instruction: 0x0c053910
      e8:	21010542 	tstcs	r1, r2, asr #10
      ec:	01000502 	tsteq	r0, r2, lsl #10
      f0:	000a1e01 	andeq	r1, sl, r1, lsl #28
      f4:	15000300 	strne	r0, [r0, #-768]	@ 0xfffffd00
      f8:	02000001 	andeq	r0, r0, #1
      fc:	0d0efb01 	vstreq	d15, [lr, #-4]
     100:	01010100 	mrseq	r0, (UNDEF: 17)
     104:	00000001 	andeq	r0, r0, r1
     108:	01000001 	tsteq	r0, r1
     10c:	462f2e2e 	strtmi	r2, [pc], -lr, lsr #28
     110:	52656572 	rsbpl	r6, r5, #478150656	@ 0x1c800000
     114:	2d534f54 	ldclcs	15, cr4, [r3, #-336]	@ 0xfffffeb0
     118:	6e72654b 	cdpvs	5, 7, cr6, cr2, cr11, {2}
     11c:	2e006c65 	cdpcs	12, 0, cr6, cr0, cr5, {3}
     120:	72462f2e 	subvc	r2, r6, #46, 30	@ 0xb8
     124:	54526565 	ldrbpl	r6, [r2], #-1381	@ 0xfffffa9b
     128:	4b2d534f 	blmi	b54e6c <xNumberOfSuccessfulFrees+0xb501f0>
     12c:	656e7265 	strbvs	r7, [lr, #-613]!	@ 0xfffffd9b
     130:	6f702f6c 	svcvs	0x00702f6c
     134:	62617472 	rsbvs	r7, r1, #1912602624	@ 0x72000000
     138:	472f656c 	strmi	r6, [pc, -ip, ror #10]!
     13c:	412f4343 			@ <UNDEFINED> instruction: 0x412f4343
     140:	435f4d52 	cmpmi	pc, #5248	@ 0x1480
     144:	2f00334d 	svccs	0x0000334d
     148:	2f727375 	svccs	0x00727375
     14c:	2f62696c 	svccs	0x0062696c
     150:	2f636367 	svccs	0x00636367
     154:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	@ 0xfffffe7c
     158:	656e6f6e 	strbvs	r6, [lr, #-3950]!	@ 0xfffff092
     15c:	6261652d 	rsbvs	r6, r1, #188743680	@ 0xb400000
     160:	33312f69 	teqcc	r1, #420	@ 0x1a4
     164:	312e322e 			@ <UNDEFINED> instruction: 0x312e322e
     168:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
     16c:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
     170:	2f2e2e00 	svccs	0x002e2e00
     174:	65657246 	strbvs	r7, [r5, #-582]!	@ 0xfffffdba
     178:	534f5452 	movtpl	r5, #62546	@ 0xf452
     17c:	72654b2d 	rsbvc	r4, r5, #46080	@ 0xb400
     180:	2f6c656e 	svccs	0x006c656e
     184:	6c636e69 	stclvs	14, cr6, [r3], #-420	@ 0xfffffe5c
     188:	00656475 	rsbeq	r6, r5, r5, ror r4
     18c:	7273752f 	rsbsvc	r7, r3, #197132288	@ 0xbc00000
     190:	636e692f 	cmnvs	lr, #770048	@ 0xbc000
     194:	6564756c 	strbvs	r7, [r4, #-1388]!	@ 0xfffffa94
    b start
     198:	77656e2f 	strbvc	r6, [r5, -pc, lsr #28]!
{
     19c:	0062696c 	rsbeq	r6, r2, ip, ror #18
    vTaskStartScheduler();
     1a0:	73617400 	cmnvc	r1, #0, 8
    return;
     1a4:	632e736b 			@ <UNDEFINED> instruction: 0x632e736b
void* memset(void* dst, int value, unsigned int size) {
     1a8:	00000100 	andeq	r0, r0, r0, lsl #2
     1ac:	74726f70 	ldrbtvc	r6, [r2], #-3952	@ 0xfffff090
     1b0:	7263616d 	rsbvc	r6, r3, #1073741851	@ 0x4000001b
    unsigned char *ptr = (unsigned char *)dst;
     1b4:	00682e6f 	rsbeq	r2, r8, pc, ror #28
    unsigned char byte_value = (unsigned char)value;
     1b8:	73000002 	movwvc	r0, #2
    while(size > 0){
     1bc:	65646474 	strbvs	r6, [r4, #-1140]!	@ 0xfffffb8c
        *ptr = byte_value;
     1c0:	00682e66 	rsbeq	r2, r8, r6, ror #28
        ptr++;
     1c4:	73000003 	movwvc	r0, #3
     1c8:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
        size--;
     1cc:	00682e74 	rsbeq	r2, r8, r4, ror lr
    while(size > 0){
     1d0:	70000003 	andvc	r0, r0, r3
     1d4:	646a6f72 	strbtvs	r6, [sl], #-3954	@ 0xfffff08e
     1d8:	2e736665 	cdpcs	6, 7, cr6, cr3, cr5, {3}
     1dc:	00040068 	andeq	r0, r4, r8, rrx
     1e0:	73696c00 	cmnvc	r9, #0, 24
    {
     1e4:	00682e74 	rsbeq	r2, r8, r4, ror lr
     1e8:	74000004 	strvc	r0, [r0], #-4
     1ec:	2e6b7361 	cdpcs	3, 6, cr7, cr11, cr1, {3}
     1f0:	00040068 	andeq	r0, r4, r8, rrx
            pxStack = pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) );
     1f4:	726f7000 	rsbvc	r7, pc, #0
     1f8:	6c626174 	stfvse	f6, [r2], #-464	@ 0xfffffe30
     1fc:	00682e65 	rsbeq	r2, r8, r5, ror #28
            if( pxStack != NULL )
     200:	73000004 	movwvc	r0, #4
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     204:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
     208:	00682e67 	rsbeq	r2, r8, r7, ror #28
                if( pxNewTCB != NULL )
     20c:	00000005 	andeq	r0, r0, r5
     210:	05000505 	streq	r0, [r0, #-1285]	@ 0xfffffafb
                    ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
     214:	0001e402 	andeq	lr, r1, r2, lsl #8
     218:	0cef0300 	stcleq	3, cr0, [pc]	@ 220 <prvCreateTask+0x3c>
                    pxNewTCB->pxStack = pxStack;
     21c:	03170501 	tsteq	r7, #4194304	@ 0x400000
     220:	0f05742c 	svceq	0x0005742c
                    vPortFreeStack( pxStack );
     224:	42280568 	eormi	r0, r8, #104, 10	@ 0x1a000000
     228:	054c1305 	strbeq	r1, [ip, #-773]	@ 0xfffffcfb
                pxNewTCB = NULL;
     22c:	27053e1e 	smladcs	r5, lr, lr, r3
        if( pxNewTCB != NULL )
     230:	5015055b 	andspl	r0, r5, fp, asr r5
     234:	054f1a05 	strbeq	r1, [pc, #-2565]	@ fffff837 <__StackTop+0xdfffd837>
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
     238:	0d05330b 	stceq	3, cr3, [r5, #-44]	@ 0xffffffd4
     23c:	053c0a03 	ldreq	r0, [ip, #-2563]!	@ 0xfffff5fd
     240:	0505d910 	streq	sp, [r5, #-2320]	@ 0xfffff6f0
     244:	4a090321 	bmi	240ed0 <xNumberOfSuccessfulFrees+0x23c254>
     248:	057a1405 	ldrbeq	r1, [sl, #-1029]!	@ 0xfffffbfb
     24c:	0d05ae0b 	stceq	14, cr10, [r5, #-44]	@ 0xffffffd4
     250:	053c0903 	ldreq	r0, [ip, #-2307]!	@ 0xfffff6fd
    }
     254:	05403d15 	strbeq	r3, [r0, #-3349]	@ 0xfffff2eb
     258:	05054110 	streq	r4, [r5, #-272]	@ 0xfffffef0
    {
     25c:	03010521 	movweq	r0, #5409	@ 0x1521
     260:	23054a31 	movwcs	r4, #23089	@ 0x5a31
     264:	05742103 	ldrbeq	r2, [r4, #-259]!	@ 0xfffffefd
     268:	16052e2c 	strne	r2, [r5], -ip, lsr #28
        pxNewTCB = prvCreateTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );
     26c:	2f2e0558 	svccs	0x002e0558
     270:	05205705 	streq	r5, [r0, #-1797]!	@ 0xfffff8fb
     274:	07052e16 	smladeq	r5, r6, lr, r2
     278:	05201c03 	streq	r1, [r0, #-3075]!	@ 0xfffff3fd
     27c:	09053e10 	stmdbeq	r5, {r4, r9, sl, fp, ip, sp}
        if( pxNewTCB != NULL )
     280:	222f052e 	eorcs	r0, pc, #192937984	@ 0xb800000
     284:	054a2705 	strbeq	r2, [sl, #-1797]	@ 0xfffff8fb
            prvAddNewTaskToReadyList( pxNewTCB );
     288:	0f056b17 	svceq	0x00056b17
            xReturn = pdPASS;
     28c:	0053054a 	subseq	r0, r3, sl, asr #10
     290:	03020402 	movweq	r0, #9218	@ 0x2402
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     294:	27052e79 	smlsdxcs	r5, r9, lr, r2
        return xReturn;
     298:	01040200 	mrseq	r0, R12_usr
    }
     29c:	0311053c 	tsteq	r1, #60, 10	@ 0xf000000
     2a0:	3e054a09 	vmlacc.f32	s8, s10, s18
{
     2a4:	05200a03 	streq	r0, [r0, #-2563]!	@ 0xfffff5fd
     2a8:	4a0a0307 	bmi	280ecc <xNumberOfSuccessfulFrees+0x27c250>
     2ac:	053e1405 	ldreq	r1, [lr, #-1029]!	@ 0xfffffbfb
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
     2b0:	0505351a 	streq	r3, [r5, #-1306]	@ 0xfffffae6
     2b4:	3f5c5943 	svccc	0x005c5943
     2b8:	03260559 			@ <UNDEFINED> instruction: 0x03260559
     2bc:	053c00c2 	ldreq	r0, [ip, #-194]!	@ 0xffffff3e
     2c0:	04020024 	streq	r0, [r2], #-36	@ 0xffffffdc
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     2c4:	07056601 	streq	r6, [r5, -r1, lsl #12]
     2c8:	052e1303 	streq	r1, [lr, #-771]!	@ 0xfffffcfd
    if( pcName != NULL )
     2cc:	01054018 	tsteq	r5, r8, lsl r0
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     2d0:	50050542 	andpl	r0, r5, r2, asr #10
     2d4:	054d0905 	strbeq	r0, [sp, #-2309]	@ 0xfffff6fb
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     2d8:	24053026 	strcs	r3, [r5], #-38	@ 0xffffffda
     2dc:	301e053c 	andscc	r0, lr, ip, lsr r5
     2e0:	052e0f05 	streq	r0, [lr, #-3845]!	@ 0xfffff0fb
     2e4:	2c05321e 	sfmcs	f3, 4, [r5], {30}
     2e8:	2e13053e 	mrccs	5, 0, r0, cr3, cr14, {1}
            if( pcName[ x ] == ( char ) 0x00 )
     2ec:	05331505 	ldreq	r1, [r3, #-1285]!	@ 0xfffffafb
     2f0:	3c0c0327 	stccc	3, cr0, [ip], {39}	@ 0x27
     2f4:	052e1305 	streq	r1, [lr, #-773]!	@ 0xfffffcfb
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     2f8:	3d053025 	stccc	0, cr3, [r5, #-148]	@ 0xffffff6c
     2fc:	2e17053c 	mrccs	5, 0, r0, cr7, cr12, {1}
     300:	05302605 	ldreq	r2, [r0, #-1541]!	@ 0xfffff9fb
                break;
     304:	3c0d0319 	stccc	3, cr0, [sp], {25}
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1U ] = '\0';
     308:	0a030d05 	beq	c3724 <xNumberOfSuccessfulFrees+0xbeaa8>
     30c:	02090558 	andeq	r0, r9, #88, 10	@ 0x16000000
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
     310:	1f051641 	svcne	0x00051641
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
     314:	2e0b0530 	cfmv64hrcs	mvdx11, r0
    pxNewTCB->uxPriority = uxPriority;
     318:	00320d05 	eorseq	r0, r2, r5, lsl #26
     31c:	06010402 	streq	r0, [r1], -r2, lsl #8
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     320:	06050574 			@ <UNDEFINED> instruction: 0x06050574
     324:	03010588 	movweq	r0, #5512	@ 0x1588
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     328:	20080b92 	mulcs	r8, r2, fp
     32c:	053d1005 	ldreq	r1, [sp, #-5]!
     330:	1405300a 	strne	r3, [r5], #-10
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     334:	341d0567 	ldrcc	r0, [sp], #-1383	@ 0xfffffa99
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );
     338:	052e0505 	streq	r0, [lr, #-1285]!	@ 0xfffffafb
     33c:	2905253f 	stmdbcs	r5, {r0, r1, r2, r3, r4, r5, r8, sl, sp}
     340:	5a16054a 	bpl	581870 <xNumberOfSuccessfulFrees+0x57cbf4>
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     344:	054a0b05 	strbeq	r0, [sl, #-2821]	@ 0xfffff4fb
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     348:	02000187 	andeq	r0, r0, #-1073741791	@ 0xc0000021
     34c:	79030204 	stmdbvc	r3, {r2, r9}
     350:	0036052e 	eorseq	r0, r6, lr, lsr #10
     354:	3c010402 	cfstrscc	mvf0, [r1], {2}
    if( pxCreatedTask != NULL )
     358:	09030d05 	stmdbeq	r3, {r0, r2, r8, sl, fp}
     35c:	0325054a 			@ <UNDEFINED> instruction: 0x0325054a
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     360:	12052009 	andne	r2, r5, #9
}
     364:	2e05055b 	cfrshl32cs	mvfx5, mvfx11, r0
     368:	05242005 	streq	r2, [r4, #-5]!
    {
     36c:	00ce0317 	sbceq	r0, lr, r7, lsl r3
     370:	030b052e 	movweq	r0, #46382	@ 0xb52e
        taskENTER_CRITICAL();
     374:	5d05e40a 	cfstrspl	mvf14, [r5, #-40]	@ 0xffffffd8
            uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );
     378:	02040200 	andeq	r0, r4, #0, 4
     37c:	3c7fa403 	cfldrdcc	mvd10, [pc], #-12	@ 378 <prvAddNewTaskToReadyList+0xc>
     380:	02002e05 	andeq	r2, r0, #5, 28	@ 0x50
            if( pxCurrentTCB == NULL )
     384:	053c0104 	ldreq	r0, [ip, #-260]!	@ 0xfffffefc
     388:	00de030d 	sbcseq	r0, lr, sp, lsl #6
                pxCurrentTCB = pxNewTCB;
     38c:	030c054a 	movweq	r0, #50506	@ 0xc54a
                if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     390:	01052012 	tsteq	r5, r2, lsl r0
     394:	0f05a321 	svceq	0x0005a321
                    prvInitialiseTaskLists();
     398:	053c0d03 	ldreq	r0, [ip, #-3331]!	@ 0xfffff2fd
     39c:	3c0f0307 	stccc	3, cr0, [pc], {7}
                if( xSchedulerRunning == pdFALSE )
     3a0:	05050204 	streq	r0, [r5, #-516]	@ 0xfffffdfc
     3a4:	3c64d203 	sfmcc	f5, 3, [r4], #-12
                    if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     3a8:	04980105 	ldreq	r0, [r8], #261	@ 0x105
     3ac:	031e0501 	tsteq	lr, #4194304	@ 0x400000
     3b0:	05201bc0 	streq	r1, [r0, #-3008]!	@ 0xfffff440
                        pxCurrentTCB = pxNewTCB;
     3b4:	14054b1b 	strne	r4, [r5], #-2843	@ 0xfffff4e5
     3b8:	0312053d 	tsteq	r2, #255852544	@ 0xf400000
            uxTaskNumber++;
     3bc:	05053c13 	streq	r3, [r5, #-3091]	@ 0xfffff3ed
     3c0:	052e1703 	streq	r1, [lr, #-1795]!	@ 0xfffff8fd
            prvAddTaskToReadyList( pxNewTCB );
     3c4:	04cc3101 	strbeq	r3, [ip], #257	@ 0x101
     3c8:	03050502 	movweq	r0, #21762	@ 0x5502
     3cc:	053c6485 	ldreq	r6, [ip, #-1157]!	@ 0xfffffb7b
     3d0:	01049801 	tsteq	r4, r1, lsl #16
     3d4:	93031705 	movwls	r1, #14085	@ 0x3705
     3d8:	0505201c 	streq	r2, [r5, #-28]	@ 0xffffffe4
     3dc:	31010540 	tstcc	r1, r0, asr #10
     3e0:	0320056a 			@ <UNDEFINED> instruction: 0x0320056a
     3e4:	1e052e25 	cdpne	14, 0, cr2, cr5, cr5, {1}
     3e8:	3209053c 	andcc	r0, r9, #60, 10	@ 0xf000000
     3ec:	c0030105 	andgt	r0, r3, r5, lsl #2
     3f0:	c5030100 	strgt	r0, [r3, #-256]	@ 0xffffff00
     3f4:	0d057400 	cfstrseq	mvf7, [r5, #-0]
     3f8:	2f10053d 	svccs	0x0010053d
     3fc:	0d030905 	vstreq.16	s0, [r3, #-10]	@ <UNPREDICTABLE>
     400:	301e052e 	andscc	r0, lr, lr, lsr #10
     404:	05342405 	ldreq	r2, [r4, #-1029]!	@ 0xfffffbfb
     408:	26053c22 	strcs	r3, [r5], -r2, lsr #24
     40c:	2e0f0531 	mcrcs	5, 0, r0, cr15, cr1, {1}
     410:	053e2c05 	ldreq	r2, [lr, #-3077]!	@ 0xfffff3fb
     414:	1a052e13 	bne	14bc68 <xNumberOfSuccessfulFrees+0x146fec>
     418:	25210540 	strcs	r0, [r1, #-1344]!	@ 0xfffffac0
     41c:	052e1f05 	streq	r1, [lr, #-3845]!	@ 0xfffff0fb
     420:	02002f19 	andeq	r2, r0, #25, 30	@ 0x64
     424:	08060104 	stmdaeq	r6, {r2, r8}
     428:	0402002e 	streq	r0, [r2], #-46	@ 0xffffffd2
     42c:	83064a03 	movwhi	r4, #27139	@ 0x6a03
     430:	04020013 	streq	r0, [r2], #-19	@ 0xffffffed
     434:	2e080601 	cfmadd32cs	mvax0, mvfx0, mvfx8, mvfx1
     438:	03040200 	movweq	r0, #16896	@ 0x4200
     43c:	0583064a 	streq	r0, [r3, #1610]	@ 0x64a
     440:	18410226 	stmdane	r1, {r1, r2, r5, r9}^
     444:	052e4105 	streq	r4, [lr, #-261]!	@ 0xfffffefb
        taskEXIT_CRITICAL();
     448:	3b053c1f 	blcc	14f4cc <xNumberOfSuccessfulFrees+0x14a850>
        if( xSchedulerRunning != pdFALSE )
     44c:	031c0530 	tsteq	ip, #48, 10	@ 0xc000000
     450:	4405586f 	strmi	r5, [r5], #-2159	@ 0xfffff791
            taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
     454:	0317052e 	tsteq	r7, #192937984	@ 0xb800000
     458:	19053c21 	stmdbne	r5, {r0, r5, sl, fp, ip, sp}
     45c:	03240544 			@ <UNDEFINED> instruction: 0x03240544
     460:	1b052e0d 	blne	14bc9c <xNumberOfSuccessfulFrees+0x147020>
     464:	4025053e 	eormi	r0, r5, lr, lsr r5
     468:	02002305 	andeq	r2, r0, #335544320	@ 0x14000000
     46c:	053c0104 	ldreq	r0, [ip, #-260]!	@ 0xfffffefc
    }
     470:	2105323f 	tstcs	r5, pc, lsr r2
     474:	3d34055f 	cfldr32cc	mvfx0, [r4, #-380]!	@ 0xfffffe84
     478:	053e2a05 	ldreq	r2, [lr, #-2565]!	@ 0xfffff5fb
     47c:	17054427 	strne	r4, [r5, -r7, lsr #8]
     480:	322d054a 	eorcc	r0, sp, #310378496	@ 0x12800000
     484:	05341d05 	ldreq	r1, [r4, #-3333]!	@ 0xfffff2fb
     488:	9e0f0309 	cdpls	3, 0, cr0, cr15, cr9, {0}
     48c:	05330c05 	ldreq	r0, [r3, #-3077]!	@ 0xfffff3fb
     490:	5c082101 	stfpls	f2, [r8], {1}
{
     494:	05441005 	strbeq	r1, [r4, #-5]
     498:	0105420c 	tsteq	r5, ip, lsl #4
    BaseType_t xReturn = pdPASS;
     49c:	1c057821 	stcne	8, cr7, [r5], {33}	@ 0x21
    char cIdleName[ configMAX_TASK_NAME_LEN ] = { 0 };
     4a0:	053c1603 	ldreq	r1, [ip, #-1539]!	@ 0xfffff9fd
     4a4:	0c053011 	stceq	0, cr3, [r5], {17}
     4a8:	21010542 	tstcs	r1, r2, asr #10
    TaskFunction_t pxIdleTaskFunction = NULL;
     4ac:	350c0578 	strcc	r0, [ip, #-1400]	@ 0xfffffa88
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
     4b0:	6a2f0105 	bvs	bc08cc <xNumberOfSuccessfulFrees+0xbbbc50>
        cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
     4b4:	00510d05 	subseq	r0, r1, r5, lsl #26
     4b8:	06010402 	streq	r0, [r1], -r2, lsl #8
     4bc:	0402003c 	streq	r0, [r2], #-60	@ 0xffffffc4
     4c0:	0b053c02 	bleq	14f4d0 <xNumberOfSuccessfulFrees+0x14a854>
     4c4:	04040200 	streq	r0, [r4], #-512	@ 0xfffffe00
        if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
     4c8:	0c052006 	stceq	0, cr2, [r5], {6}
     4cc:	2f010525 	svccs	0x00010525
     4d0:	8202ea03 	andhi	lr, r2, #12288	@ 0x3000
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
     4d4:	0b030505 	bleq	c18f0 <xNumberOfSuccessfulFrees+0xbcc74>
     4d8:	1605314a 	strne	r3, [r5], -sl, asr #2
     4dc:	68050530 	stmdavs	r5, {r4, r5, r8, sl}
            break;
     4e0:	052f1605 	streq	r1, [pc, #-1541]!	@ fffffee3 <__StackTop+0xdfffdee3>
    cIdleName[ xIdleTaskNameIndex ] = '\0';
     4e4:	0105400c 	tsteq	r5, ip
     4e8:	00e40321 	rsceq	r0, r4, r1, lsr #6
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
     4ec:	3f100566 	svccc	0x00100566
     4f0:	0d031e05 	stceq	14, cr1, [r3, #-20]	@ 0xffffffec
            pxIdleTaskFunction = &prvIdleTask;
     4f4:	2e07052e 	cfsh32cs	mvfx0, mvfx7, #30
            xReturn = xTaskCreate( pxIdleTaskFunction,
     4f8:	05403705 	strbeq	r3, [r0, #-1797]	@ 0xfffff8fb
     4fc:	14052e1a 	strne	r2, [r5], #-3610	@ 0xfffff1e6
     500:	3e0b0532 	mcrcc	5, 0, r0, cr11, cr2, {1}
     504:	053e0d05 	ldreq	r0, [lr, #-3333]!	@ 0xfffff2fb
     508:	080b031d 	stmdaeq	fp, {r0, r2, r3, r4, r8, r9}
     50c:	2e0b0512 	mcrcs	5, 0, r0, cr11, cr2, {0}
     510:	054e1505 	strbeq	r1, [lr, #-1285]	@ 0xfffffafb
        if( xReturn != pdPASS )
     514:	2a053c13 	bcs	14f568 <xNumberOfSuccessfulFrees+0x14a8ec>
     518:	4b150535 	blmi	5419f4 <xNumberOfSuccessfulFrees+0x53cd78>
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
     51c:	0b031d05 	bleq	c7938 <xNumberOfSuccessfulFrees+0xc2cbc>
     520:	3c1b0520 	cfldr32cc	mvfx0, [fp], {32}
     524:	052f2005 	streq	r2, [pc, #-5]!	@ 527 <prvCreateIdleTasks+0x93>
            break;
     528:	2e053e17 	mcrcs	14, 0, r3, cr5, cr7, {0}
}
     52c:	3d190551 	cfldr32cc	mvfx0, [r9, #-324]	@ 0xfffffebc
     530:	00281505 	eoreq	r1, r8, r5, lsl #10
     534:	06010402 	streq	r0, [r1], -r2, lsl #8
     538:	02002e08 	andeq	r2, r0, #8, 28	@ 0x80
     53c:	054a0304 	strbeq	r0, [sl, #-772]	@ 0xfffffcfc
{
     540:	05860619 	streq	r0, [r6, #1561]	@ 0x619
     544:	19052e17 	stmdbne	r5, {r0, r1, r2, r4, r9, sl, fp, sp}
    xReturn = prvCreateIdleTasks();
     548:	04020030 	streq	r0, [r2], #-48	@ 0xffffffd0
    if( xReturn == pdPASS )
     54c:	2e080601 	cfmadd32cs	mvax0, mvfx0, mvfx8, mvfx1
     550:	03040200 	movweq	r0, #16896	@ 0x4200
    __asm volatile
     554:	0615054a 	ldreq	r0, [r5], -sl, asr #10
     558:	05820903 	streq	r0, [r2, #2307]	@ 0x903
     55c:	02100326 	andseq	r0, r0, #-1744830464	@ 0x98000000
     560:	41050141 	tstmi	r5, r1, asr #2
}
     564:	3c1f052e 	cfldr32cc	mvfx0, [pc], {46}	@ 0x2e
        xNextTaskUnblockTime = portMAX_DELAY;
     568:	053e3105 	ldreq	r3, [lr, #-261]!	@ 0xfffffefb
     56c:	7fb90313 	svcvc	0x00b90313
        xSchedulerRunning = pdTRUE;
     570:	0315052e 	tsteq	r5, #192937984	@ 0xb800000
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     574:	052000e0 	streq	r0, [r0, #-224]!	@ 0xffffff20
     578:	25059e13 	strcs	r9, [r5, #-3603]	@ 0xfffff1ed
        ( void ) xPortStartScheduler();
     57c:	03230530 			@ <UNDEFINED> instruction: 0x03230530
    ( void ) uxTopUsedPriority;
     580:	13052e2f 	movwne	r2, #24111	@ 0x5e2f
}
     584:	3025052e 	eorcc	r0, r5, lr, lsr #10
     588:	2a031605 	bcs	c5da4 <xNumberOfSuccessfulFrees+0xc1128>
     58c:	030c053c 	movweq	r0, #50492	@ 0xc53c
     590:	0105580d 	tsteq	r5, sp, lsl #16
     594:	03050521 	movweq	r0, #21793	@ 0x5521
     598:	9008018a 	andls	r0, r8, sl, lsl #3
{
     59c:	053f2205 	ldreq	r2, [pc, #-517]!	@ 39f <prvAddNewTaskToReadyList+0x33>
     5a0:	21052e0b 	tstcs	r5, fp, lsl #28
    __asm volatile
     5a4:	03050532 	movweq	r0, #21810	@ 0x5532
     5a8:	053c00cb 	ldreq	r0, [ip, #-203]!	@ 0xffffff35
     5ac:	7fb90321 	svcvc	0x00b90321
     5b0:	030d0520 	movweq	r0, #54560	@ 0xd520
}
     5b4:	02043c2e 	andeq	r3, r4, #11776	@ 0x2e00
    xSchedulerRunning = pdFALSE;
     5b8:	e9030905 	stmdb	r3, {r0, r2, r8, fp}
    vPortEndScheduler();
     5bc:	10053c58 	andne	r3, r5, r8, asr ip
}
     5c0:	0501044c 	streq	r0, [r1, #-1100]	@ 0xfffffbb4
     5c4:	0402000d 	streq	r0, [r2], #-13
     5c8:	27950301 	ldrcs	r0, [r5, r1, lsl #6]
{
     5cc:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
     5d0:	90080603 	andls	r0, r8, r3, lsl #12
     5d4:	05055e06 	streq	r5, [r5, #-3590]	@ 0xfffff1fa
     5d8:	052e1303 	streq	r1, [lr, #-771]!	@ 0xfffffcfd
}
     5dc:	00ea0301 	rsceq	r0, sl, r1, lsl #6
     5e0:	032e05e4 			@ <UNDEFINED> instruction: 0x032e05e4
     5e4:	05055813 	streq	r5, [r5, #-2067]	@ 0xfffff7ed
{
     5e8:	01055a2e 	tsteq	r5, lr, lsr #20
     5ec:	05056c4d 	streq	r6, [r5, #-3149]	@ 0xfffff3b3
    TCB_t * pxTCB = NULL;
     5f0:	6d660c03 	stclvs	12, cr0, [r6, #-12]!
    BaseType_t xAlreadyYielded = pdFALSE;
     5f4:	0105f408 	tsteq	r5, r8, lsl #8	@ <UNPREDICTABLE>
        taskENTER_CRITICAL();
     5f8:	742b034d 	strtvc	r0, [fp], #-845	@ 0xfffffcb3
            const BaseType_t xCoreID = ( BaseType_t ) portGET_CORE_ID();
     5fc:	16031605 	strne	r1, [r3], -r5, lsl #12
            uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended - 1U );
     600:	2e14054a 	cfmac32cs	mvfx0, mvfx4, mvfx10
     604:	00300505 	eorseq	r0, r0, r5, lsl #10
            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     608:	06010402 	streq	r0, [r1], -r2, lsl #8
     60c:	02002e08 	andeq	r2, r0, #8, 28	@ 0x80
     610:	054a0304 	strbeq	r0, [sl, #-772]	@ 0xfffffcfc
                if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     614:	0584061e 	streq	r0, [r4, #1566]	@ 0x61e
     618:	09052e07 	stmdbeq	r5, {r0, r1, r2, r9, sl, fp, sp}
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     61c:	04020030 	streq	r0, [r2], #-48	@ 0xffffffd0
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     620:	2e080601 	cfmadd32cs	mvax0, mvfx0, mvfx8, mvfx1
     624:	03040200 	movweq	r0, #16896	@ 0x4200
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
     628:	0383064a 	orreq	r0, r3, #77594624	@ 0x4a00000
     62c:	01420214 	cmpeq	r2, r4, lsl r2
     630:	b1081b05 	tstlt	r8, r5, lsl #22
     634:	052e3605 	streq	r3, [lr, #-1541]!	@ 0xfffff9fb
     638:	15053c0b 	strne	r3, [r5, #-3083]	@ 0xfffff3f5
     63c:	32210533 	eorcc	r0, r1, #213909504	@ 0xcc00000
     640:	054e1505 	strbeq	r1, [lr, #-1285]	@ 0xfffffafb
     644:	2e15030c 	cdpcs	3, 1, cr0, cr5, cr12, {0}
     648:	08210105 	stmdaeq	r1!, {r0, r2, r8}
     64c:	03050525 	movweq	r0, #21797	@ 0x5525
     650:	1405580a 	strne	r5, [r5], #-2058	@ 0xfffff7f6
     654:	3e05055f 	cfrshl32cc	mvfx5, mvfx15, r0
     658:	01040200 	mrseq	r0, R12_usr
     65c:	00200806 	eoreq	r0, r0, r6, lsl #16
     660:	4a030402 	bmi	c1670 <xNumberOfSuccessfulFrees+0xbc9f4>
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
     664:	82130306 	andshi	r0, r3, #402653184	@ 0x18000000
     668:	01040200 	mrseq	r0, R12_usr
     66c:	002e0806 	eoreq	r0, lr, r6, lsl #16
     670:	4a030402 	bmi	c1680 <xNumberOfSuccessfulFrees+0xbca04>
     674:	1b058306 	blne	161294 <xNumberOfSuccessfulFrees+0x15c618>
     678:	05164102 	ldreq	r4, [r6, #-258]	@ 0xfffffefe
     67c:	0b052e36 	bleq	14bf5c <xNumberOfSuccessfulFrees+0x1472e0>
     680:	3421053c 	strtcc	r0, [r1], #-1340	@ 0xfffffac4
     684:	12030105 	andne	r0, r3, #1073741825	@ 0x40000001
     688:	0505cc3c 	streq	ip, [r5, #-3132]	@ 0xfffff3c4
     68c:	3023054e 	eorcc	r0, r3, lr, asr #10
     690:	054b2405 	strbeq	r2, [fp, #-1029]	@ 0xfffffbfb
     694:	01054c05 	tsteq	r5, r5, lsl #24
     698:	1f058631 	svcne	0x00058631
     69c:	4b20054e 	blmi	801bdc <xNumberOfSuccessfulFrees+0x7fcf60>
     6a0:	a34d0105 	movtge	r0, #53509	@ 0xd105
                        prvAddTaskToReadyList( pxTCB );
     6a4:	05600505 	strbeq	r0, [r0, #-1285]!	@ 0xfffffafb
     6a8:	4405311a 	strmi	r3, [r5], #-282	@ 0xfffffee6
     6ac:	2e1a053d 	mrccs	5, 0, r0, cr10, cr13, {1}
     6b0:	18032b05 	stmdane	r3, {r0, r2, r8, r9, fp, sp}
     6b4:	2e1f053c 	mrccs	5, 0, r0, cr15, cr12, {1}
     6b8:	052e0b05 	streq	r0, [lr, #-2821]!	@ 0xfffff4fb
     6bc:	0402005f 	streq	r0, [r2], #-95	@ 0xffffffa1
     6c0:	3e052e01 	cdpcc	14, 0, cr2, cr5, cr1, {0}
     6c4:	01040200 	mrseq	r0, R12_usr
     6c8:	4315052e 	tstmi	r5, #192937984	@ 0xb800000
     6cc:	052f1c05 	streq	r1, [pc, #-3077]!	@ fffffacf <__StackTop+0xdfffdacf>
     6d0:	10054c21 	andne	r4, r5, r1, lsr #24
     6d4:	3f0d052e 	svccc	0x000d052e
     6d8:	052e1c05 	streq	r1, [lr, #-3077]!	@ 0xfffff3fb
     6dc:	15054b0d 	strne	r4, [r5, #-2829]	@ 0xfffff4f3
     6e0:	401c053d 	andsmi	r0, ip, sp, lsr r5
     6e4:	053d1505 	ldreq	r1, [sp, #-1285]!	@ 0xfffffafb
     6e8:	0c053105 	stfeqs	f3, [r5], {5}
     6ec:	21010532 	tstcs	r1, r2, lsr r5
     6f0:	32290594 	eorcc	r0, r9, #148, 10	@ 0x25000000
     6f4:	033f0105 	teqeq	pc, #1073741825	@ 0x40000001
     6f8:	0574018a 	ldrbeq	r0, [r4, #-394]!	@ 0xfffffe76
     6fc:	4a180309 	bmi	601328 <xNumberOfSuccessfulFrees+0x5fc6ac>
     700:	18031105 	stmdane	r3, {r0, r2, r8, ip}
     704:	2e0f052e 	cfsh32cs	mvfx0, mvfx15, #30
     708:	05301105 	ldreq	r1, [r0, #-261]!	@ 0xfffffefb
     70c:	82660309 	rsbhi	r0, r6, #603979776	@ 0x24000000
     710:	f2030105 	vrhadd.s8	d0, d3, d5
     714:	15056601 	strne	r6, [r5, #-1537]	@ 0xfffff9ff
     718:	2e05053f 	mcrcs	5, 0, r0, cr5, cr15, {1}
     71c:	05220905 	streq	r0, [r2, #-2309]!	@ 0xfffff6fb
     720:	04020068 	streq	r0, [r2], #-104	@ 0xffffff98
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     724:	36059c03 	strcc	r9, [r5], -r3, lsl #24
     728:	01040200 	mrseq	r0, R12_usr
     72c:	4105053c 	tstmi	r5, ip, lsr r5
     730:	17053d3d 	smladxne	r5, sp, sp, r3
                                xYieldPendings[ xCoreID ] = pdTRUE;
     734:	053c1003 	ldreq	r1, [ip, #-3]!
     738:	01053d1f 	tsteq	r5, pc, lsl sp
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     73c:	0316083d 	tsteq	r6, #3997696	@ 0x3d0000
     740:	032e00c8 			@ <UNDEFINED> instruction: 0x032e00c8
     744:	054a02d8 	strbeq	r0, [sl, #-728]	@ 0xfffffd28
                    if( pxTCB != NULL )
     748:	07052f09 	streq	r2, [r5, -r9, lsl #30]
                        prvResetNextTaskUnblockTime();
     74c:	341e053c 	ldrcc	r0, [lr], #-1340	@ 0xfffffac4
                        TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
     750:	0a030105 	beq	c0b6c <xNumberOfSuccessfulFrees+0xbbef0>
     754:	1e20054a 	cfsh64ne	mvdx0, mvdx0, #42
                        if( xPendedCounts > ( TickType_t ) 0U )
     758:	054a1e05 	strbeq	r1, [sl, #-3589]	@ 0xfffff1fb
                                if( xTaskIncrementTick() != pdFALSE )
     75c:	09053001 	stmdbeq	r5, {r0, ip, sp}
     760:	44150589 	ldrmi	r0, [r5], #-1417	@ 0xfffffa77
     764:	05401405 	strbeq	r1, [r0, #-1029]	@ 0xfffffbfb
                                    xYieldPendings[ xCoreID ] = pdTRUE;
     768:	05052109 	streq	r2, [r5, #-265]	@ 0xfffffef7
     76c:	05741603 	ldrbeq	r1, [r4, #-1539]!	@ 0xfffff9fd
                                --xPendedCounts;
     770:	0b054b16 	bleq	1533d0 <xNumberOfSuccessfulFrees+0x14e754>
     774:	002a0532 	eoreq	r0, sl, r2, lsr r5
                            } while( xPendedCounts > ( TickType_t ) 0U );
     778:	3c010402 	cfstrscc	mvf0, [r1], {2}
                            xPendedTicks = 0;
     77c:	053f1905 	ldreq	r1, [pc, #-2309]!	@ fffffe7f <__StackTop+0xdfffde7f>
     780:	05054410 	streq	r4, [r5, #-1040]	@ 0xfffffbf0
                    if( xYieldPendings[ xCoreID ] != pdFALSE )
     784:	03010521 	movweq	r0, #5409	@ 0x1521
     788:	0582089f 	streq	r0, [r2, #2207]	@ 0x89f
     78c:	0e054110 	flteqs	f5, r4
                            xAlreadyYielded = pdTRUE;
     790:	3205052e 	andcc	r0, r5, #192937984	@ 0xb800000
                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
     794:	05860c05 	streq	r0, [r6, #3077]	@ 0xc05
     798:	05052101 	streq	r2, [r5, #-257]	@ 0xfffffeff
     79c:	05822103 	streq	r2, [r2, #259]	@ 0x103
     7a0:	1b056825 	blne	15a83c <xNumberOfSuccessfulFrees+0x155bc0>
     7a4:	2e2c0536 	mcrcs	5, 1, r0, cr12, cr6, {1}
        taskEXIT_CRITICAL();
     7a8:	05580b05 	ldrbeq	r0, [r8, #-2821]	@ 0xfffff4fb
}
     7ac:	04020048 	streq	r0, [r2], #-72	@ 0xffffffb8
     7b0:	0d052e01 	stceq	14, cr2, [r5, #-4]
     7b4:	34110540 	ldrcc	r0, [r1], #-1344	@ 0xfffffac0
     7b8:	05312505 	ldreq	r2, [r1, #-1285]!	@ 0xfffffafb
     7bc:	17052e36 	smladxne	r5, r6, lr, r2
     7c0:	31250558 			@ <UNDEFINED> instruction: 0x31250558
     7c4:	052e4805 	streq	r4, [lr, #-2053]!	@ 0xfffff7fb
     7c8:	11055b26 	tstne	r5, r6, lsr #22
     7cc:	33130535 	tstcc	r3, #222298112	@ 0xd400000
     7d0:	053f1505 	ldreq	r1, [pc, #-1285]!	@ 2d3 <prvInitialiseNewTask+0x31>
     7d4:	0f05511f 	svceq	0x0005511f
{
     7d8:	002c053f 	eoreq	r0, ip, pc, lsr r5
     7dc:	3c010402 	cfstrscc	mvf0, [r1], {2}
        xTicks = xTickCount;
     7e0:	053e1105 	ldreq	r1, [lr, #-261]!	@ 0xfffffefb
    return xTicks;
     7e4:	24058a09 	strcs	r8, [r5], #-2569	@ 0xfffff5f7
}
     7e8:	2e160531 	mrccs	5, 0, r0, cr6, cr1, {1}
     7ec:	05680f05 	strbeq	r0, [r8, #-3845]!	@ 0xfffff0fb
     7f0:	21053e13 	tstcs	r5, r3, lsl lr
{
     7f4:	2e46053e 	mcrcs	5, 2, r0, cr6, cr14, {1}
     7f8:	05782105 	ldrbeq	r2, [r8, #-261]!	@ 0xfffffefb
    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
     7fc:	46052e51 			@ <UNDEFINED> instruction: 0x46052e51
        xReturn = xTickCount;
     800:	6019052e 	andsvs	r0, r9, lr, lsr #10
    return xReturn;
     804:	052e3c05 	streq	r3, [lr, #-3077]!	@ 0xfffff3fb
}
     808:	10055a09 	andne	r5, r5, r9, lsl #20
     80c:	21050532 	tstcs	r5, r2, lsr r5
     810:	05820c03 	streq	r0, [r2, #3075]	@ 0xc03
{
     814:	1b05752e 	blne	15dcd4 <xNumberOfSuccessfulFrees+0x159058>
    return uxCurrentNumberOfTasks;
     818:	2e2a0536 	mcrcs	5, 1, r0, cr10, cr6, {1}
}
     81c:	05580b05 	ldrbeq	r0, [r8, #-2821]	@ 0xfffff4fb
     820:	0402005d 	streq	r0, [r2], #-93	@ 0xffffffa3
     824:	0d052e01 	stceq	14, cr2, [r5, #-4]
{
     828:	33110540 	tstcc	r1, #64, 10	@ 0x10000000
     82c:	05312505 	ldreq	r2, [r1, #-1285]!	@ 0xfffffafb
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     830:	17052e34 	smladxne	r5, r4, lr, r2
     834:	33250558 			@ <UNDEFINED> instruction: 0x33250558
     838:	052e3605 	streq	r3, [lr, #-1541]!	@ 0xfffff9fb
     83c:	4a05584d 	bmi	156978 <xNumberOfSuccessfulFrees+0x151cfc>
    return &( pxTCB->pcTaskName[ 0 ] );
     840:	6925052e 	stmdbvs	r5!, {r1, r2, r3, r5, r8, sl}
}
     844:	052e4805 	streq	r4, [lr, #-2053]!	@ 0xfffff7fb
     848:	11055b26 	tstne	r5, r6, lsr #22
     84c:	33130535 	tstcc	r3, #222298112	@ 0xd400000
     850:	053f1505 	ldreq	r1, [pc, #-1285]!	@ 353 <prvInitialiseNewTask+0xb1>
{
     854:	0f05511f 	svceq	0x0005511f
     858:	002c053f 	eoreq	r0, ip, pc, lsr r5
    vTaskSuspendAll();
     85c:	3c010402 	cfstrscc	mvf0, [r1], {2}
    taskENTER_CRITICAL();
     860:	053e1105 	ldreq	r1, [lr, #-261]!	@ 0xfffffefb
        xPendedTicks += xTicksToCatchUp;
     864:	0f058a09 	svceq	0x00058a09
     868:	40350532 	eorsmi	r0, r5, r2, lsr r5
     86c:	052e4605 	streq	r4, [lr, #-1541]!	@ 0xfffff9fb
    taskEXIT_CRITICAL();
     870:	1d055827 	stcne	8, cr5, [r5, #-156]	@ 0xffffff64
    xYieldOccurred = xTaskResumeAll();
     874:	2e2c0535 	mcrcs	5, 1, r0, cr12, cr5, {1}
     878:	05580f05 	ldrbeq	r0, [r8, #-3845]	@ 0xfffff0fb
}
     87c:	1d053119 	stfnes	f3, [r5, #-100]	@ 0xffffff9c
     880:	2e2e0542 	cfsh64cs	mvdx0, mvdx14, #34
     884:	05584505 	ldrbeq	r4, [r8, #-1285]	@ 0xfffffafb
{
     888:	19052e42 	stmdbne	r5, {r1, r6, r9, sl, fp, sp}
     88c:	3c053167 	stfccs	f3, [r5], {103}	@ 0x67
    BaseType_t xSwitchRequired = pdFALSE;
     890:	5a09052e 	bpl	241d50 <xNumberOfSuccessfulFrees+0x23d0d4>
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     894:	05321005 	ldreq	r1, [r2, #-5]!
     898:	0c032105 	stfeqs	f2, [r3], {5}
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     89c:	76140590 			@ <UNDEFINED> instruction: 0x76140590
     8a0:	05350f05 	ldreq	r0, [r5, #-3845]!	@ 0xfffff0fb
        xTickCount = xConstTickCount;
     8a4:	0f053009 	svceq	0x00053009
     8a8:	3e470530 	mcrcc	5, 2, r0, cr7, cr0, {1}
        if( xConstTickCount == ( TickType_t ) 0U )
     8ac:	05662f05 	strbeq	r2, [r6, #-3845]!	@ 0xfffff0fb
            taskSWITCH_DELAYED_LISTS();
     8b0:	35053123 	strcc	r3, [r5, #-291]	@ 0xfffffedd
     8b4:	680d0568 	stmdavs	sp, {r3, r5, r6, r8, sl}
     8b8:	05f52b05 	ldrbeq	r2, [r5, #2821]!	@ 0xb05
     8bc:	1505663f 	strne	r6, [r5, #-1599]	@ 0xfffff9c1
     8c0:	232d0583 			@ <UNDEFINED> instruction: 0x232d0583
     8c4:	05664205 	strbeq	r4, [r6, #-517]!	@ 0xfffffdfb
     8c8:	3f057515 	svccc	0x00057515
     8cc:	75150523 	ldrvc	r0, [r5, #-1315]	@ 0xfffffadd
     8d0:	05241705 	streq	r1, [r4, #-1797]!	@ 0xfffff8fb
        if( xConstTickCount >= xNextTaskUnblockTime )
     8d4:	15053e43 	strne	r3, [r5, #-3651]	@ 0xfffff1bd
     8d8:	1d21057c 	cfstr32ne	mvfx0, [r1, #-496]!	@ 0xfffffe10
     8dc:	03311505 	teqeq	r1, #20971520	@ 0x1400000
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     8e0:	0f05200f 	svceq	0x0005200f
     8e4:	3e110527 	cfmul64cc	mvdx0, mvdx1, mvdx7
                    xNextTaskUnblockTime = portMAX_DELAY;
     8e8:	01040200 	mrseq	r0, R12_usr
     8ec:	002e0806 	eoreq	r0, lr, r6, lsl #16
                    break;
     8f0:	4a030402 	bmi	c1900 <xNumberOfSuccessfulFrees+0xbcc84>
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     8f4:	17038306 	strne	r8, [r3, -r6, lsl #6]
     8f8:	00014102 	andeq	r4, r1, r2, lsl #2
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     8fc:	06010402 	streq	r0, [r1], -r2, lsl #8
     900:	06090574 			@ <UNDEFINED> instruction: 0x06090574
                    if( xConstTickCount < xItemValue )
     904:	32100589 	andscc	r0, r0, #574619648	@ 0x22400000
     908:	03210505 			@ <UNDEFINED> instruction: 0x03210505
                        xNextTaskUnblockTime = xItemValue;
     90c:	1405c80d 	strne	ip, [r5], #-2061	@ 0xfffff7f3
                        break;
     910:	030f0577 	movweq	r0, #62839	@ 0xf577
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
     914:	02042e1a 	andeq	r2, r4, #416	@ 0x1a0
     918:	ea030505 	b	c1d34 <xNumberOfSuccessfulFrees+0xbd0b8>
     91c:	0c052e42 	stceq	14, cr2, [r5], {66}	@ 0x42
     920:	04ba0c03 	ldrteq	r0, [sl], #3075	@ 0xc03
     924:	03320501 	teqeq	r2, #4194304	@ 0x400000
     928:	05203d8f 	streq	r3, [r0, #-3471]!	@ 0xfffff271
     92c:	4705220f 	strmi	r2, [r5, -pc, lsl #4]
     930:	662f053e 			@ <UNDEFINED> instruction: 0x662f053e
     934:	05312305 	ldreq	r2, [r1, #-773]!	@ 0xfffffcfb
     938:	0d057535 	cfstr32eq	mvfx7, [r5, #-212]	@ 0xffffff2c
     93c:	082b0568 	stmdaeq	fp!, {r3, r5, r6, r8, sl}
     940:	663f0515 			@ <UNDEFINED> instruction: 0x663f0515
     944:	05831505 	streq	r1, [r3, #1285]	@ 0x505
     948:	4205232d 	andmi	r2, r5, #-1275068416	@ 0xb4000000
     94c:	75150566 	ldrvc	r0, [r5, #-1382]	@ 0xfffffa9a
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     950:	05233f05 	streq	r3, [r3, #-3845]!	@ 0xfffff0fb
     954:	17057515 	smladne	r5, r5, r5, r7
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
     958:	4c430524 	cfstr64mi	mvdx0, [r3], {36}	@ 0x24
     95c:	057c1505 	ldrbeq	r1, [ip, #-1285]!	@ 0xfffffafb
     960:	15051d21 	strne	r1, [r5, #-3361]	@ 0xfffff2df
     964:	200e0331 	andcs	r0, lr, r1, lsr r3
     968:	05270f05 	streq	r0, [r7, #-3845]!	@ 0xfffff0fb
     96c:	13055d2a 	movwne	r5, #23850	@ 0x5d2a
     970:	3015052e 	andscc	r0, r5, lr, lsr #10
     974:	01040200 	mrseq	r0, R12_usr
     978:	002e0806 	eoreq	r0, lr, r6, lsl #16
     97c:	4a030402 	bmi	c198c <xNumberOfSuccessfulFrees+0xbcd10>
     980:	16038306 	strne	r8, [r3], -r6, lsl #6
     984:	05014202 	streq	r4, [r1, #-514]	@ 0xfffffdfe
     988:	05b1081e 	ldreq	r0, [r1, #2078]!	@ 0x81e
     98c:	17052e39 	smladxne	r5, r9, lr, r2
     990:	321b053c 	andscc	r0, fp, #60, 10	@ 0xf000000
     994:	053e3805 	ldreq	r3, [lr, #-2053]!	@ 0xfffff7fb
                    prvAddTaskToReadyList( pxTCB );
     998:	0204422d 	andeq	r4, r4, #-805306366	@ 0xd0000002
     99c:	8f030505 	svchi	0x00030505
     9a0:	01055842 	tsteq	r5, r2, asr #16
     9a4:	05010440 	streq	r0, [r1, #-1088]	@ 0xfffffbc0
     9a8:	3e8b0310 	mcrcc	3, 4, r0, cr11, cr0, {0}
     9ac:	21050520 	tstcs	r5, r0, lsr #10
     9b0:	20080a03 	andcs	r0, r8, r3, lsl #20
     9b4:	1c030f05 	stcne	15, cr0, [r3], {5}
     9b8:	05020466 	streq	r0, [r2, #-1126]	@ 0xfffffb9a
     9bc:	41b80305 			@ <UNDEFINED> instruction: 0x41b80305
     9c0:	030c052e 	movweq	r0, #50478	@ 0xc52e
     9c4:	0104ba0c 	tsteq	r4, ip, lsl #20
     9c8:	c1033205 	tstgt	r3, r5, lsl #4
     9cc:	2305203e 	movwcs	r2, #20542	@ 0x503e
     9d0:	75350522 	ldrvc	r0, [r5, #-1314]!	@ 0xfffffade
     9d4:	056a2505 	strbeq	r2, [sl, #-1285]!	@ 0xfffffafb
     9d8:	0f05663a 	svceq	0x0005663a
     9dc:	5d2a057a 	cfstr32pl	mvfx0, [sl, #-488]!	@ 0xfffffe18
     9e0:	052e1305 	streq	r1, [lr, #-773]!	@ 0xfffffcfb
     9e4:	02003015 	andeq	r3, r0, #21
     9e8:	08060104 	stmdaeq	r6, {r2, r8}
     9ec:	0402002e 	streq	r0, [r2], #-46	@ 0xffffffd2
     9f0:	83064a03 	movwhi	r4, #27139	@ 0x6a03
     9f4:	42021603 	andmi	r1, r2, #3145728	@ 0x300000
     9f8:	081e0501 	ldmdaeq	lr, {r0, r8, sl}
     9fc:	2e3905b1 	mrccs	5, 1, r0, cr9, cr1, {5}
     a00:	053c1705 	ldreq	r1, [ip, #-1797]!	@ 0xfffff8fb
     a04:	3805321b 	stmdacc	r5, {r0, r1, r3, r4, r9, ip, sp}
     a08:	422d053e 	eormi	r0, sp, #260046848	@ 0xf800000
     a0c:	05050204 	streq	r0, [r5, #-516]	@ 0xfffffdfc
     a10:	58418903 	stmdapl	r1, {r0, r1, r8, fp, pc}^
     a14:	04400105 	strbeq	r0, [r0], #-261	@ 0xfffffefb
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     a18:	03050501 	movweq	r0, #21761	@ 0x5501
     a1c:	03203f90 			@ <UNDEFINED> instruction: 0x03203f90
     a20:	05200809 	streq	r0, [r0, #-2057]!	@ 0xfffff7f7
     a24:	580a0311 	stmdapl	sl, {r0, r4, r8, r9}
                                xSwitchRequired = pdTRUE;
     a28:	01040200 	mrseq	r0, R12_usr
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     a2c:	02003c06 	andeq	r3, r0, #1536	@ 0x600
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > 1U )
     a30:	053c0204 	ldreq	r0, [ip, #-516]!	@ 0xfffffdfc
     a34:	0402000f 	streq	r0, [r2], #-15
     a38:	05200604 	streq	r0, [r0, #-1540]!	@ 0xfffff9fc
     a3c:	25052309 	strcs	r2, [r5, #-777]	@ 0xfffffcf7
     a40:	660f0530 			@ <UNDEFINED> instruction: 0x660f0530
     a44:	05303805 	ldreq	r3, [r0, #-2053]!	@ 0xfffff7fb
                    xSwitchRequired = pdTRUE;
     a48:	05406719 	strbeq	r6, [r0, #-1817]	@ 0xfffff8e7
                if( xYieldPendings[ 0 ] != pdFALSE )
     a4c:	10053109 	andne	r3, r5, r9, lsl #2
     a50:	21050532 	tstcs	r5, r2, lsr r5
                    xSwitchRequired = pdTRUE;
     a54:	05740a03 	ldrbeq	r0, [r4, #-2563]!	@ 0xfffff5fd
        xPendedTicks += 1U;
     a58:	660a0311 			@ <UNDEFINED> instruction: 0x660a0311
     a5c:	01040200 	mrseq	r0, R12_usr
     a60:	02003c06 	andeq	r3, r0, #1536	@ 0x600
}
     a64:	053c0204 	ldreq	r0, [ip, #-516]!	@ 0xfffffdfc
     a68:	0402000f 	streq	r0, [r2], #-15
     a6c:	05200604 	streq	r0, [r0, #-1540]!	@ 0xfffff9fc
     a70:	16052309 	strne	r2, [r5], -r9, lsl #6
     a74:	75230532 	strvc	r0, [r3, #-1330]!	@ 0xffffface
     a78:	05663905 	strbeq	r3, [r6, #-2309]!	@ 0xfffff6fb
     a7c:	09052e36 	stmdbeq	r5, {r1, r2, r4, r5, r9, sl, fp, sp}
     a80:	32100576 	andscc	r0, r0, #494927872	@ 0x1d800000
     a84:	05210505 	streq	r0, [r1, #-1285]!	@ 0xfffffafb
     a88:	01ad0301 			@ <UNDEFINED> instruction: 0x01ad0301
     a8c:	5a160574 	bpl	582064 <xNumberOfSuccessfulFrees+0x57d3e8>
     a90:	3d3d1405 	cfldrscc	mvf1, [sp, #-20]!	@ 0xffffffec
     a94:	0d032605 	stceq	6, cr2, [r3, #-20]	@ 0xffffffec
    {
     a98:	2e09053c 	mcrcs	5, 0, r0, cr9, cr12, {1}
     a9c:	02000705 	andeq	r0, r0, #1310720	@ 0x140000
        if( uxSchedulerSuspended != ( UBaseType_t ) 0U )
     aa0:	05580104 	ldrbeq	r0, [r8, #-260]	@ 0xfffffefc
     aa4:	15053209 	strne	r3, [r5, #-521]	@ 0xfffffdf7
            xYieldPendings[ 0 ] = pdTRUE;
     aa8:	05ba3b03 	ldreq	r3, [sl, #2819]!	@ 0xb03
    }
     aac:	0b054d09 	bleq	153ed8 <xNumberOfSuccessfulFrees+0x14f25c>
            xYieldPendings[ 0 ] = pdFALSE;
     ab0:	4e40054c 	cdpmi	5, 4, cr0, cr0, cr12, {2}
            taskSELECT_HIGHEST_PRIORITY_TASK();
     ab4:	052e0d05 	streq	r0, [lr, #-3333]!	@ 0xfffff2fb
     ab8:	58190301 	ldmdapl	r9, {r0, r8, r9}
        __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
     abc:	6d033805 	stcvs	8, cr3, [r3, #-20]	@ 0xffffffec
     ac0:	2e0d0520 	cfsh32cs	mvfx0, mvfx13, #16
     ac4:	055d1d05 	ldrbeq	r1, [sp, #-3333]	@ 0xfffff2fb
     ac8:	26052e0f 	strcs	r2, [r5], -pc, lsl #28
     acc:	0301053e 	movweq	r0, #5438	@ 0x153e
     ad0:	f4033c0c 			@ <UNDEFINED> instruction: 0xf4033c0c
     ad4:	1605f200 	strne	pc, [r5], -r0, lsl #4
     ad8:	031c0542 	tsteq	ip, #276824064	@ 0x10800000
     adc:	10053c11 	andne	r3, r5, r1, lsl ip
     ae0:	3d18053d 	cfldr32cc	mvfx0, [r8, #-244]	@ 0xffffff0c
     ae4:	053d1705 	ldreq	r1, [sp, #-1797]!	@ 0xfffff8fb
     ae8:	053e3d12 	ldreq	r3, [lr, #-3346]!	@ 0xfffff2ee
     aec:	23052e05 	movwcs	r2, #24069	@ 0x5e05
     af0:	003f0522 	eorseq	r0, pc, r2, lsr #10
     af4:	56030402 	strpl	r0, [r3], -r2, lsl #8
     af8:	02001f05 	andeq	r1, r0, #5, 30
     afc:	053c0104 	ldreq	r0, [ip, #-260]!	@ 0xfffffefc
     b00:	12054115 	andne	r4, r5, #1073741829	@ 0x40000005
            portTASK_SWITCH_HOOK( pxCurrentTCB );
     b04:	3d1a053d 	cfldr32cc	mvfx0, [sl, #-244]	@ 0xffffff0c
    }
     b08:	0301053e 	movweq	r0, #5438	@ 0x153e
     b0c:	1b023c0b 	blne	8fb40 <xNumberOfSuccessfulFrees+0x8aec4>
     b10:	ac010100 	stfges	f0, [r1], {-0}
     b14:	03000001 	movweq	r0, #1
     b18:	0000c200 	andeq	ip, r0, r0, lsl #4
     b1c:	fb010200 	blx	41326 <xNumberOfSuccessfulFrees+0x3c6aa>
     b20:	01000d0e 	tsteq	r0, lr, lsl #26
{
     b24:	00010101 	andeq	r0, r1, r1, lsl #2
     b28:	00010000 	andeq	r0, r1, r0
     b2c:	2e2e0100 	sufcse	f0, f6, f0
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     b30:	6572462f 	ldrbvs	r4, [r2, #-1583]!	@ 0xfffff9d1
     b34:	4f545265 	svcmi	0x00545265
     b38:	654b2d53 	strbvs	r2, [fp, #-3411]	@ 0xfffff2ad
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b3c:	6c656e72 	stclvs	14, cr6, [r5], #-456	@ 0xfffffe38
     b40:	73752f00 	cmnvc	r5, #0, 30
}
     b44:	696c2f72 	stmdbvs	ip!, {r1, r4, r5, r6, r8, r9, sl, fp, sp}^
     b48:	63672f62 	cmnvs	r7, #392	@ 0x188
     b4c:	72612f63 	rsbvc	r2, r1, #396	@ 0x18c
{
     b50:	6f6e2d6d 	svcvs	0x006e2d6d
     b54:	652d656e 	strvs	r6, [sp, #-1390]!	@ 0xfffffa92
     b58:	2f696261 	svccs	0x00696261
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     b5c:	322e3331 	eorcc	r3, lr, #-1006632960	@ 0xc4000000
     b60:	692f312e 	stmdbvs	pc!, {r1, r2, r3, r5, r8, ip, sp}	@ <UNPREDICTABLE>
     b64:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     b68:	2e006564 	cfsh32cs	mvfx6, mvfx0, #52
     b6c:	72462f2e 	subvc	r2, r6, #46, 30	@ 0xb8
     b70:	54526565 	ldrbpl	r6, [r2], #-1381	@ 0xfffffa9b
     b74:	4b2d534f 	blmi	b558b8 <xNumberOfSuccessfulFrees+0xb50c3c>
     b78:	656e7265 	strbvs	r7, [lr, #-613]!	@ 0xfffffd9b
     b7c:	6f702f6c 	svcvs	0x00702f6c
     b80:	62617472 	rsbvs	r7, r1, #1912602624	@ 0x72000000
     b84:	472f656c 	strmi	r6, [pc, -ip, ror #10]!
     b88:	412f4343 			@ <UNDEFINED> instruction: 0x412f4343
     b8c:	435f4d52 	cmpmi	pc, #5248	@ 0x1480
     b90:	2e00334d 	cdpcs	3, 0, cr3, cr0, cr13, {2}
     b94:	72462f2e 	subvc	r2, r6, #46, 30	@ 0xb8
     b98:	54526565 	ldrbpl	r6, [r2], #-1381	@ 0xfffffa9b
     b9c:	4b2d534f 	blmi	b558e0 <xNumberOfSuccessfulFrees+0xb50c64>
     ba0:	656e7265 	strbvs	r7, [lr, #-613]!	@ 0xfffffd9b
     ba4:	6e692f6c 	cdpvs	15, 6, cr2, cr9, cr12, {3}
     ba8:	64756c63 	ldrbtvs	r6, [r5], #-3171	@ 0xfffff39d
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     bac:	6c000065 	stcvs	0, cr0, [r0], {101}	@ 0x65
     bb0:	2e747369 	cdpcs	3, 7, cr7, cr4, cr9, {3}
}
     bb4:	00010063 	andeq	r0, r1, r3, rrx
     bb8:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
     bbc:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
{
     bc0:	00020068 	andeq	r0, r2, r8, rrx
     bc4:	726f7000 	rsbvc	r7, pc, #0
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     bc8:	63616d74 	cmnvs	r1, #116, 26	@ 0x1d00
     bcc:	682e6f72 	stmdavs	lr!, {r1, r4, r5, r6, r8, r9, sl, fp, sp, lr}
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
     bd0:	00000300 	andeq	r0, r0, r0, lsl #6
     bd4:	7473696c 	ldrbtvc	r6, [r3], #-2412	@ 0xfffff694
     bd8:	0400682e 	streq	r6, [r0], #-2094	@ 0xfffff7d2
     bdc:	05000000 	streq	r0, [r0, #-0]
     be0:	02050001 	andeq	r0, r5, #1
     be4:	00001ad0 	ldrdeq	r1, [r0], -r0
     be8:	05013103 	streq	r3, [r1, #-259]	@ 0xfffffefd
     bec:	15055028 	strne	r5, [r5, #-40]	@ 0xffffffd8
     bf0:	3421053c 	strtcc	r0, [r1], #-1340	@ 0xfffffac4
     bf4:	054e3005 	strbeq	r3, [lr, #-5]
     bf8:	34053c1d 	strcc	r3, [r5], #-3101	@ 0xfffff3e3
     bfc:	3c21052f 	cfstr32cc	mvfx0, [r1], #-188	@ 0xffffff44
     c00:	0b031d05 	bleq	c801c <xNumberOfSuccessfulFrees+0xc33a0>
     c04:	4401052e 	strmi	r0, [r1], #-1326	@ 0xfffffad2
     c08:	4e19055c 	mrcmi	5, 0, r0, cr9, cr12, {2}
     c0c:	5d440105 	stfple	f0, [r4, #-20]	@ 0xffffffec
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     c10:	05591805 	ldrbeq	r1, [r9, #-2053]	@ 0xfffff7fb
     c14:	3c0d031b 	stccc	3, cr0, [sp], {27}
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
     c18:	053d2805 	ldreq	r2, [sp, #-2053]!	@ 0xfffff7fb
     c1c:	0c052e1f 	stceq	14, cr2, [r5], {31}
     c20:	2e210533 	mcrcs	5, 1, r0, cr1, cr3, {1}
     c24:	052f1905 	streq	r1, [pc, #-2309]!	@ 327 <prvInitialiseNewTask+0x85>
     c28:	3b053f20 	blcc	1508b0 <xNumberOfSuccessfulFrees+0x14bc34>
     c2c:	2e23053e 	mcrcs	5, 1, r0, cr3, cr14, {1}
     c30:	05202105 	streq	r2, [r0, #-261]!	@ 0xfffffefb
     c34:	055d3101 	ldrbeq	r3, [sp, #-257]	@ 0xfffffeff
     c38:	07055a16 	smladeq	r5, r6, sl, r5
     c3c:	053c1203 	ldreq	r1, [ip, #-515]!	@ 0xfffffdfd
     c40:	19054c14 	stmdbne	r5, {r2, r4, sl, fp, lr}
     c44:	054a1d03 	strbeq	r1, [sl, #-3331]	@ 0xfffff2fd
     c48:	83053c09 	movwhi	r3, #23561	@ 0x5c09
     c4c:	04020001 	streq	r0, [r2], #-1
     c50:	4d052003 	stcmi	0, cr2, [r5, #-12]
        prvAddTaskToReadyList( pxUnblockedTCB );
     c54:	01040200 	mrseq	r0, R12_usr
     c58:	0055053c 	subseq	r0, r5, ip, lsr r5
     c5c:	2e010402 	cdpcs	4, 0, cr0, cr1, cr2, {0}
     c60:	02006205 	andeq	r6, r0, #1342177280	@ 0x50000000
     c64:	05200104 	streq	r0, [r0, #-260]!	@ 0xfffffefc
     c68:	3c090327 	stccc	3, cr0, [r9], {39}	@ 0x27
     c6c:	052e1b05 	streq	r1, [lr, #-2821]!	@ 0xfffff4fb
     c70:	27052f12 	smladcs	r5, r2, pc, r2	@ <UNPREDICTABLE>
     c74:	2f1f052e 	svccs	0x001f052e
     c78:	053d1805 	ldreq	r1, [sp, #-2053]!	@ 0xfffff7fb
     c7c:	3b054020 	blcc	150d04 <xNumberOfSuccessfulFrees+0x14c088>
     c80:	2e23053e 	mcrcs	5, 1, r0, cr3, cr14, {1}
     c84:	05202105 	streq	r2, [r0, #-261]!	@ 0xfffffefb
     c88:	055d3101 	ldrbeq	r3, [sp, #-257]	@ 0xfffffeff
     c8c:	13054d14 	movwne	r4, #23828	@ 0x5d14
     c90:	2e380540 	cfneg32cs	mvfx0, mvfx8
     c94:	052e2805 	streq	r2, [lr, #-2053]!	@ 0xfffff7fb
     c98:	38052113 	stmdacc	r5, {r0, r1, r4, r8, sp}
     c9c:	2e28052e 	cfsh64cs	mvdx0, mvdx8, #30
     ca0:	05260f05 	streq	r0, [r6, #-3845]!	@ 0xfffff0fb
     ca4:	29052e07 	stmdbcs	r5, {r0, r1, r2, r9, sl, fp, sp}
     ca8:	2e19053e 	mrccs	5, 0, r0, cr9, cr14, {1}
     cac:	05352105 	ldreq	r2, [r5, #-261]!	@ 0xfffffefb
     cb0:	23053d3b 	movwcs	r3, #23867	@ 0x5d3b
     cb4:	2021052e 	eorcs	r0, r1, lr, lsr #10
     cb8:	05321205 	ldreq	r1, [r2, #-517]!	@ 0xfffffdfb
     cbc:	05022f01 	streq	r2, [r2, #-3841]	@ 0xfffff0ff
     cc0:	ac010100 	stfges	f0, [r1], {-0}
     cc4:	03000003 	movweq	r0, #3
     cc8:	00010f00 	andeq	r0, r1, r0, lsl #30
     ccc:	fb010200 	blx	414d6 <xNumberOfSuccessfulFrees+0x3c85a>
     cd0:	01000d0e 	tsteq	r0, lr, lsl #26
     cd4:	00010101 	andeq	r0, r1, r1, lsl #2
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     cd8:	00010000 	andeq	r0, r1, r0
     cdc:	2e2e0100 	sufcse	f0, f6, f0
     ce0:	6572462f 	ldrbvs	r4, [r2, #-1583]!	@ 0xfffff9d1
     ce4:	4f545265 	svcmi	0x00545265
     ce8:	654b2d53 	strbvs	r2, [fp, #-3411]	@ 0xfffff2ad
     cec:	6c656e72 	stclvs	14, cr6, [r5], #-456	@ 0xfffffe38
     cf0:	726f702f 	rsbvc	r7, pc, #47	@ 0x2f
     cf4:	6c626174 	stfvse	f6, [r2], #-464	@ 0xfffffe30
     cf8:	654d2f65 	strbvs	r2, [sp, #-3941]	@ 0xfffff09b
     cfc:	6e614d6d 	cdpvs	13, 6, cr4, cr1, cr13, {3}
     d00:	752f0067 	strvc	r0, [pc, #-103]!	@ ca1 <xTaskRemoveFromEventList+0xe1>
     d04:	6c2f7273 	sfmvs	f7, 4, [pc], #-460	@ b40 <vTaskPlaceOnEventList+0x1c>
     d08:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
     d0c:	612f6363 			@ <UNDEFINED> instruction: 0x612f6363
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     d10:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
     d14:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
     d18:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
     d1c:	2e33312f 	rsfcssp	f3, f3, #10.0
            xReturn = pdTRUE;
     d20:	2f312e32 	svccs	0x00312e32
            xYieldPendings[ 0 ] = pdTRUE;
     d24:	6c636e69 	stclvs	14, cr6, [r3], #-420	@ 0xfffffe5c
     d28:	00656475 	rsbeq	r6, r5, r5, ror r4
            xReturn = pdFALSE;
     d2c:	462f2e2e 	strtmi	r2, [pc], -lr, lsr #28
}
     d30:	52656572 	rsbpl	r6, r5, #478150656	@ 0x1c800000
     d34:	2d534f54 	ldclcs	15, cr4, [r3, #-336]	@ 0xfffffeb0
     d38:	6e72654b 	cdpvs	5, 7, cr6, cr2, cr11, {2}
     d3c:	702f6c65 	eorvc	r6, pc, r5, ror #24
     d40:	6174726f 	cmnvs	r4, pc, ror #4
     d44:	2f656c62 	svccs	0x00656c62
     d48:	2f434347 	svccs	0x00434347
     d4c:	5f4d5241 	svcpl	0x004d5241
     d50:	00334d43 	eorseq	r4, r3, r3, asr #26
{
     d54:	462f2e2e 	strtmi	r2, [pc], -lr, lsr #28
     d58:	52656572 	rsbpl	r6, r5, #478150656	@ 0x1c800000
     d5c:	2d534f54 	ldclcs	15, cr4, [r3, #-336]	@ 0xfffffeb0
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     d60:	6e72654b 	cdpvs	5, 7, cr6, cr2, cr11, {2}
     d64:	692f6c65 	stmdbvs	pc!, {r0, r2, r5, r6, sl, fp, sp, lr}	@ <UNPREDICTABLE>
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem );
     d68:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
     d6c:	2f006564 	svccs	0x00006564
    listREMOVE_ITEM( pxEventListItem );
     d70:	2f727375 	svccs	0x00727375
     d74:	6c636e69 	stclvs	14, cr6, [r3], #-420	@ 0xfffffe5c
     d78:	2f656475 	svccs	0x00656475
     d7c:	6c77656e 	cfldr64vs	mvdx6, [r7], #-440	@ 0xfffffe48
     d80:	00006269 	andeq	r6, r0, r9, ror #4
     d84:	70616568 	rsbvc	r6, r1, r8, ror #10
     d88:	632e345f 			@ <UNDEFINED> instruction: 0x632e345f
     d8c:	00000100 	andeq	r0, r0, r0, lsl #2
     d90:	64647473 	strbtvs	r7, [r4], #-1139	@ 0xfffffb8d
     d94:	682e6665 	stmdavs	lr!, {r0, r2, r5, r6, r9, sl, sp, lr}
     d98:	00000200 	andeq	r0, r0, r0, lsl #4
     d9c:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
     da0:	682e746e 	stmdavs	lr!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}
     da4:	00000200 	andeq	r0, r0, r0, lsl #4
     da8:	74726f70 	ldrbtvc	r6, [r2], #-3952	@ 0xfffff090
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
     dac:	7263616d 	rsbvc	r6, r3, #1073741851	@ 0x4000001b
     db0:	00682e6f 	rsbeq	r2, r8, pc, ror #28
     db4:	70000003 	andvc	r0, r0, r3
     db8:	6174726f 	cmnvs	r4, pc, ror #4
     dbc:	2e656c62 	cdpcs	12, 6, cr6, cr5, cr2, {3}
     dc0:	00040068 	andeq	r0, r4, r8, rrx
     dc4:	73617400 	cmnvc	r1, #0, 8
     dc8:	00682e6b 	rsbeq	r2, r8, fp, ror #28
     dcc:	73000004 	movwvc	r0, #4
     dd0:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
     dd4:	00682e67 	rsbeq	r2, r8, r7, ror #28
     dd8:	00000005 	andeq	r0, r0, r5
     ddc:	05000105 	streq	r0, [r0, #-261]	@ 0xfffffefb
     de0:	001c3002 	andseq	r3, ip, r2
     de4:	01ad0300 			@ <UNDEFINED> instruction: 0x01ad0300
    prvAddTaskToReadyList( pxUnblockedTCB );
     de8:	4e0c0501 	cfsh32mi	mvfx0, mvfx12, #1
     dec:	30070530 	andcc	r0, r7, r0, lsr r5
     df0:	05400d05 	strbeq	r0, [r0, #-3333]	@ 0xfffff2fb
     df4:	19052e0b 	stmdbne	r5, {r0, r1, r3, r9, sl, fp, sp}
     df8:	4e1f053e 	mrcmi	5, 0, r0, cr15, cr14, {1}
     dfc:	053c0f05 	ldreq	r0, [ip, #-3845]!	@ 0xfffff0fb
     e00:	2905314e 	stmdbcs	r5, {r1, r2, r3, r6, r8, ip, sp}
     e04:	3e15053c 	mrccc	5, 0, r0, cr5, cr12, {1}
     e08:	052e1305 	streq	r1, [lr, #-773]!	@ 0xfffffcfb
     e0c:	055c3e21 	ldrbeq	r3, [ip, #-3617]	@ 0xfffff1df
     e10:	3c0a0319 	stccc	3, cr0, [sl], {25}
     e14:	05360505 	ldreq	r0, [r6, #-1285]!	@ 0xfffffafb
     e18:	0b053213 	bleq	14d66c <xNumberOfSuccessfulFrees+0x1489f0>
     e1c:	300d052e 	andcc	r0, sp, lr, lsr #10
     e20:	052e0b03 	streq	r0, [lr, #-2819]!	@ 0xfffff4fd
     e24:	0f05200b 	svceq	0x0005200b
     e28:	00360530 	eorseq	r0, r6, r0, lsr r5
     e2c:	3c010402 	cfstrscc	mvf0, [r1], {2}
     e30:	02002505 	andeq	r2, r0, #20971520	@ 0x1400000
     e34:	052e0104 	streq	r0, [lr, #-260]!	@ 0xfffffefc
     e38:	19054021 	stmdbne	r5, {r0, r5, lr}
     e3c:	3f16052f 	svccc	0x0016052f
     e40:	05222505 	streq	r2, [r2, #-1285]!	@ 0xfffffafb
     e44:	21052f1d 	tstcs	r5, sp, lsl pc
     e48:	2e3e0539 	mrccs	5, 1, r0, cr14, cr9, {1}
     e4c:	02004a05 	andeq	r4, r0, #20480	@ 0x5000
     e50:	053c0104 	ldreq	r0, [ip, #-260]!	@ 0xfffffefc
     e54:	0402003e 	streq	r0, [r2], #-62	@ 0xffffffc2
     e58:	1d052e01 	stcne	14, cr2, [r5, #-4]
     e5c:	052e0903 	streq	r0, [lr, #-2307]!	@ 0xfffff6fd
     e60:	3d052e13 	stccc	14, cr2, [r5, #-76]	@ 0xffffffb4
     e64:	2e200540 	cfsh64cs	mvdx0, mvdx0, #32
     e68:	05201e05 	streq	r1, [r0, #-3589]!	@ 0xfffff1fb
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     e6c:	3605333f 			@ <UNDEFINED> instruction: 0x3605333f
     e70:	3422052e 	strtcc	r0, [r2], #-1326	@ 0xfffffad2
     e74:	052e2f05 	streq	r2, [lr, #-3845]!	@ 0xfffff0fb
            xYieldPendings[ 0 ] = pdTRUE;
     e78:	17052e41 	strne	r2, [r5, -r1, asr #28]
     e7c:	3428052e 	strtcc	r0, [r8], #-1326	@ 0xfffffad2
}
     e80:	054f3d05 	strbeq	r3, [pc, #-3333]	@ 183 <vector_table+0x183>
     e84:	34052e4a 	strcc	r2, [r5], #-3658	@ 0xfffff1b6
     e88:	2f2d052e 	svccs	0x002d052e
     e8c:	053f4a05 	ldreq	r4, [pc, #-2565]!	@ 48f <prvAddNewTaskToReadyList+0x123>
     e90:	3a052e39 	bcc	14c77c <xNumberOfSuccessfulFrees+0x147b00>
     e94:	4329052f 			@ <UNDEFINED> instruction: 0x4329052f
{
     e98:	052e3305 	streq	r3, [lr, #-773]!	@ 0xfffffcfb
     e9c:	2d052e29 	stccs	14, cr2, [r5, #-164]	@ 0xffffff5c
    taskENTER_CRITICAL();
     ea0:	4a17053e 	bmi	5c23a0 <xNumberOfSuccessfulFrees+0x5bd724>
        pxTimeOut->xOverflowCount = xNumOfOverflows;
     ea4:	05303805 	ldreq	r3, [r0, #-2053]!	@ 0xfffff7fb
     ea8:	15055129 	strne	r5, [r5, #-297]	@ 0xfffffed7
        pxTimeOut->xTimeOnEntering = xTickCount;
     eac:	672e0540 	strvs	r0, [lr, -r0, asr #10]!
     eb0:	053d3305 	ldreq	r3, [sp, #-773]!	@ 0xfffffcfb
    taskEXIT_CRITICAL();
     eb4:	5816030e 	ldmdapl	r6, {r1, r2, r3, r8, r9}
}
     eb8:	10030c05 	andne	r0, r3, r5, lsl #24
     ebc:	2101052e 	tstcs	r1, lr, lsr #10
     ec0:	4b0f05da 	blmi	3c2630 <xNumberOfSuccessfulFrees+0x3bd9b4>
     ec4:	05310705 	ldreq	r0, [r1, #-1797]!	@ 0xfffff8fb
{
     ec8:	1005400d 	andne	r4, r5, sp
     ecc:	340d055b 	strcc	r0, [sp], #-1371	@ 0xfffffaa5
    pxTimeOut->xOverflowCount = xNumOfOverflows;
     ed0:	052e0b05 	streq	r0, [lr, #-2821]!	@ 0xfffff4fb
     ed4:	0f053017 	svceq	0x00053017
    pxTimeOut->xTimeOnEntering = xTickCount;
     ed8:	3211052e 	andscc	r0, r1, #192937984	@ 0xb800000
     edc:	05660c03 	strbeq	r0, [r6, #-3075]!	@ 0xfffff3fd
}
     ee0:	29053132 	stmdbcs	r5, {r1, r4, r5, r8, ip, sp}
     ee4:	5a15052e 	bpl	5423a4 <xNumberOfSuccessfulFrees+0x53d728>
     ee8:	053d2d05 	ldreq	r2, [sp, #-3333]!	@ 0xfffff2fb
     eec:	01055a1a 	tsteq	r5, sl, lsl sl
     ef0:	942e0c03 	strtls	r0, [lr], #-3075	@ 0xfffff3fd
{
     ef4:	052f0c05 	streq	r0, [pc, #-3077]!	@ 2f7 <prvInitialiseNewTask+0x55>
     ef8:	056a2f01 	strbeq	r2, [sl, #-3841]!	@ 0xfffff0ff
     efc:	01052f0c 	tsteq	r5, ip, lsl #30
    taskENTER_CRITICAL();
     f00:	24056a2f 	strcs	r6, [r5], #-2607	@ 0xfffff5d1
        const TickType_t xConstTickCount = xTickCount;
     f04:	4b01052f 	blmi	423c8 <xNumberOfSuccessfulFrees+0x3d74c>
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     f08:	054f3086 	strbeq	r3, [pc, #-134]	@ e8a <vTaskRemoveFromUnorderedEventList+0x136>
     f0c:	0905590c 	stmdbeq	r5, {r2, r3, r8, fp, ip, lr}
     f10:	04020030 	streq	r0, [r2], #-48	@ 0xffffffd0
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) )
     f14:	003c0601 	eorseq	r0, ip, r1, lsl #12
     f18:	82030402 	andhi	r0, r3, #33554432	@ 0x2000000
     f1c:	04020020 	streq	r0, [r2], #-32	@ 0xffffffe0
     f20:	07052004 	streq	r2, [r5, -r4]
     f24:	06040200 	streq	r0, [r4], -r0, lsl #4
            xReturn = pdTRUE;
     f28:	0e052006 	cdpeq	0, 0, cr2, cr5, cr6, {0}
            *pxTicksToWait = ( TickType_t ) 0;
     f2c:	840b0530 	strhi	r0, [fp], #-1328	@ 0xfffffad0
     f30:	053e1605 	ldreq	r1, [lr, #-1541]!	@ 0xfffff9fb
        else if( xElapsedTime < *pxTicksToWait )
     f34:	0105940c 	tsteq	r5, ip, lsl #8
     f38:	0c054e21 	stceq	14, cr4, [r5], {33}	@ 0x21
     f3c:	3f14053f 	svccc	0x0014053f
            *pxTicksToWait -= xElapsedTime;
     f40:	05301a05 	ldreq	r1, [r0, #-2565]!	@ 0xfffff5fb
     f44:	18053c07 	stmdane	r5, {r0, r1, r2, sl, fp, ip, sp}
     f48:	054b3d30 	strbeq	r3, [fp, #-3376]	@ 0xfffff2d0
            vTaskInternalSetTimeOutState( pxTimeOut );
     f4c:	660b031e 			@ <UNDEFINED> instruction: 0x660b031e
            xReturn = pdFALSE;
     f50:	05201c05 	streq	r1, [r0, #-3077]!	@ 0xfffff3fb
     f54:	12052f17 	andne	r2, r5, #23, 30	@ 0x5c
            *pxTicksToWait = ( TickType_t ) 0;
     f58:	4b150540 	blmi	542460 <xNumberOfSuccessfulFrees+0x53d7e4>
            xReturn = pdTRUE;
     f5c:	3d201205 	sfmcc	f1, 4, [r0, #-20]!	@ 0xffffffec
    taskEXIT_CRITICAL();
     f60:	054b0d05 	strbeq	r0, [fp, #-3333]	@ 0xfffff2fb
    return xReturn;
     f64:	0a05200b 	beq	148f98 <xNumberOfSuccessfulFrees+0x14431c>
}
     f68:	2e17052f 	cfmul64cs	mvdx0, mvdx7, mvdx15
     f6c:	052f0a05 	streq	r0, [pc, #-2565]!	@ 56f <vTaskStartScheduler+0x2f>
     f70:	16052e1c 			@ <UNDEFINED> instruction: 0x16052e1c
     f74:	2f400532 	svccs	0x00400532
{
     f78:	05203e05 	streq	r3, [r0, #-3589]!	@ 0xfffff1fb
    xYieldPendings[ portGET_CORE_ID() ] = pdTRUE;
     f7c:	27052e22 	strcs	r2, [r5, -r2, lsr #28]
     f80:	4d36052f 	cfldr32mi	mvfx0, [r6, #-188]!	@ 0xffffff44
}
     f84:	052e2405 	streq	r2, [lr, #-1029]!	@ 0xfffffbfb
     f88:	19052f2b 	stmdbne	r5, {r0, r1, r3, r5, r8, r9, sl, fp, sp}
     f8c:	2f01052e 	svccs	0x0001052e
{
     f90:	501505f6 			@ <UNDEFINED> instruction: 0x501505f6
     f94:	052e0505 	streq	r0, [lr, #-1285]!	@ 0xfffffafb
        prvCheckTasksWaitingTermination();
     f98:	04020077 	streq	r0, [r2], #-119	@ 0xffffff89
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) configNUMBER_OF_CORES )
     f9c:	20052003 	andcs	r2, r5, r3
     fa0:	01040200 	mrseq	r0, R12_usr
                taskYIELD();
     fa4:	0059053c 	subseq	r0, r9, ip, lsr r5
     fa8:	2e010402 	cdpcs	4, 0, cr0, cr1, cr2, {0}
     fac:	0c030905 			@ <UNDEFINED> instruction: 0x0c030905
     fb0:	301b053c 	andscc	r0, fp, ip, lsr r5
        prvCheckTasksWaitingTermination();
     fb4:	052e0f05 	streq	r0, [lr, #-3845]!	@ 0xfffff0fb
     fb8:	13052e07 	movwne	r2, #24071	@ 0x5e07
     fbc:	2e32053e 	mrccs	5, 1, r0, cr2, cr14, {1}
{
     fc0:	052e2005 	streq	r2, [lr, #-5]!
     fc4:	09053d19 	stmdbeq	r5, {r0, r3, r4, r8, sl, fp, ip, sp}
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
     fc8:	052e0903 	streq	r0, [lr, #-2307]!	@ 0xfffff6fd
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     fcc:	0f053020 	svceq	0x00053020
     fd0:	2e40052e 	cdpcs	5, 4, cr0, cr0, cr14, {1}
     fd4:	052e0705 	streq	r0, [lr, #-1797]!	@ 0xfffff8fb
     fd8:	4605300d 	strmi	r3, [r5], -sp
     fdc:	2e0b052e 	cfsh32cs	mvfx0, mvfx11, #30
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
     fe0:	05311c05 	ldreq	r1, [r1, #-3077]!	@ 0xfffff3fb
     fe4:	64052e2c 	strvs	r2, [r5], #-3628	@ 0xfffff1d4
     fe8:	2029052e 	eorcs	r0, r9, lr, lsr #10
    vListInitialise( &xDelayedTaskList1 );
     fec:	053d3005 	ldreq	r3, [sp, #-5]!
     ff0:	2e052e68 	cdpcs	14, 0, cr2, cr5, cr8, {3}
    vListInitialise( &xDelayedTaskList2 );
     ff4:	36054020 	strcc	r4, [r5], -r0, lsr #32
    vListInitialise( &xPendingReadyList );
     ff8:	2e2a055d 	mcrcs	5, 1, r0, cr10, cr13, {2}
     ffc:	05350705 	ldreq	r0, [r5, #-1797]!	@ 0xfffff8fb
    pxDelayedTaskList = &xDelayedTaskList1;
    1000:	01054c25 	tsteq	r5, r5, lsr #24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1004:	0c059442 	cfstrseq	mvf9, [r5], {66}	@ 0x42
    1008:	2e19054c 	cfmac32cs	mvfx0, mvfx9, mvfx12
}
    100c:	052e2705 	streq	r2, [lr, #-1797]!	@ 0xfffff8fb
    1010:	11053e05 	tstne	r5, r5, lsl #28
    1014:	400b0530 	andmi	r0, fp, r0, lsr r5
    1018:	053e1205 	ldreq	r1, [lr, #-517]!	@ 0xfffffdfb
    101c:	1c052418 	cfstrsne	mvf2, [r5], {24}
    1020:	2e13053e 	mrccs	5, 0, r0, cr3, cr14, {1}
    1024:	053e1e05 	ldreq	r1, [lr, #-3589]!	@ 0xfffff1fb
    1028:	13053f1c 	movwne	r3, #24348	@ 0x5f1c
{
    102c:	3e1e052e 	cfmul64cc	mvdx0, mvdx14, mvdx14
}
    1030:	05411905 	strbeq	r1, [r1, #-2309]	@ 0xfffff6fb
    1034:	3c6e031c 	stclcc	3, cr0, [lr], #-112	@ 0xffffff90
{
    1038:	16030e05 	strne	r0, [r3], -r5, lsl #28
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    103c:	30310558 	eorscc	r0, r1, r8, asr r5
    1040:	053d3205 	ldreq	r3, [sp, #-517]!	@ 0xfffffdfb
    1044:	05053d26 	streq	r3, [r5, #-3366]	@ 0xfffff2da
        xNextTaskUnblockTime = portMAX_DELAY;
    1048:	3031053e 	eorscc	r0, r1, lr, lsr r5
    104c:	054b3505 	strbeq	r3, [fp, #-1285]	@ 0xfffffafb
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    1050:	35054b2f 	strcc	r4, [r5, #-2863]	@ 0xfffff4d1
    1054:	4c05054b 	cfstr32mi	mvfx0, [r5], {75}	@ 0x4b
    1058:	032f0105 			@ <UNDEFINED> instruction: 0x032f0105
}
    105c:	0b05f209 	bleq	17d888 <xNumberOfSuccessfulFrees+0x178c0c>
    1060:	3e19052f 	cfmul64cc	mvdx0, mvdx9, mvdx15
    1064:	3d3d2405 	cfldrscc	mvf2, [sp, #-20]!	@ 0xffffffec
    1068:	053d1e05 	ldreq	r1, [sp, #-3589]!	@ 0xfffff1fb
        {
    106c:	0f023d01 	svceq	0x00023d01
    1070:	f9010100 			@ <UNDEFINED> instruction: 0xf9010100
            xReturn = pxCurrentTCB;
    1074:	03000001 	movweq	r0, #1
            return xReturn;
    1078:	0000bd00 	andeq	fp, r0, r0, lsl #26
        }
    107c:	fb010200 	blx	41886 <xNumberOfSuccessfulFrees+0x3cc0a>
    1080:	01000d0e 	tsteq	r0, lr, lsl #26
    1084:	00010101 	andeq	r0, r1, r1, lsl #2
    {
    1088:	00010000 	andeq	r0, r1, r0
    108c:	2e2e0100 	sufcse	f0, f6, f0
        TaskHandle_t xReturn = NULL;
    1090:	6572462f 	ldrbvs	r4, [r2, #-1583]!	@ 0xfffff9d1
        if( taskVALID_CORE_ID( xCoreID ) != pdFALSE )
    1094:	4f545265 	svcmi	0x00545265
    1098:	654b2d53 	strbvs	r2, [fp, #-3411]	@ 0xfffff2ad
    109c:	6c656e72 	stclvs	14, cr6, [r5], #-456	@ 0xfffffe38
                xReturn = pxCurrentTCB;
    10a0:	726f702f 	rsbvc	r7, pc, #47	@ 0x2f
    10a4:	6c626174 	stfvse	f6, [r2], #-464	@ 0xfffffe30
    }
    10a8:	43472f65 	movtmi	r2, #32613	@ 0x7f65
    10ac:	52412f43 	subpl	r2, r1, #268	@ 0x10c
    10b0:	4d435f4d 	stclmi	15, cr5, [r3, #-308]	@ 0xfffffecc
    10b4:	752f0033 	strvc	r0, [pc, #-51]!	@ 1089 <xTaskGetCurrentTaskHandleForCore+0x1>
{
    10b8:	6c2f7273 	sfmvs	f7, 4, [pc], #-460	@ ef4 <xTaskCheckForTimeOut>
    10bc:	672f6269 	strvs	r6, [pc, -r9, ror #4]!
    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    10c0:	612f6363 			@ <UNDEFINED> instruction: 0x612f6363
    10c4:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) );
    10c8:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	@ 0xfffffe44
    10cc:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    10d0:	2e33312f 	rsfcssp	f3, f3, #10.0
    10d4:	2f312e32 	svccs	0x00312e32
}
    10d8:	6c636e69 	stclvs	14, cr6, [r3], #-420	@ 0xfffffe5c
    10dc:	00656475 	rsbeq	r6, r5, r5, ror r4
    10e0:	462f2e2e 	strtmi	r2, [pc], -lr, lsr #28
    10e4:	52656572 	rsbpl	r6, r5, #478150656	@ 0x1c800000
    {
    10e8:	2d534f54 	ldclcs	15, cr4, [r3, #-336]	@ 0xfffffeb0
    10ec:	6e72654b 	cdpvs	5, 7, cr6, cr2, cr11, {2}
    10f0:	692f6c65 	stmdbvs	pc!, {r0, r2, r5, r6, sl, fp, sp, lr}	@ <UNPREDICTABLE>
        BaseType_t xAlreadyYielded, xShouldBlock = pdFALSE;
    10f4:	756c636e 	strbvc	r6, [ip, #-878]!	@ 0xfffffc92
        if( ( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0U ) && ( xTicksToWait > ( TickType_t ) 0 ) )
    10f8:	00006564 	andeq	r6, r0, r4, ror #10
    10fc:	74726f70 	ldrbtvc	r6, [r2], #-3952	@ 0xfffff090
    1100:	0100632e 	tsteq	r0, lr, lsr #6
    1104:	6f700000 	svcvs	0x00700000
    1108:	616d7472 	smcvs	55106	@ 0xd742
    110c:	2e6f7263 	cdpcs	2, 6, cr7, cr15, cr3, {3}
            vTaskSuspendAll();
    1110:	00010068 	andeq	r0, r1, r8, rrx
                taskENTER_CRITICAL();
    1114:	64747300 	ldrbtvs	r7, [r4], #-768	@ 0xfffffd00
                    if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0U )
    1118:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
    111c:	00020068 	andeq	r0, r2, r8, rrx
    1120:	6f727000 	svcvs	0x00727000
    1124:	6665646a 	strbtvs	r6, [r5], -sl, ror #8
    1128:	00682e73 	rsbeq	r2, r8, r3, ror lr
                        pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
    112c:	74000003 	strvc	r0, [r0], #-3
    1130:	2e6b7361 	cdpcs	3, 6, cr7, cr11, cr1, {3}
    1134:	00030068 	andeq	r0, r3, r8, rrx
                        xShouldBlock = pdTRUE;
    1138:	01050000 	mrseq	r0, (UNDEF: 5)
                taskEXIT_CRITICAL();
    113c:	18020500 	stmdane	r2, {r8, sl}
                if( xShouldBlock == pdTRUE )
    1140:	03000021 	movweq	r0, #33	@ 0x21
    1144:	050101b8 	streq	r0, [r1, #-440]	@ 0xfffffe48
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1148:	13056911 	movwne	r6, #22801	@ 0x5911
    114c:	4b11053d 	blmi	442648 <xNumberOfSuccessfulFrees+0x43d9cc>
            xAlreadyYielded = xTaskResumeAll();
    1150:	053d1705 	ldreq	r1, [sp, #-1797]!	@ 0xfffff8fb
            if( ( xShouldBlock == pdTRUE ) && ( xAlreadyYielded == pdFALSE ) )
    1154:	13052030 	movwne	r2, #20528	@ 0x5030
    1158:	2f11052e 	svccs	0x0011052e
    115c:	053d1505 	ldreq	r1, [sp, #-1285]!	@ 0xfffffafb
                taskYIELD_WITHIN_API();
    1160:	12052013 	andne	r2, r5, #19
    1164:	3d15052f 	cfldr32cc	mvfx0, [r5, #-188]	@ 0xffffff44
    1168:	05201305 	streq	r1, [r0, #-773]!	@ 0xfffffcfb
    116c:	0c052f12 	stceq	15, cr2, [r5], {18}
        taskENTER_CRITICAL();
    1170:	2101053e 	tstcs	r1, lr, lsr r5
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];
    1174:	3d170578 	cfldr32cc	mvfx0, [r7, #-480]	@ 0xfffffe20
    1178:	05050204 	streq	r0, [r5, #-516]	@ 0xfffffdfc
    117c:	052e0c03 	streq	r0, [lr, #-3075]!	@ 0xfffff3fd
    1180:	01049801 	tsteq	r4, r1, lsl #16
            if( ulReturn != 0U )
    1184:	77030a05 	strvc	r0, [r3, -r5, lsl #20]
    1188:	00140520 	andseq	r0, r4, r0, lsr #10
                if( xClearCountOnExit != pdFALSE )
    118c:	20010402 	andcs	r0, r1, r2, lsl #8
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ( uint32_t ) 0U;
    1190:	0a030105 	beq	c15ac <xNumberOfSuccessfulFrees+0xbc930>
    1194:	05056a3c 	streq	r6, [r5, #-2620]	@ 0xfffff5c4
    1198:	03010513 	movweq	r0, #5395	@ 0x1513
    119c:	242e080e 	strtcs	r0, [lr], #-2062	@ 0xfffff7f2
    11a0:	05130505 	ldreq	r0, [r3, #-1285]	@ 0xfffffafb
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ulReturn - ( uint32_t ) 1;
    11a4:	e40d0301 	str	r0, [sp], #-769	@ 0xfffffcff
    11a8:	03310527 	teqeq	r1, #163577856	@ 0x9c00000
    11ac:	21053c0f 	tstcs	r5, pc, lsl #24
    11b0:	03050520 	movweq	r0, #21792	@ 0x5520
            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;
    11b4:	052e00ea 	streq	r0, [lr, #-234]!	@ 0xffffff16
    11b8:	05053c18 	streq	r3, [r5, #-3096]	@ 0xfffff3e8
    11bc:	3c18053d 	cfldr32cc	mvfx0, [r8], {61}	@ 0x3d
    11c0:	053d0505 	ldreq	r0, [sp, #-1285]!	@ 0xfffffafb
        taskEXIT_CRITICAL();
    11c4:	05052018 	streq	r2, [r5, #-24]	@ 0xffffffe8
    }
    11c8:	31170532 	tstcc	r7, r2, lsr r5
    11cc:	363f0505 	ldrtcc	r0, [pc], -r5, lsl #10
    11d0:	310c052f 	tstcc	ip, pc, lsr #10
    11d4:	be210105 	suflts	f0, f1, f5
    {
    11d8:	02044e32 	andeq	r4, r4, #800	@ 0x320
    11dc:	ad030505 	cfstr32ge	mvfx0, [r3, #-20]	@ 0xffffffec
    11e0:	01053c7e 	tsteq	r5, lr, ror ip
    11e4:	05010498 	streq	r0, [r1, #-1176]	@ 0xfffffb68
        BaseType_t xReturn, xAlreadyYielded, xShouldBlock = pdFALSE;
    11e8:	01cd0316 	biceq	r0, sp, r6, lsl r3
        if( ( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED ) && ( xTicksToWait > ( TickType_t ) 0 ) )
    11ec:	03010520 	movweq	r0, #5408	@ 0x1520
    11f0:	0586580b 	streq	r5, [r6, #2059]	@ 0x80b
    11f4:	1b053e16 	blne	150a54 <xNumberOfSuccessfulFrees+0x14bdd8>
    11f8:	2e07055a 	cfrshl32cs	mvfx7, mvfx10, r0
    11fc:	05050204 	streq	r0, [r5, #-516]	@ 0xfffffdfc
    1200:	4a7eba03 	bmi	1fafa14 <xNumberOfSuccessfulFrees+0x1faad98>
            vTaskSuspendAll();
    1204:	04400105 	strbeq	r0, [r0], #-261	@ 0xfffffefb
                taskENTER_CRITICAL();
    1208:	01c60301 	biceq	r0, r6, r1, lsl #6
                    if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )
    120c:	05058620 	streq	r8, [r5, #-1568]	@ 0xfffff9e0
    1210:	03010515 	movweq	r0, #5397	@ 0x1515
    1214:	0122021d 			@ <UNDEFINED> instruction: 0x0122021d
    1218:	05020424 	streq	r0, [r2, #-1060]	@ 0xfffffbdc
                        pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnEntry;
    121c:	7dec0305 	stclvc	3, cr0, [ip, #20]!
    1220:	9801053c 	stmdals	r1, {r2, r3, r4, r5, r8, sl}
    1224:	0d050104 	stfeqs	f0, [r5, #-16]
    1228:	20029503 	andcs	r9, r2, r3, lsl #10
    122c:	02000b05 	andeq	r0, r0, #5120	@ 0x1400
    1230:	053c0104 	ldreq	r0, [ip, #-260]!	@ 0xfffffefc
    1234:	2305340d 	movwcs	r3, #21517	@ 0x540d
    1238:	05020420 	streq	r0, [r2, #-1056]	@ 0xfffffbe0
                        pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
    123c:	7dff0305 	ldclvc	3, cr0, [pc, #20]!	@ 1258 <xTaskGenericNotifyWait+0x80>
    1240:	40010558 	andmi	r0, r1, r8, asr r5
    1244:	85030104 	strhi	r0, [r3, #-260]	@ 0xfffffefc
                        xShouldBlock = pdTRUE;
    1248:	e5032002 	str	r2, [r3, #-2]
                taskEXIT_CRITICAL();
    124c:	05057401 	streq	r7, [r5, #-1025]	@ 0xfffffbff
                if( xShouldBlock == pdTRUE )
    1250:	052e0b03 	streq	r0, [lr, #-2819]!	@ 0xfffff4fd
    1254:	0505201f 	streq	r2, [r5, #-31]	@ 0xffffffe1
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1258:	2028052f 	eorcs	r0, r8, pc, lsr #10
    125c:	05310505 	ldreq	r0, [r1, #-1285]!	@ 0xfffffafb
            xAlreadyYielded = xTaskResumeAll();
    1260:	0505201f 	streq	r2, [r5, #-31]	@ 0xffffffe1
            if( ( xShouldBlock == pdTRUE ) && ( xAlreadyYielded == pdFALSE ) )
    1264:	201f052f 	andscs	r0, pc, pc, lsr #10
    1268:	022f0105 	eoreq	r0, pc, #1073741825	@ 0x40000001
    126c:	0101000c 	tsteq	r1, ip

Disassembly of section .debug_info:

00000000 <.debug_info>:
       0:	00000022 	andeq	r0, r0, r2, lsr #32
       4:	00000002 	andeq	r0, r0, r2
       8:	01040000 	mrseq	r0, (UNDEF: 4)
       c:	00000000 	andeq	r0, r0, r0
      10:	00000198 	muleq	r0, r8, r1
      14:	0000019c 	muleq	r0, ip, r1
      18:	00000000 	andeq	r0, r0, r0
      1c:	00000007 	andeq	r0, r0, r7
      20:	00000021 	andeq	r0, r0, r1, lsr #32
      24:	00928001 	addseq	r8, r2, r1
      28:	00050000 	andeq	r0, r5, r0
      2c:	00140401 	andseq	r0, r4, r1, lsl #8
      30:	65020000 	strvs	r0, [r2, #-0]
      34:	1d000000 	stcne	0, cr0, [r0, #-0]
      38:	000000b8 	strheq	r0, [r0], -r8
      3c:	00000007 	andeq	r0, r0, r7
      40:	0000019c 	muleq	r0, ip, r1
      44:	0000000c 	andeq	r0, r0, ip
      48:	00000034 	andeq	r0, r0, r4, lsr r0
      4c:	69050403 	stmdbvs	r5, {r0, r1, sl}
      50:	0100746e 	tsteq	r0, lr, ror #8
      54:	00580704 	subseq	r0, r8, r4, lsl #14
      58:	08010000 	stmdaeq	r1, {}	@ <UNPREDICTABLE>
      5c:	00002d05 	andeq	r2, r0, r5, lsl #26
      60:	04080100 	streq	r0, [r8], #-256	@ 0xffffff00
      64:	000000e8 	andeq	r0, r0, r8, ror #1
      68:	c2060101 	andgt	r0, r6, #1073741824	@ 0x40000000
      6c:	01000000 	mrseq	r0, (UNDEF: 0)
      70:	00f40502 	rscseq	r0, r4, r2, lsl #10
      74:	04010000 	streq	r0, [r1], #-0
      78:	00003205 	andeq	r3, r0, r5, lsl #4
      7c:	08010100 	stmdaeq	r1, {r8}
      80:	000000c0 	andeq	r0, r0, r0, asr #1
      84:	3b070201 	blcc	1c0890 <xNumberOfSuccessfulFrees+0x1bbc14>
      88:	01000000 	mrseq	r0, (UNDEF: 0)
      8c:	00530704 	subseq	r0, r3, r4, lsl #14
      90:	08010000 	stmdaeq	r1, {}	@ <UNPREDICTABLE>
      94:	00004e07 	andeq	r4, r0, r7, lsl #28
      98:	08010100 	stmdaeq	r1, {r8}
      9c:	000000c9 	andeq	r0, r0, r9, asr #1
      a0:	0000d404 	andeq	sp, r0, r4, lsl #8
      a4:	05ef0200 	strbeq	r0, [pc, #512]!	@ 2ac <prvInitialiseNewTask+0xa>
      a8:	00ce0506 	sbceq	r0, lr, r6, lsl #10
      ac:	04010000 	streq	r0, [r1], #-0
      b0:	00019c06 	andeq	r9, r1, r6, lsl #24
      b4:	00000c00 	andeq	r0, r0, r0, lsl #24
      b8:	009c0100 	addseq	r0, ip, r0, lsl #2
      bc:	000000a2 	andeq	r0, r0, r2, lsr #1
      c0:	04010005 	streq	r0, [r1], #-5
      c4:	00000068 	andeq	r0, r0, r8, rrx
      c8:	00006503 	andeq	r6, r0, r3, lsl #10
      cc:	00fe1d00 	rscseq	r1, lr, r0, lsl #26
      d0:	00070000 	andeq	r0, r7, r0
      d4:	01a80000 			@ <UNDEFINED> instruction: 0x01a80000
      d8:	003a0000 	eorseq	r0, sl, r0
      dc:	00970000 	addseq	r0, r7, r0
      e0:	13040000 	movwne	r0, #16384	@ 0x4000
      e4:	01000001 	tsteq	r0, r1
      e8:	00880701 	addeq	r0, r8, r1, lsl #14
      ec:	01a80000 			@ <UNDEFINED> instruction: 0x01a80000
      f0:	003a0000 	eorseq	r0, sl, r0
      f4:	9c010000 	stcls	0, cr0, [r1], {-0}
      f8:	00000088 	andeq	r0, r0, r8, lsl #1
      fc:	74736405 	ldrbtvc	r6, [r3], #-1029	@ 0xfffffbfb
     100:	14010100 	strne	r0, [r1], #-256	@ 0xffffff00
     104:	00000088 	andeq	r0, r0, r8, lsl #1
     108:	016c9102 	cmneq	ip, r2, lsl #2
     10c:	0000011f 	andeq	r0, r0, pc, lsl r1
     110:	00008a1d 	andeq	r8, r0, sp, lsl sl
     114:	68910200 	ldmvs	r1, {r9}
     118:	00010e01 	andeq	r0, r1, r1, lsl #28
     11c:	00913100 	addseq	r3, r1, r0, lsl #2
     120:	91020000 	mrsls	r0, (UNDEF: 2)
     124:	74700664 	ldrbtvc	r0, [r0], #-1636	@ 0xfffff99c
     128:	02010072 	andeq	r0, r1, #114	@ 0x72
     12c:	00009814 	andeq	r9, r0, r4, lsl r8
     130:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
     134:	00011a07 	andeq	r1, r1, r7, lsl #20
     138:	13030100 	movwne	r0, #12544	@ 0x3100
     13c:	0000009e 	muleq	r0, lr, r0
     140:	00739102 	rsbseq	r9, r3, r2, lsl #2
     144:	04090408 	streq	r0, [r9], #-1032	@ 0xfffffbf8
     148:	746e6905 	strbtvc	r6, [lr], #-2309	@ 0xfffff6fb
     14c:	07040200 	streq	r0, [r4, -r0, lsl #4]
     150:	00000058 	andeq	r0, r0, r8, asr r0
     154:	009e040a 	addseq	r0, lr, sl, lsl #8
     158:	01020000 	mrseq	r0, (UNDEF: 2)
     15c:	0000c008 	andeq	ip, r0, r8
     160:	15f60000 	ldrbne	r0, [r6, #0]!
     164:	00050000 	andeq	r0, r5, r0
     168:	01050401 	tsteq	r5, r1, lsl #8
     16c:	65240000 	strvs	r0, [r4, #-0]!
     170:	1d000000 	stcne	0, cr0, [r0, #-0]
     174:	000007d4 	ldrdeq	r0, [r0], -r4
     178:	00000007 	andeq	r0, r0, r7
     17c:	000001e4 	andeq	r0, r0, r4, ror #3
     180:	000018ec 	andeq	r1, r0, ip, ror #17
     184:	000000f1 	strdeq	r0, [r0], -r1
     188:	0004f507 	andeq	pc, r4, r7, lsl #10
     18c:	17d60300 	ldrbne	r0, [r6, r0, lsl #6]
     190:	00000032 	andeq	r0, r0, r2, lsr r0
     194:	5807040a 	stmdapl	r7, {r1, r3, sl}
     198:	25000000 	strcs	r0, [r0, #-0]
{
     19c:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    vTaskStartScheduler();
     1a0:	080a0074 	stmdaeq	sl, {r2, r4, r5, r6}
    return;
     1a4:	00002d05 	andeq	r2, r0, r5, lsl #26
void* memset(void* dst, int value, unsigned int size) {
     1a8:	04080a00 	streq	r0, [r8], #-2560	@ 0xfffff600
     1ac:	000000e8 	andeq	r0, r0, r8, ror #1
     1b0:	c206010a 	andgt	r0, r6, #-2147483646	@ 0x80000002
    unsigned char *ptr = (unsigned char *)dst;
     1b4:	0a000000 	beq	1bc <memset+0x14>
    unsigned char byte_value = (unsigned char)value;
     1b8:	00c00801 	sbceq	r0, r0, r1, lsl #16
    while(size > 0){
     1bc:	020a0000 	andeq	r0, sl, #0
        *ptr = byte_value;
     1c0:	0000f405 	andeq	pc, r0, r5, lsl #8
        ptr++;
     1c4:	07020a00 	streq	r0, [r2, -r0, lsl #20]
     1c8:	0000003b 	andeq	r0, r0, fp, lsr r0
        size--;
     1cc:	3205040a 	andcc	r0, r5, #167772160	@ 0xa000000
    while(size > 0){
     1d0:	0a000000 	beq	1d8 <memset+0x30>
     1d4:	00530704 	subseq	r0, r3, r4, lsl #14
     1d8:	080a0000 	stmdaeq	sl, {}	@ <UNPREDICTABLE>
     1dc:	00004e07 	andeq	r4, r0, r7, lsl #28
     1e0:	05042600 	streq	r2, [r4, #-1536]	@ 0xfffffa00
    {
     1e4:	0000007f 	andeq	r0, r0, pc, ror r0
     1e8:	00008b04 	andeq	r8, r0, r4, lsl #22
     1ec:	08010a00 	stmdaeq	r1, {r9, fp}
     1f0:	000000c9 	andeq	r0, r0, r9, asr #1
            pxStack = pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) );
     1f4:	00008b05 	andeq	r8, r0, r5, lsl #22
     1f8:	00920400 	addseq	r0, r2, r0, lsl #8
     1fc:	97050000 	strls	r0, [r5, -r0]
            if( pxStack != NULL )
     200:	07000000 	streq	r0, [r0, -r0]
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     204:	00000688 	andeq	r0, r0, r8, lsl #13
     208:	55182e04 	ldrpl	r2, [r8, #-3588]	@ 0xfffff1fc
                if( pxNewTCB != NULL )
     20c:	0b000000 	bleq	214 <prvCreateTask+0x30>
     210:	000000a1 	andeq	r0, r0, r1, lsr #1
                    ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
     214:	00039007 	andeq	r9, r3, r7
     218:	19340400 	ldmdbne	r4!, {sl}
                    pxNewTCB->pxStack = pxStack;
     21c:	00000071 	andeq	r0, r0, r1, ror r0
     220:	0000b20b 	andeq	fp, r0, fp, lsl #4
                    vPortFreeStack( pxStack );
     224:	07970700 	ldreq	r0, [r7, r0, lsl #14]
     228:	24050000 	strcs	r0, [r5], #-0
                pxNewTCB = NULL;
     22c:	0000cf11 	andeq	ip, r0, r1, lsl pc
        if( pxNewTCB != NULL )
     230:	00d40400 	sbcseq	r0, r4, r0, lsl #8
     234:	df270000 	svcle	0x00270000
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
     238:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
     23c:	0000007f 	andeq	r0, r0, pc, ror r0
     240:	022f0700 	eoreq	r0, pc, #0, 14
     244:	3a020000 	bcc	8024c <xNumberOfSuccessfulFrees+0x7b5d0>
     248:	0000b21a 	andeq	fp, r0, sl, lsl r2
     24c:	00df0b00 	sbcseq	r0, pc, r0, lsl #22
     250:	df050000 	svcle	0x00050000
    }
     254:	07000000 	streq	r0, [r0, -r0]
     258:	00000605 	andeq	r0, r0, r5, lsl #12
    {
     25c:	6a1a3b02 	bvs	68ee6c <xNumberOfSuccessfulFrees+0x68a1f0>
     260:	0b000000 	bleq	268 <xTaskCreate+0xc>
     264:	000000f5 	strdeq	r0, [r0], -r5
     268:	0000f505 	andeq	pc, r0, r5, lsl #10
        pxNewTCB = prvCreateTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );
     26c:	06040700 	streq	r0, [r4], -r0, lsl #14
     270:	3c020000 	stccc	0, cr0, [r2], {-0}
     274:	0000711a 	andeq	r7, r0, sl, lsl r1
     278:	010b0b00 	tsteq	fp, r0, lsl #22
     27c:	17050000 	strne	r0, [r5, -r0]
        if( pxNewTCB != NULL )
     280:	07000001 	streq	r0, [r0, -r1]
     284:	00000887 	andeq	r0, r0, r7, lsl #17
            prvAddNewTaskToReadyList( pxNewTCB );
     288:	b21a4202 	andslt	r4, sl, #536870912	@ 0x20000000
            xReturn = pdPASS;
     28c:	0b000000 	bleq	294 <xTaskCreate+0x38>
     290:	00000121 	andeq	r0, r0, r1, lsr #2
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     294:	00012105 	andeq	r2, r1, r5, lsl #2
        return xReturn;
     298:	02611200 	rsbeq	r1, r1, #0, 4
    }
     29c:	06140000 	ldreq	r0, [r4], -r0
     2a0:	01860890 			@ <UNDEFINED> instruction: 0x01860890
{
     2a4:	47060000 	strmi	r0, [r6, -r0]
     2a8:	06000009 	streq	r0, [r0], -r9
     2ac:	01212493 			@ <UNDEFINED> instruction: 0x01212493
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
     2b0:	06000000 	streq	r0, [r0], -r0
     2b4:	000007a6 	andeq	r0, r0, r6, lsr #15
     2b8:	862d9406 	strthi	r9, [sp], -r6, lsl #8
     2bc:	04000001 	streq	r0, [r0], #-1
     2c0:	00049606 	andeq	r9, r4, r6, lsl #12
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     2c4:	2d950600 	ldccs	6, cr0, [r5]
     2c8:	00000186 	andeq	r0, r0, r6, lsl #3
    if( pcName != NULL )
     2cc:	0aba0608 	beq	fee81af4 <__StackTop+0xdee7faf4>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     2d0:	96060000 	strls	r0, [r6], -r0
     2d4:	00007f0c 	andeq	r7, r0, ip, lsl #30
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     2d8:	e1060c00 	tst	r6, r0, lsl #24
     2dc:	06000008 	streq	r0, [r0], -r8
     2e0:	01c02897 			@ <UNDEFINED> instruction: 0x01c02897
     2e4:	00100000 	andseq	r0, r0, r0
     2e8:	00013704 	andeq	r3, r1, r4, lsl #14
            if( pcName[ x ] == ( char ) 0x00 )
     2ec:	05221200 	streq	r1, [r2, #-512]!	@ 0xfffffe00
     2f0:	06140000 	ldreq	r0, [r4], -r0
     2f4:	01c010ac 	biceq	r1, r0, ip, lsr #1
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     2f8:	38060000 	stmdacc	r6, {}	@ <UNPREDICTABLE>
     2fc:	06000001 	streq	r0, [r0], -r1
     300:	010b25af 	smlatbeq	fp, pc, r5, r2	@ <UNPREDICTABLE>
                break;
     304:	06000000 	streq	r0, [r0], -r0
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1U ] = '\0';
     308:	00000227 	andeq	r0, r0, r7, lsr #4
     30c:	1226b006 	eorne	fp, r6, #6
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
     310:	04000002 	streq	r0, [r0], #-2
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
     314:	00063306 	andeq	r3, r6, r6, lsl #6
    pxNewTCB->uxPriority = uxPriority;
     318:	14b10600 	ldrtne	r0, [r1], #1536	@ 0x600
     31c:	00000206 	andeq	r0, r0, r6, lsl #4
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     320:	8b040008 	blhi	100348 <xNumberOfSuccessfulFrees+0xfb6cc>
     324:	07000001 	streq	r0, [r0, -r1]
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     328:	00000658 	andeq	r0, r0, r8, asr r6
     32c:	371b9a06 	ldrcc	r9, [fp, -r6, lsl #20]
     330:	12000001 	andne	r0, r0, #1
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     334:	00000507 	andeq	r0, r0, r7, lsl #10
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );
     338:	0c9d060c 	ldceq	6, cr0, [sp], {12}
     33c:	00000206 	andeq	r0, r0, r6, lsl #4
     340:	00094706 	andeq	r4, r9, r6, lsl #14
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     344:	28a00600 	stmiacs	r0!, {r9, sl}
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     348:	00000121 	andeq	r0, r0, r1, lsr #2
     34c:	07a60600 	streq	r0, [r6, r0, lsl #12]!
     350:	a1060000 	mrsge	r0, (UNDEF: 6)
     354:	00018631 	andeq	r8, r1, r1, lsr r6
    if( pxCreatedTask != NULL )
     358:	96060400 	strls	r0, [r6], -r0, lsl #8
     35c:	06000004 	streq	r0, [r0], -r4
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     360:	018631a2 	orreq	r3, r6, r2, lsr #3
}
     364:	00080000 	andeq	r0, r8, r0
     368:	00065407 	andeq	r5, r6, r7, lsl #8
    {
     36c:	24a40600 	strtcs	r0, [r4], #1536	@ 0x600
     370:	000001d1 	ldrdeq	r0, [r0], -r1
        taskENTER_CRITICAL();
     374:	0001c504 	andeq	ip, r1, r4, lsl #10
            uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );
     378:	02120500 	andseq	r0, r2, #0, 10
     37c:	73070000 	movwvc	r0, #28672	@ 0x7000
     380:	06000008 	streq	r0, [r0], -r8
            if( pxCurrentTCB == NULL )
     384:	018b03b3 			@ <UNDEFINED> instruction: 0x018b03b3
     388:	1c050000 	stcne	0, cr0, [r5], {-0}
                pxCurrentTCB = pxNewTCB;
     38c:	07000002 	streq	r0, [r0, -r2]
                if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     390:	00000835 	andeq	r0, r0, r5, lsr r8
     394:	392e5f07 	stmdbcc	lr!, {r0, r1, r2, r8, r9, sl, fp, ip, lr}
                    prvInitialiseTaskLists();
     398:	04000002 	streq	r0, [r0], #-2
     39c:	0000023e 	andeq	r0, r0, lr, lsr r2
                if( xSchedulerRunning == pdFALSE )
     3a0:	00018528 	andeq	r8, r1, r8, lsr #10
     3a4:	76014c00 	strvc	r4, [r1], -r0, lsl #24
                    if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     3a8:	02b51001 	adcseq	r1, r5, #1
     3ac:	cc0d0000 	stcgt	0, cr0, [sp], {-0}
     3b0:	7800000b 	stmdavc	r0, {r0, r1, r3}
                        pxCurrentTCB = pxNewTCB;
     3b4:	036d1c01 	cmneq	sp, #256	@ 0x100
     3b8:	0d000000 	stceq	0, cr0, [r0, #-0]
            uxTaskNumber++;
     3bc:	00000b85 	andeq	r0, r0, r5, lsl #23
     3c0:	c5100182 	ldrgt	r0, [r0, #-386]	@ 0xfffffe7e
            prvAddTaskToReadyList( pxNewTCB );
     3c4:	04000001 	streq	r0, [r0], #-1
     3c8:	000aed0d 	andeq	lr, sl, sp, lsl #26
     3cc:	10018300 	andne	r8, r1, r0, lsl #6
     3d0:	000001c5 	andeq	r0, r0, r5, asr #3
     3d4:	016e0d18 	cmneq	lr, r8, lsl sp
     3d8:	01840000 	orreq	r0, r4, r0
     3dc:	00010b11 	andeq	r0, r1, r1, lsl fp
     3e0:	830d2c00 	movwhi	r2, #56320	@ 0xdc00
     3e4:	85000009 	strhi	r0, [r0, #-9]
     3e8:	03681301 	cmneq	r8, #67108864	@ 0x4000000
     3ec:	0d300000 	ldceq	0, cr0, [r0, #-0]
     3f0:	0000012d 	andeq	r0, r0, sp, lsr #2
     3f4:	720a018a 	andvc	r0, sl, #-2147483614	@ 0x80000022
     3f8:	34000003 	strcc	r0, [r0], #-3
     3fc:	0005920d 	andeq	r9, r5, sp, lsl #4
     400:	1b01b300 	blne	6d008 <xNumberOfSuccessfulFrees+0x6838c>
     404:	00000392 	muleq	r0, r2, r3
     408:	03990d44 	orrseq	r0, r9, #68, 26	@ 0x1100
     40c:	01b40000 			@ <UNDEFINED> instruction: 0x01b40000
     410:	0003a71a 	andeq	sl, r3, sl, lsl r7
     414:	29004800 	stmdbcs	r0, {fp, lr}
     418:	00550107 	subseq	r0, r5, r7, lsl #2
     41c:	75070000 	strvc	r0, [r7, #-0]
     420:	0002e201 	andeq	lr, r2, r1, lsl #4
     424:	01de1300 	bicseq	r1, lr, r0, lsl #6
     428:	13000000 	movwne	r0, #0
     42c:	000008a6 	andeq	r0, r0, r6, lsr #17
     430:	04fc1301 	ldrbteq	r1, [ip], #769	@ 0x301
     434:	13020000 	movwne	r0, #8192	@ 0x2000
     438:	00000415 	andeq	r0, r0, r5, lsl r4
     43c:	05dd1303 	ldrbeq	r1, [sp, #771]	@ 0x303
     440:	00040000 	andeq	r0, r4, r0
     444:	0004e707 	andeq	lr, r4, r7, lsl #14
        taskEXIT_CRITICAL();
     448:	037b0700 	cmneq	fp, #0, 14
        if( xSchedulerRunning != pdFALSE )
     44c:	000002b5 			@ <UNDEFINED> instruction: 0x000002b5
     450:	00023b12 	andeq	r3, r2, r2, lsl fp
            taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
     454:	80070800 	andhi	r0, r7, r0, lsl #16
     458:	00031610 	andeq	r1, r3, r0, lsl r6
     45c:	03120600 	tsteq	r2, #0, 12
     460:	82070000 	andhi	r0, r7, #0
     464:	0000f510 	andeq	pc, r0, r0, lsl r5	@ <UNPREDICTABLE>
     468:	87060000 	strhi	r0, [r6, -r0]
     46c:	07000007 	streq	r0, [r0, -r7]
    }
     470:	01211083 	smlawbeq	r1, r3, r0, r1
     474:	00040000 	andeq	r0, r4, r0
     478:	00080107 	andeq	r0, r8, r7, lsl #2
     47c:	03840700 	orreq	r0, r4, #0, 14
     480:	000002ee 	andeq	r0, r0, lr, ror #5
     484:	0008af12 	andeq	sl, r8, r2, lsl pc
     488:	89070c00 	stmdbhi	r7, {sl, fp}
     48c:	00035710 	andeq	r5, r3, r0, lsl r7
     490:	0a310600 	beq	c41c98 <xNumberOfSuccessfulFrees+0xc3d01c>
{
     494:	8b070000 	blhi	1c049c <xNumberOfSuccessfulFrees+0x1bb820>
     498:	00007f0c 	andeq	r7, r0, ip, lsl #30
    BaseType_t xReturn = pdPASS;
     49c:	5b060000 	blpl	1804a4 <xNumberOfSuccessfulFrees+0x17b828>
    char cIdleName[ configMAX_TASK_NAME_LEN ] = { 0 };
     4a0:	07000007 	streq	r0, [r0, -r7]
     4a4:	00b20e8c 	adcseq	r0, r2, ip, lsl #29
     4a8:	06040000 	streq	r0, [r4], -r0
    TaskFunction_t pxIdleTaskFunction = NULL;
     4ac:	00000356 	andeq	r0, r0, r6, asr r3
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
     4b0:	b20e8d07 	andlt	r8, lr, #448	@ 0x1c0
        cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
     4b4:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
     4b8:	06c60700 	strbeq	r0, [r6], r0, lsl #14
     4bc:	8e070000 	cdphi	0, 0, cr0, cr7, cr0, {0}
     4c0:	00032203 	andeq	r2, r3, r3, lsl #4
     4c4:	03570500 	cmpeq	r7, #0, 10
        if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
     4c8:	df040000 	svcle	0x00040000
     4cc:	04000000 	streq	r0, [r0], #-0
     4d0:	000000eb 	andeq	r0, r0, fp, ror #1
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
     4d4:	00008b10 	andeq	r8, r0, r0, lsl fp
     4d8:	00038200 	andeq	r8, r3, r0, lsl #4
     4dc:	00321100 	eorseq	r1, r2, r0, lsl #2
            break;
     4e0:	000f0000 	andeq	r0, pc, r0
    cIdleName[ xIdleTaskNameIndex ] = '\0';
     4e4:	0000be10 	andeq	fp, r0, r0, lsl lr
     4e8:	00039200 	andeq	r9, r3, r0, lsl #4
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
     4ec:	00321100 	eorseq	r1, r2, r0, lsl #2
     4f0:	00000000 	andeq	r0, r0, r0
            pxIdleTaskFunction = &prvIdleTask;
     4f4:	0003820b 	andeq	r8, r3, fp, lsl #4
            xReturn = xTaskCreate( pxIdleTaskFunction,
     4f8:	00ad1000 	adceq	r1, sp, r0
     4fc:	03a70000 			@ <UNDEFINED> instruction: 0x03a70000
     500:	32110000 	andscc	r0, r1, #0
     504:	00000000 	andeq	r0, r0, r0
     508:	03970b00 	orrseq	r0, r7, #0, 22
     50c:	721d0000 	andsvc	r0, sp, #0
     510:	c4000003 	strgt	r0, [r0], #-3
        if( xReturn != pdPASS )
     514:	023e0301 	eorseq	r0, lr, #67108864	@ 0x4000000
     518:	b41d0000 	ldrlt	r0, [sp], #-0
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
     51c:	c800000a 	stmdagt	r0, {r1, r3}
     520:	03ac1001 			@ <UNDEFINED> instruction: 0x03ac1001
     524:	ed2a0000 	stc	0, cr0, [sl, #-0]
            break;
     528:	01000008 	tsteq	r0, r8
}
     52c:	dc3701ce 	ldfles	f0, [r7], #-824	@ 0xfffffcc8
     530:	05000003 	streq	r0, [r0, #-3]
     534:	00238c03 	eoreq	r8, r3, r3, lsl #24
     538:	03b80400 			@ <UNDEFINED> instruction: 0x03b80400
     53c:	d70b0000 	strle	r0, [fp, -r0]
{
     540:	10000003 	andne	r0, r0, r3
     544:	0000021c 	andeq	r0, r0, ip, lsl r2
    xReturn = prvCreateIdleTasks();
     548:	000003f1 	strdeq	r0, [r0], -r1
    if( xReturn == pdPASS )
     54c:	00003211 	andeq	r3, r0, r1, lsl r2
     550:	01000400 	tsteq	r0, r0, lsl #8
    __asm volatile
     554:	0000026c 	andeq	r0, r0, ip, ror #4
     558:	e11f01db 			@ <UNDEFINED> instruction: 0xe11f01db
     55c:	05000003 	streq	r0, [r0, #-3]
     560:	00239003 	eoreq	r9, r3, r3
}
     564:	02ee0100 	rsceq	r0, lr, #0, 2
        xNextTaskUnblockTime = portMAX_DELAY;
     568:	01dc0000 	bicseq	r0, ip, r0
     56c:	00021c1f 	andeq	r1, r2, pc, lsl ip
        xSchedulerRunning = pdTRUE;
     570:	f4030500 	vst3.8	{d0,d2,d4}, [r3], r0
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     574:	01000023 	tsteq	r0, r3, lsr #32
     578:	00000300 	andeq	r0, r0, r0, lsl #6
        ( void ) xPortStartScheduler();
     57c:	1c1f01dd 	ldfnes	f0, [pc], {221}	@ 0xdd
    ( void ) uxTopUsedPriority;
     580:	05000002 	streq	r0, [r0, #-2]
}
     584:	00240803 	eoreq	r0, r4, r3, lsl #16
     588:	09610100 	stmdbeq	r1!, {r8}^
     58c:	01de0000 	bicseq	r0, lr, r0
     590:	00043e2a 	andeq	r3, r4, sl, lsr #28
     594:	1c030500 	cfstr32ne	mvfx0, [r3], {-0}
     598:	04000024 	streq	r0, [r0], #-36	@ 0xffffffdc
{
     59c:	0000021c 	andeq	r0, r0, ip, lsl r2
     5a0:	0004390b 	andeq	r3, r4, fp, lsl #18
    __asm volatile
     5a4:	04390500 	ldrteq	r0, [r9], #-1280	@ 0xfffffb00
     5a8:	51010000 	mrspl	r0, (UNDEF: 1)
     5ac:	df000005 	svcle	0x00000005
     5b0:	043e2a01 	ldrteq	r2, [lr], #-2561	@ 0xfffff5ff
}
     5b4:	03050000 	movweq	r0, #20480	@ 0x5000
    xSchedulerRunning = pdFALSE;
     5b8:	00002420 	andeq	r2, r0, r0, lsr #8
    vPortEndScheduler();
     5bc:	00046d01 	andeq	r6, r4, r1, lsl #26
}
     5c0:	1f01e000 	svcne	0x0001e000
     5c4:	0000021c 	andeq	r0, r0, ip, lsl r2
     5c8:	24240305 	strtcs	r0, [r4], #-773	@ 0xfffffcfb
{
     5cc:	62010000 	andvs	r0, r1, #0
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
     5d0:	f600000b 			@ <UNDEFINED> instruction: 0xf600000b
     5d4:	01172d01 	tsteq	r7, r1, lsl #26
     5d8:	03050000 	movweq	r0, #20480	@ 0x5000
}
     5dc:	00002438 	andeq	r2, r0, r8, lsr r4
     5e0:	00051701 	andeq	r1, r5, r1, lsl #14
     5e4:	2c01f700 	stccs	7, cr15, [r1], {-0}
{
     5e8:	0000012d 	andeq	r0, r0, sp, lsr #2
     5ec:	243c0305 	ldrtcs	r0, [ip], #-773	@ 0xfffffcfb
    TCB_t * pxTCB = NULL;
     5f0:	e8010000 	stmda	r1, {}	@ <UNPREDICTABLE>
    BaseType_t xAlreadyYielded = pdFALSE;
     5f4:	f8000001 			@ <UNDEFINED> instruction: 0xf8000001
        taskENTER_CRITICAL();
     5f8:	01172d01 	tsteq	r7, r1, lsl #26
            const BaseType_t xCoreID = ( BaseType_t ) portGET_CORE_ID();
     5fc:	03050000 	movweq	r0, #20480	@ 0x5000
            uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended - 1U );
     600:	00002440 	andeq	r2, r0, r0, asr #8
     604:	00021501 	andeq	r1, r2, r1, lsl #10
            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     608:	2c01f900 			@ <UNDEFINED> instruction: 0x2c01f900
     60c:	00000101 	andeq	r0, r0, r1, lsl #2
     610:	24440305 	strbcs	r0, [r4], #-773	@ 0xfffffcfb
                if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     614:	fc010000 	stc2	0, cr0, [r1], {-0}
     618:	fa00000a 	blx	648 <xTaskResumeAll+0x60>
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     61c:	012d2c01 			@ <UNDEFINED> instruction: 0x012d2c01
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     620:	03050000 	movweq	r0, #20480	@ 0x5000
     624:	00002448 	andeq	r2, r0, r8, asr #8
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
     628:	00010110 	andeq	r0, r1, r0, lsl r1
     62c:	0004d600 	andeq	sp, r4, r0, lsl #12
     630:	00321100 	eorseq	r1, r2, r0, lsl #2
     634:	00000000 	andeq	r0, r0, r0
     638:	0004c60b 	andeq	ip, r4, fp, lsl #12
     63c:	02c30100 	sbceq	r0, r3, #0, 2
     640:	01fb0000 	mvnseq	r0, r0
     644:	0004d62c 	andeq	sp, r4, ip, lsr #12
     648:	4c030500 	cfstr32mi	mvfx0, [r3], {-0}
     64c:	01000024 	tsteq	r0, r4, lsr #32
     650:	000008d1 	ldrdeq	r0, [r0], -r1
     654:	012c01fc 	strdeq	r0, [ip, -ip]!
     658:	05000001 	streq	r0, [r0, #-1]
     65c:	00245003 	eoreq	r5, r4, r3
     660:	08280100 	stmdaeq	r8!, {r8}
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
     664:	01fd0000 	mvnseq	r0, r0
     668:	00010b24 	andeq	r0, r1, r4, lsr #22
     66c:	54030500 	strpl	r0, [r3], #-1280	@ 0xfffffb00
     670:	01000024 	tsteq	r0, r4, lsr #32
     674:	000006d5 	ldrdeq	r0, [r0], -r5
     678:	2d2c01fe 	stfcss	f0, [ip, #-1016]!	@ 0xfffffc08
     67c:	05000001 	streq	r0, [r0, #-1]
     680:	00245803 	eoreq	r5, r4, r3, lsl #16
     684:	022d1000 	eoreq	r1, sp, #0
     688:	05330000 	ldreq	r0, [r3, #-0]!
     68c:	32110000 	andscc	r0, r1, #0
     690:	00000000 	andeq	r0, r0, r0
     694:	05810100 	streq	r0, [r1, #256]	@ 0x100
     698:	01ff0000 	mvnseq	r0, r0
     69c:	00052325 	andeq	r2, r5, r5, lsr #6
     6a0:	5c030500 	cfstr32pl	mvfx0, [r3], {-0}
                        prvAddTaskToReadyList( pxTCB );
     6a4:	01000024 	tsteq	r0, r4, lsr #32
     6a8:	000004b8 			@ <UNDEFINED> instruction: 0x000004b8
     6ac:	1c230204 	sfmne	f0, 4, [r3], #-16
     6b0:	05000001 	streq	r0, [r0, #-1]
     6b4:	00237803 	eoreq	r7, r3, r3, lsl #16
     6b8:	0bb70100 	bleq	fedc0ac0 <__StackTop+0xdedbeac0>
     6bc:	02120000 	andseq	r0, r2, #0
     6c0:	0001172d 	andeq	r1, r1, sp, lsr #14
     6c4:	60030500 	andvs	r0, r3, r0, lsl #10
     6c8:	2b000024 	blcs	760 <xTaskResumeAll+0x178>
     6cc:	000003a7 	andeq	r0, r0, r7, lsr #7
     6d0:	0d01f706 	stceq	7, cr15, [r1, #-24]	@ 0xffffffe8
     6d4:	0000010b 	andeq	r0, r0, fp, lsl #2
     6d8:	00000580 	andeq	r0, r0, r0, lsl #11
     6dc:	00021708 	andeq	r1, r2, r8, lsl #14
     6e0:	7c190000 	ldcvc	0, cr0, [r9], {-0}
     6e4:	b900000a 	stmdblt	r0, {r1, r3}
     6e8:	00059101 	andeq	r9, r5, r1, lsl #2
     6ec:	04430800 	strbeq	r0, [r3], #-2048	@ 0xfffff800
     6f0:	19000000 	stmdbne	r0, {}	@ <UNPREDICTABLE>
     6f4:	00000a9a 	muleq	r0, sl, sl
     6f8:	05a701d1 	streq	r0, [r7, #465]!	@ 0x1d1
     6fc:	43080000 	movwmi	r0, #32768	@ 0x8000
     700:	08000004 	stmdaeq	r0, {r2}
     704:	00000217 	andeq	r0, r0, r7, lsl r2
     708:	0be61a00 	bleq	ff986f10 <__StackTop+0xdf984f10>
     70c:	ec080000 	stc	0, cr0, [r8], {-0}
     710:	015a2c06 	cmpeq	sl, r6, lsl #24
     714:	e5080000 	str	r0, [r8, #-0]
     718:	0000f50c 	andeq	pc, r0, ip, lsl #10
     71c:	01481a00 	cmpeq	r8, r0, lsl #20
     720:	74020000 	strvc	r0, [r2], #-0
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     724:	03311a0d 	teqeq	r1, #53248	@ 0xd000
     728:	73020000 	movwvc	r0, #8192	@ 0x2000
     72c:	06fd1b0d 	ldrbteq	r1, [sp], sp, lsl #22
     730:	8d080000 	stchi	0, cr0, [r8, #-0]
                                xYieldPendings[ xCoreID ] = pdTRUE;
     734:	00036817 	andeq	r6, r3, r7, lsl r8
     738:	0005eb00 	andeq	lr, r5, r0, lsl #22
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     73c:	03680800 	cmneq	r8, #0, 16
     740:	c3080000 	movwgt	r0, #32768	@ 0x8000
     744:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
                    if( pxTCB != NULL )
     748:	0000007f 	andeq	r0, r0, pc, ror r0
                        prvResetNextTaskUnblockTime();
     74c:	09111900 	ldmdbeq	r1, {r8, fp, ip}
                        TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
     750:	01c40000 	biceq	r0, r4, r0
     754:	000005fc 	strdeq	r0, [r0], -ip
                        if( xPendedCounts > ( TickType_t ) 0U )
     758:	00021708 	andeq	r1, r2, r8, lsl #14
                                if( xTaskIncrementTick() != pdFALSE )
     75c:	a82d0000 	stmdage	sp!, {}	@ <UNPREDICTABLE>
     760:	08000009 	stmdaeq	r0, {r0, r3}
     764:	060e06c0 	streq	r0, [lr], -r0, asr #13
                                    xYieldPendings[ xCoreID ] = pdTRUE;
     768:	7f080000 	svcvc	0x00080000
     76c:	00000000 	andeq	r0, r0, r0
                                --xPendedCounts;
     770:	0001131b 	andeq	r1, r1, fp, lsl r3
     774:	09210900 	stmdbeq	r1!, {r8, fp}
                            } while( xPendedCounts > ( TickType_t ) 0U );
     778:	0000007f 	andeq	r0, r0, pc, ror r0
                            xPendedTicks = 0;
     77c:	0000062e 	andeq	r0, r0, lr, lsr #12
     780:	00007f08 	andeq	r7, r0, r8, lsl #30
                    if( xYieldPendings[ xCoreID ] != pdFALSE )
     784:	00390800 	eorseq	r0, r9, r0, lsl #16
     788:	26080000 	strcs	r0, [r8], -r0
     78c:	00000000 	andeq	r0, r0, r0
                            xAlreadyYielded = pdTRUE;
     790:	000bd91b 	andeq	sp, fp, fp, lsl r9
                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
     794:	08bd0800 	ldmfdeq	sp!, {fp}
     798:	0000007f 	andeq	r0, r0, pc, ror r0
     79c:	00000644 	andeq	r0, r0, r4, asr #12
     7a0:	00002608 	andeq	r2, r0, r8, lsl #12
     7a4:	a1140000 	tstge	r4, r0
        taskEXIT_CRITICAL();
     7a8:	6a000004 	bvs	7c0 <xTaskResumeAll+0x1d8>
}
     7ac:	1a3c0622 	bne	f0203c <xNumberOfSuccessfulFrees+0xefd3c0>
     7b0:	00940000 	addseq	r0, r4, r0
     7b4:	9c010000 	stcls	0, cr0, [r1], {-0}
     7b8:	0000066a 	andeq	r0, r0, sl, ror #12
     7bc:	00012501 	andeq	r2, r1, r1, lsl #10
     7c0:	10226c00 	eorne	r6, r2, r0, lsl #24
     7c4:	000000f5 	strdeq	r0, [r0], -r5
     7c8:	00749102 	rsbseq	r9, r4, r2, lsl #2
     7cc:	000b2215 	andeq	r2, fp, r5, lsl r2
     7d0:	0d218300 	stceq	3, cr8, [r1, #-0]
     7d4:	00001990 	muleq	r0, r0, r9
{
     7d8:	000000ac 	andeq	r0, r0, ip, lsr #1
     7dc:	06db9c01 	ldrbeq	r9, [fp], r1, lsl #24
        xTicks = xTickCount;
     7e0:	8d020000 	stchi	0, cr0, [r2, #-0]
    return xTicks;
     7e4:	8300000a 	movwhi	r0, #10
}
     7e8:	01213821 			@ <UNDEFINED> instruction: 0x01213821
     7ec:	91020000 	mrsls	r0, (UNDEF: 2)
     7f0:	0a1b0264 	beq	6c1188 <xNumberOfSuccessfulFrees+0x6bc50c>
{
     7f4:	21840000 	orrcs	r0, r4, r0
     7f8:	0001063e 	andeq	r0, r1, lr, lsr r6
    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
     7fc:	60910200 	addsvs	r0, r1, r0, lsl #4
        xReturn = xTickCount;
     800:	000b7901 	andeq	r7, fp, r1, lsl #18
    return xReturn;
     804:	10218600 	eorne	r8, r1, r0, lsl #12
}
     808:	00000121 	andeq	r0, r0, r1, lsr #2
     80c:	01689102 	cmneq	r8, r2, lsl #2
     810:	0000053a 	andeq	r0, r0, sl, lsr r5
{
     814:	32162187 	andscc	r2, r6, #-1073741791	@ 0xc0000021
    return uxCurrentNumberOfTasks;
     818:	02000001 	andeq	r0, r0, #1
}
     81c:	fb017491 	blx	5da6a <xNumberOfSuccessfulFrees+0x58dee>
     820:	88000001 	stmdahi	r0, {r0}
     824:	04431421 	strbeq	r1, [r3], #-1057	@ 0xfffffbdf
{
     828:	91020000 	mrsls	r0, (UNDEF: 2)
     82c:	0c3d0170 	ldfeqs	f0, [sp], #-448	@ 0xfffffe40
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     830:	21890000 	orrcs	r0, r9, r0
     834:	00044314 	andeq	r4, r4, r4, lsl r3
     838:	6c910200 	lfmvs	f0, 4, [r1], {0}
     83c:	07250c00 	streq	r0, [r5, -r0, lsl #24]!
    return &( pxTCB->pcTaskName[ 0 ] );
     840:	20bc0000 	adcscs	r0, ip, r0
}
     844:	0000b20e 	andeq	fp, r0, lr, lsl #4
     848:	00193000 	andseq	r3, r9, r0
     84c:	00006000 	andeq	r6, r0, r0
     850:	419c0100 	orrsmi	r0, ip, r0, lsl #2
{
     854:	02000007 	andeq	r0, r0, #7
     858:	000008a0 	andeq	r0, r0, r0, lsr #17
    vTaskSuspendAll();
     85c:	2d3a20bc 	ldccs	0, cr2, [sl, #-752]!	@ 0xfffffd10
    taskENTER_CRITICAL();
     860:	02000002 	andeq	r0, r0, #2
        xPendedTicks += xTicksToCatchUp;
     864:	63026c91 	movwvs	r6, #11409	@ 0x2c91
     868:	bd000003 	stclt	0, cr0, [r0, #-12]
     86c:	010b3920 	tsteq	fp, r0, lsr #18
    taskEXIT_CRITICAL();
     870:	91020000 	mrsls	r0, (UNDEF: 2)
    xYieldOccurred = xTaskResumeAll();
     874:	02450268 	subeq	r0, r5, #104, 4	@ 0x80000006
     878:	20be0000 	adcscs	r0, lr, r0
}
     87c:	0000b236 	andeq	fp, r0, r6, lsr r2
     880:	64910200 	ldrvs	r0, [r1], #512	@ 0x200
     884:	000b9401 	andeq	r9, fp, r1, lsl #8
{
     888:	1120c000 			@ <UNDEFINED> instruction: 0x1120c000
     88c:	000003d7 	ldrdeq	r0, [r0], -r7
    BaseType_t xSwitchRequired = pdFALSE;
     890:	01749102 	cmneq	r4, r2, lsl #2
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     894:	0000071c 	andeq	r0, r0, ip, lsl r7
     898:	b21220c1 	andslt	r2, r2, #193	@ 0xc1
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     89c:	02000000 	andeq	r0, r0, #0
     8a0:	0c007091 	stceq	0, cr7, [r0], {145}	@ 0x91
        xTickCount = xConstTickCount;
     8a4:	00000b9a 	muleq	r0, sl, fp
     8a8:	f5102095 			@ <UNDEFINED> instruction: 0xf5102095
        if( xConstTickCount == ( TickType_t ) 0U )
     8ac:	d8000000 	stmdale	r0, {}	@ <UNPREDICTABLE>
            taskSWITCH_DELAYED_LISTS();
     8b0:	58000018 	stmdapl	r0, {r3, r4}
     8b4:	01000000 	mrseq	r0, (UNDEF: 0)
     8b8:	0007989c 	muleq	r7, ip, r8
     8bc:	08a00200 	stmiaeq	r0!, {r9}
     8c0:	20950000 	addscs	r0, r5, r0
     8c4:	00022d3b 	andeq	r2, r2, fp, lsr sp
     8c8:	6c910200 	lfmvs	f0, 4, [r1], {0}
     8cc:	00036302 	andeq	r6, r3, r2, lsl #6
     8d0:	3a209600 	bcc	8260d8 <xNumberOfSuccessfulFrees+0x82145c>
        if( xConstTickCount >= xNextTaskUnblockTime )
     8d4:	0000010b 	andeq	r0, r0, fp, lsl #2
     8d8:	01689102 	cmneq	r8, r2, lsl #2
     8dc:	00000b94 	muleq	r0, r4, fp
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     8e0:	d7112098 			@ <UNDEFINED> instruction: 0xd7112098
     8e4:	02000003 	andeq	r0, r0, #3
                    xNextTaskUnblockTime = portMAX_DELAY;
     8e8:	14017091 	strne	r7, [r1], #-145	@ 0xffffff6f
     8ec:	99000007 	stmdbls	r0, {r0, r1, r2}
                    break;
     8f0:	00f51420 	rscseq	r1, r5, r0, lsr #8
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     8f4:	91020000 	mrsls	r0, (UNDEF: 2)
     8f8:	3f140074 	svccc	0x00140074
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     8fc:	1100000a 	tstne	r0, sl
     900:	171c0a20 	ldrne	r0, [ip, -r0, lsr #20]
                    if( xConstTickCount < xItemValue )
     904:	01bc0000 			@ <UNDEFINED> instruction: 0x01bc0000
     908:	9c010000 	stcls	0, cr0, [r1], {-0}
                        xNextTaskUnblockTime = xItemValue;
     90c:	0000089d 	muleq	r0, sp, r8
                        break;
     910:	00089202 	andeq	r9, r8, r2, lsl #4
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
     914:	36201100 	strtcc	r1, [r0], -r0, lsl #2
     918:	0000022d 	andeq	r0, r0, sp, lsr #4
     91c:	024c9102 	subeq	r9, ip, #-2147483648	@ 0x80000000
     920:	00000bff 	strdeq	r0, [r0], -pc	@ <UNPREDICTABLE>
     924:	0b352012 	bleq	d48974 <xNumberOfSuccessfulFrees+0xd43cf8>
     928:	02000001 	andeq	r0, r0, #1
     92c:	c4024891 	strgt	r4, [r2], #-2193	@ 0xfffff76f
     930:	13000001 	movwne	r0, #1
     934:	089d3620 	ldmeq	sp, {r5, r9, sl, ip, sp}
     938:	91020000 	mrsls	r0, (UNDEF: 2)
     93c:	0b940144 	bleq	fe500e54 <__StackTop+0xde4fee54>
     940:	20150000 	andscs	r0, r5, r0
     944:	0003d711 	andeq	sp, r3, r1, lsl r7
     948:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
     94c:	00027e01 	andeq	r7, r2, r1, lsl #28
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     950:	11201600 			@ <UNDEFINED> instruction: 0x11201600
     954:	000000a1 	andeq	r0, r0, r1, lsr #1
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
     958:	016f9102 	cmneq	pc, r2, lsl #2
     95c:	00000379 	andeq	r0, r0, r9, ror r3
     960:	0b152017 	bleq	5489c4 <xNumberOfSuccessfulFrees+0x543d48>
     964:	02000001 	andeq	r0, r0, #1
     968:	8e037091 	mcrhi	0, 0, r7, cr3, cr1, {4}
     96c:	3e000017 	mcrcc	0, 0, r0, cr0, cr7, {0}
     970:	25000000 	strcs	r0, [r0, #-0]
     974:	01000008 	tsteq	r0, r8
     978:	00000bf8 	strdeq	r0, [r0], -r8
     97c:	43152049 	tstmi	r5, #73	@ 0x49
     980:	02000004 	andeq	r0, r0, #4
     984:	03006491 	movweq	r6, #1169	@ 0x491
     988:	000017de 	ldrdeq	r1, [r0], -lr
     98c:	00000070 	andeq	r0, r0, r0, ror r0
     990:	00000842 	andeq	r0, r0, r2, asr #16
     994:	00022701 	andeq	r2, r2, r1, lsl #14
                    prvAddTaskToReadyList( pxTCB );
     998:	15204a00 	strne	r4, [r0, #-2560]!	@ 0xfffff600
     99c:	00000217 	andeq	r0, r0, r7, lsl r2
     9a0:	00609102 	rsbeq	r9, r0, r2, lsl #2
     9a4:	00185003 	andseq	r5, r8, r3
     9a8:	00003800 	andeq	r3, r0, r0, lsl #16
     9ac:	00085f00 	andeq	r5, r8, r0, lsl #30
     9b0:	02270100 	eoreq	r0, r7, #0, 2
     9b4:	20600000 	rsbcs	r0, r0, r0
     9b8:	00021715 	andeq	r1, r2, r5, lsl r7
     9bc:	68910200 	ldmvs	r1, {r9}
     9c0:	15971e00 	ldrne	r1, [r7, #3584]	@ 0xe00
     9c4:	172c0000 	strne	r0, [ip, -r0]!
     9c8:	001a0000 	andseq	r0, sl, r0
     9cc:	20350000 	eorscs	r0, r5, r0
     9d0:	00000883 	andeq	r0, r0, r3, lsl #17
     9d4:	0015a80f 	andseq	sl, r5, pc, lsl #16
     9d8:	5c910200 	lfmpl	f0, 4, [r1], {0}
     9dc:	0015b30f 	andseq	fp, r5, pc, lsl #6
     9e0:	58910200 	ldmpl	r1, {r9}
     9e4:	15811600 	strne	r1, [r1, #1536]	@ 0x600
     9e8:	18ac0000 	stmiane	ip!, {}	@ <UNPREDICTABLE>
     9ec:	00080000 	andeq	r0, r8, r0
     9f0:	208b0000 	addcs	r0, fp, r0
     9f4:	158b1c09 	strne	r1, [fp, #3081]	@ 0xc09
     9f8:	91020000 	mrsls	r0, (UNDEF: 2)
     9fc:	04000054 	streq	r0, [r0], #-84	@ 0xffffffac
     a00:	000000f5 	strdeq	r0, [r0], -r5
     a04:	0002a90e 	andeq	sl, r2, lr, lsl #18
     a08:	101f5b00 	andsne	r5, pc, r0, lsl #22
     a0c:	000000f5 	strdeq	r0, [r0], -r5
     a10:	000014d0 	ldrdeq	r1, [r0], -r0
     a14:	0000024c 	andeq	r0, r0, ip, asr #4
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     a18:	09e79c01 	stmibeq	r7!, {r0, sl, fp, ip, pc}^
     a1c:	92020000 	andls	r0, r2, #0
     a20:	5b000008 	blpl	a48 <xTaskIncrementTick+0x1c0>
     a24:	022d381f 	eoreq	r3, sp, #2031616	@ 0x1f0000
                                xSwitchRequired = pdTRUE;
     a28:	91020000 	mrsls	r0, (UNDEF: 2)
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     a2c:	0bff024c 	bleq	fffc1364 <__StackTop+0xdffbf364>
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > 1U )
     a30:	1f5c0000 	svcne	0x005c0000
     a34:	00010b37 	andeq	r0, r1, r7, lsr fp
     a38:	48910200 	ldmmi	r1, {r9}
     a3c:	00098b02 	andeq	r8, r9, r2, lsl #22
     a40:	341f5d00 	ldrcc	r5, [pc], #-3328	@ a48 <xTaskIncrementTick+0x1c0>
     a44:	000000b2 	strheq	r0, [r0], -r2
                    xSwitchRequired = pdTRUE;
     a48:	02449102 	subeq	r9, r4, #-2147483648	@ 0x80000000
                if( xYieldPendings[ 0 ] != pdFALSE )
     a4c:	00000842 	andeq	r0, r0, r2, asr #16
     a50:	e2391f5e 	eors	r1, r9, #376	@ 0x178
                    xSwitchRequired = pdTRUE;
     a54:	02000002 	andeq	r0, r0, #2
        xPendedTicks += 1U;
     a58:	ad024391 	stcge	3, cr4, [r2, #-580]	@ 0xfffffdbc
     a5c:	5f000007 	svcpl	0x00000007
     a60:	09e7361f 	stmibeq	r7!, {r0, r1, r2, r3, r4, r9, sl, ip, sp}^
}
     a64:	91020000 	mrsls	r0, (UNDEF: 2)
     a68:	01c40200 	biceq	r0, r4, r0, lsl #4
     a6c:	1f600000 	svcne	0x00600000
     a70:	00089d38 	andeq	r9, r8, r8, lsr sp
     a74:	04910200 	ldreq	r0, [r1], #512	@ 0x200
     a78:	000b9401 	andeq	r9, fp, r1, lsl #8
     a7c:	111f6200 	tstne	pc, r0, lsl #4
     a80:	000003d7 	ldrdeq	r0, [r0], -r7
     a84:	01709102 	cmneq	r0, r2, lsl #2
     a88:	0000027e 	andeq	r0, r0, lr, ror r2
     a8c:	a1111f63 	tstge	r1, r3, ror #30
     a90:	02000000 	andeq	r0, r0, #0
     a94:	14016b91 	strne	r6, [r1], #-2961	@ 0xfffff46f
    {
     a98:	64000007 	strvs	r0, [r0], #-7
     a9c:	00f5141f 	rscseq	r1, r5, pc, lsl r4
        if( uxSchedulerSuspended != ( UBaseType_t ) 0U )
     aa0:	91020000 	mrsls	r0, (UNDEF: 2)
     aa4:	03790174 	cmneq	r9, #116, 2
            xYieldPendings[ 0 ] = pdTRUE;
     aa8:	1f650000 	svcne	0x00650000
    }
     aac:	00010b15 	andeq	r0, r1, r5, lsl fp
            xYieldPendings[ 0 ] = pdFALSE;
     ab0:	6c910200 	lfmvs	f0, 4, [r1], {0}
            taskSELECT_HIGHEST_PRIORITY_TASK();
     ab4:	0015d003 	andseq	sp, r5, r3
     ab8:	00003e00 	andeq	r3, r0, r0, lsl #28
        __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
     abc:	00096f00 	andeq	r6, r9, r0, lsl #30
     ac0:	0bf80100 	bleq	ffe00ec8 <__StackTop+0xdfdfeec8>
     ac4:	1fc30000 	svcne	0x00c30000
     ac8:	00044315 	andeq	r4, r4, r5, lsl r3
     acc:	60910200 	addsvs	r0, r1, r0, lsl #4
     ad0:	16200300 	strtne	r0, [r0], -r0, lsl #6
     ad4:	00700000 	rsbseq	r0, r0, r0
     ad8:	098c0000 	stmibeq	ip, {}	@ <UNPREDICTABLE>
     adc:	27010000 	strcs	r0, [r1, -r0]
     ae0:	c4000002 	strgt	r0, [r0], #-2
     ae4:	0217151f 	andseq	r1, r7, #130023424	@ 0x7c00000
     ae8:	91020000 	mrsls	r0, (UNDEF: 2)
     aec:	9203005c 	andls	r0, r3, #92	@ 0x5c
     af0:	38000016 	stmdacc	r0, {r1, r2, r4}
     af4:	a9000000 	stmdbge	r0, {}	@ <UNPREDICTABLE>
     af8:	01000009 	tsteq	r0, r9
     afc:	00000227 	andeq	r0, r0, r7, lsr #4
     b00:	17151fda 			@ <UNDEFINED> instruction: 0x17151fda
            portTASK_SWITCH_HOOK( pxCurrentTCB );
     b04:	02000002 	andeq	r0, r0, #2
    }
     b08:	1e006491 	mcrne	4, 0, r6, cr0, cr1, {4}
     b0c:	00001597 	muleq	r0, r7, r5
     b10:	000014e6 	andeq	r1, r0, r6, ror #9
     b14:	0000001a 	andeq	r0, r0, sl, lsl r0
     b18:	09cd1f83 	stmibeq	sp, {r0, r1, r7, r8, r9, sl, fp, ip}^
     b1c:	a80f0000 	stmdage	pc, {}	@ <UNPREDICTABLE>
     b20:	02000015 	andeq	r0, r0, #21
{
     b24:	b30f5891 	movwlt	r5, #63633	@ 0xf891
     b28:	02000015 	andeq	r0, r0, #21
     b2c:	16005491 			@ <UNDEFINED> instruction: 0x16005491
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     b30:	00001581 	andeq	r1, r0, r1, lsl #11
     b34:	000016ee 	andeq	r1, r0, lr, ror #13
     b38:	00000008 	andeq	r0, r0, r8
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b3c:	1c092005 	stcne	0, cr2, [r9], {5}
     b40:	0000158b 	andeq	r1, r0, fp, lsl #11
}
     b44:	00509102 	subseq	r9, r0, r2, lsl #2
     b48:	00b20400 	adcseq	r0, r2, r0, lsl #8
     b4c:	c60c0000 	strgt	r0, [ip], -r0
{
     b50:	e3000003 	movw	r0, #3
     b54:	00f5101e 	rscseq	r1, r5, lr, lsl r0
     b58:	12fc0000 	rscsne	r0, ip, #0
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     b5c:	01d40000 	bicseq	r0, r4, r0
     b60:	9c010000 	stcls	0, cr0, [r1], {-0}
     b64:	00000ab5 			@ <UNDEFINED> instruction: 0x00000ab5
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     b68:	00089202 	andeq	r9, r8, r2, lsl #4
     b6c:	311ee300 	tstcc	lr, r0, lsl #6
     b70:	0000022d 	andeq	r0, r0, sp, lsr #4
     b74:	025c9102 	subseq	r9, ip, #-2147483648	@ 0x80000000
     b78:	00000bff 	strdeq	r0, [r0], -pc	@ <UNPREDICTABLE>
     b7c:	0b301ee4 	bleq	c08714 <xNumberOfSuccessfulFrees+0xc03a98>
     b80:	02000001 	andeq	r0, r0, #1
     b84:	8b025891 	blhi	96dd0 <xNumberOfSuccessfulFrees+0x92154>
     b88:	e5000009 	str	r0, [r0, #-9]
     b8c:	00b22d1e 	adcseq	r2, r2, lr, lsl sp
     b90:	91020000 	mrsls	r0, (UNDEF: 2)
     b94:	08420254 	stmdaeq	r2, {r2, r4, r6, r9}^
     b98:	1ee60000 	cdpne	0, 14, cr0, cr6, cr0, {0}
     b9c:	0002e232 	andeq	lr, r2, r2, lsr r2
     ba0:	53910200 	orrspl	r0, r1, #0, 4
     ba4:	0007ad02 	andeq	sl, r7, r2, lsl #26
     ba8:	2f1ee700 	svccs	0x001ee700
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     bac:	000009e7 	andeq	r0, r0, r7, ror #19
     bb0:	01009102 	tsteq	r0, r2, lsl #2
}
     bb4:	00000b94 	muleq	r0, r4, fp
     bb8:	d7111ee9 	ldrle	r1, [r1, -r9, ror #29]
     bbc:	02000003 	andeq	r0, r0, #3
{
     bc0:	14017091 	strne	r7, [r1], #-145	@ 0xffffff6f
     bc4:	ea000007 	b	be8 <xTaskRemoveFromEventList+0x28>
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     bc8:	00f5141e 	rscseq	r1, r5, lr, lsl r4
     bcc:	91020000 	mrsls	r0, (UNDEF: 2)
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
     bd0:	027e0174 	rsbseq	r0, lr, #116, 2
     bd4:	1eeb0000 	cdpne	0, 14, cr0, cr11, cr0, {0}
     bd8:	0000a111 	andeq	sl, r0, r1, lsl r1
     bdc:	6f910200 	svcvs	0x00910200
     be0:	0013d203 	andseq	sp, r3, r3, lsl #4
     be4:	00003e00 	andeq	r3, r0, r0, lsl #28
     be8:	000a9b00 	andeq	r9, sl, r0, lsl #22
     bec:	0bf80100 	bleq	ffe00ff4 <__StackTop+0xdfdfeff4>
     bf0:	1f300000 	svcne	0x00300000
     bf4:	00044311 	andeq	r4, r4, r1, lsl r3
     bf8:	68910200 	ldmvs	r1, {r9}
     bfc:	14220900 	strtne	r0, [r2], #-2304	@ 0xfffff700
     c00:	00700000 	rsbseq	r0, r0, r0
     c04:	27010000 	strcs	r0, [r1, -r0]
     c08:	31000002 	tstcc	r0, r2
     c0c:	0217111f 	andseq	r1, r7, #-1073741817	@ 0xc0000007
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     c10:	91020000 	mrsls	r0, (UNDEF: 2)
     c14:	0c000064 	stceq	0, cr0, [r0], {100}	@ 0x64
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
     c18:	00000610 	andeq	r0, r0, r0, lsl r6
     c1c:	f5101e71 			@ <UNDEFINED> instruction: 0xf5101e71
     c20:	d8000000 	stmdale	r0, {}	@ <UNPREDICTABLE>
     c24:	24000011 	strcs	r0, [r0], #-17	@ 0xffffffef
     c28:	01000001 	tsteq	r0, r1
     c2c:	000b489c 	muleq	fp, ip, r8
     c30:	0c530200 	lfmeq	f0, 2, [r3], {-0}
     c34:	1e710000 	cdpne	0, 7, cr0, cr1, cr0, {0}
     c38:	00010b34 	andeq	r0, r1, r4, lsr fp
     c3c:	64910200 	ldrvs	r0, [r1], #512	@ 0x200
     c40:	00044502 	andeq	r4, r4, r2, lsl #10
     c44:	311e7200 	tstcc	lr, r0, lsl #4
     c48:	000000b2 	strheq	r0, [r0], -r2
     c4c:	02609102 	rsbeq	r9, r0, #-2147483648	@ 0x80000000
     c50:	00000199 	muleq	r0, r9, r1
        prvAddTaskToReadyList( pxUnblockedTCB );
     c54:	b2311e73 	eorslt	r1, r1, #1840	@ 0x730
     c58:	02000000 	andeq	r0, r0, #0
     c5c:	ce025c91 	mcrgt	12, 0, r5, cr2, cr1, {4}
     c60:	74000009 	strvc	r0, [r0], #-9
     c64:	09e7331e 	stmibeq	r7!, {r1, r2, r3, r4, r8, r9, ip, sp}^
     c68:	91020000 	mrsls	r0, (UNDEF: 2)
     c6c:	0a8d0258 	beq	fe3415d4 <__StackTop+0xde33f5d4>
     c70:	1e750000 	cdpne	0, 7, cr0, cr5, cr0, {0}
     c74:	00012133 	andeq	r2, r1, r3, lsr r1
     c78:	00910200 	addseq	r0, r1, r0, lsl #4
     c7c:	00071401 	andeq	r1, r7, r1, lsl #8
     c80:	141e7700 	ldrne	r7, [lr], #-1792	@ 0xfffff900
     c84:	000000f5 	strdeq	r0, [r0], -r5
     c88:	01749102 	cmneq	r4, r2, lsl #2
     c8c:	00000ac2 	andeq	r0, r0, r2, asr #21
     c90:	f51d1e77 			@ <UNDEFINED> instruction: 0xf51d1e77
     c94:	02000000 	andeq	r0, r0, #0
     c98:	fa016c91 	blx	5bee4 <xNumberOfSuccessfulFrees+0x57268>
     c9c:	77000008 	strvc	r0, [r0, -r8]
     ca0:	00f52e1e 	rscseq	r2, r5, lr, lsl lr
     ca4:	91020000 	mrsls	r0, (UNDEF: 2)
     ca8:	3c0c0070 	stccc	0, cr0, [ip], {112}	@ 0x70
     cac:	0b000006 	bleq	ccc <xTaskRemoveFromEventList+0x10c>
     cb0:	00b20e1e 	adcseq	r0, r2, lr, lsl lr
     cb4:	10e80000 	rscne	r0, r8, r0
     cb8:	00f00000 	rscseq	r0, r0, r0
     cbc:	9c010000 	stcls	0, cr0, [r1], {-0}
     cc0:	00000bbd 			@ <UNDEFINED> instruction: 0x00000bbd
     cc4:	000c5302 	andeq	r5, ip, r2, lsl #6
     cc8:	331e0b00 	tstcc	lr, #0, 22
     ccc:	0000010b 	andeq	r0, r0, fp, lsl #2
     cd0:	02649102 	rsbeq	r9, r4, #-2147483648	@ 0x80000000
     cd4:	000003e8 	andeq	r0, r0, r8, ror #7
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     cd8:	f5321e0c 			@ <UNDEFINED> instruction: 0xf5321e0c
     cdc:	02000000 	andeq	r0, r0, #0
     ce0:	8d026091 	stchi	0, cr6, [r2, #-580]	@ 0xfffffdbc
     ce4:	0d00000a 	stceq	0, cr0, [r0, #-40]	@ 0xffffffd8
     ce8:	0121321e 			@ <UNDEFINED> instruction: 0x0121321e
     cec:	91020000 	mrsls	r0, (UNDEF: 2)
     cf0:	071c015c 			@ <UNDEFINED> instruction: 0x071c015c
     cf4:	1e0f0000 	cdpne	0, 0, cr0, cr15, cr0, {0}
     cf8:	0000b212 	andeq	fp, r0, r2, lsl r2
     cfc:	6c910200 	lfmvs	f0, 4, [r1], {0}
     d00:	000ac201 	andeq	ip, sl, r1, lsl #4
     d04:	141e1000 	ldrne	r1, [lr], #-0
     d08:	000000f5 	strdeq	r0, [r0], -r5
     d0c:	01709102 	cmneq	r0, r2, lsl #2
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     d10:	000008fa 	strdeq	r0, [r0], -sl
     d14:	f5251e10 			@ <UNDEFINED> instruction: 0xf5251e10
     d18:	02000000 	andeq	r0, r0, #0
     d1c:	0e007491 	mcreq	4, 0, r7, cr0, cr1, {4}
            xReturn = pdTRUE;
     d20:	00000859 	andeq	r0, r0, r9, asr r8
            xYieldPendings[ 0 ] = pdTRUE;
     d24:	210c1dde 	ldrdcs	r1, [ip, -lr]
     d28:	b8000001 	stmdalt	r0, {r0}
            xReturn = pdFALSE;
     d2c:	30000010 	andcc	r0, r0, r0, lsl r0
}
     d30:	01000000 	mrseq	r0, (UNDEF: 0)
     d34:	000be79c 	muleq	fp, ip, r7
     d38:	07130100 	ldreq	r0, [r3, -r0, lsl #2]
     d3c:	1de00000 	stclne	0, cr0, [r0]
     d40:	00012110 	andeq	r2, r1, r0, lsl r1
     d44:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
     d48:	0b410e00 	bleq	1044550 <xNumberOfSuccessfulFrees+0x103f8d4>
     d4c:	19ae0000 	stmibne	lr!, {}	@ <UNPREDICTABLE>
     d50:	00022d12 	andeq	r2, r2, r2, lsl sp
{
     d54:	00108800 	andseq	r8, r0, r0, lsl #16
     d58:	00003000 	andeq	r3, r0, r0
     d5c:	209c0100 	addscs	r0, ip, r0, lsl #2
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     d60:	0200000c 	andeq	r0, r0, #12
     d64:	00000125 	andeq	r0, r0, r5, lsr #2
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem );
     d68:	f53f19ae 			@ <UNDEFINED> instruction: 0xf53f19ae
     d6c:	02000000 	andeq	r0, r0, #0
    listREMOVE_ITEM( pxEventListItem );
     d70:	14016c91 	strne	r6, [r1], #-3217	@ 0xfffff36f
     d74:	b0000007 	andlt	r0, r0, r7
     d78:	022d1619 	eoreq	r1, sp, #26214400	@ 0x1900000
     d7c:	91020000 	mrsls	r0, (UNDEF: 2)
     d80:	d20e0074 	andle	r0, lr, #116	@ 0x74
     d84:	8b00000a 	blhi	db4 <vTaskRemoveFromUnorderedEventList+0x60>
     d88:	022d1619 	eoreq	r1, sp, #26214400	@ 0x1900000
     d8c:	106c0000 	rsbne	r0, ip, r0
     d90:	001c0000 	andseq	r0, ip, r0
     d94:	9c010000 	stcls	0, cr0, [r1], {-0}
     d98:	00000c4a 	andeq	r0, r0, sl, asr #24
     d9c:	00071401 	andeq	r1, r7, r1, lsl #8
     da0:	1a198d00 	bne	6641a8 <xNumberOfSuccessfulFrees+0x65f52c>
     da4:	0000022d 	andeq	r0, r0, sp, lsr #4
     da8:	00749102 	rsbseq	r9, r4, r2, lsl #2
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
     dac:	00076b1f 	andeq	r6, r7, pc, lsl fp
     db0:	38197300 	ldmdacc	r9, {r8, r9, ip, sp, lr}
     db4:	34000010 	strcc	r0, [r0], #-16
     db8:	01000000 	mrseq	r0, (UNDEF: 0)
     dbc:	0c1d1f9c 	ldceq	15, cr1, [sp], {156}	@ 0x9c
     dc0:	17d30000 	ldrbne	r0, [r3, r0]
     dc4:	0000102c 	andeq	r1, r0, ip, lsr #32
     dc8:	0000000c 	andeq	r0, r0, ip
     dcc:	7f159c01 	svcvc	0x00159c01
     dd0:	b3000004 	movwlt	r0, #4
     dd4:	0fc00d17 	svceq	0x00c00d17
     dd8:	006c0000 	rsbeq	r0, ip, r0
     ddc:	9c010000 	stcls	0, cr0, [r1], {-0}
     de0:	00000c92 	muleq	r0, r2, ip
     de4:	00016e01 	andeq	r6, r1, r1, lsl #28
    prvAddTaskToReadyList( pxUnblockedTCB );
     de8:	1117b500 	tstne	r7, r0, lsl #10
     dec:	0000010b 	andeq	r0, r0, fp, lsl #2
     df0:	00749102 	rsbseq	r9, r4, r2, lsl #2
     df4:	00062715 	andeq	r2, r6, r5, lsl r7
     df8:	0816a900 	ldmdaeq	r6, {r8, fp, sp, pc}
     dfc:	00000f90 	muleq	r0, r0, pc	@ <UNPREDICTABLE>
     e00:	00000030 	andeq	r0, r0, r0, lsr r0
     e04:	0cb89c01 	ldceq	12, cr9, [r8], #4
     e08:	3a020000 	bcc	80e10 <xNumberOfSuccessfulFrees+0x7c194>
     e0c:	a9000009 	stmdbge	r0, {r0, r3}
     e10:	007f0816 	rsbseq	r0, pc, r6, lsl r8	@ <UNPREDICTABLE>
     e14:	91020000 	mrsls	r0, (UNDEF: 2)
     e18:	e3200074 			@ <UNDEFINED> instruction: 0xe3200074
     e1c:	18000009 	stmdane	r0, {r0, r3}
     e20:	000f7816 	andeq	r7, pc, r6, lsl r8	@ <UNPREDICTABLE>
     e24:	00001800 	andeq	r1, r0, r0, lsl #16
     e28:	0c9c0100 	ldfeqs	f0, [ip], {0}
     e2c:	00000993 	muleq	r0, r3, r9
     e30:	f50c15d3 			@ <UNDEFINED> instruction: 0xf50c15d3
     e34:	f4000000 	vst4.8	{d0-d3}, [r0], r0
     e38:	8400000e 	strhi	r0, [r0], #-14
     e3c:	01000000 	mrseq	r0, (UNDEF: 0)
     e40:	000d399c 	muleq	sp, ip, r9
     e44:	07ca0200 	strbeq	r0, [sl, r0, lsl #4]
     e48:	15d30000 	ldrbne	r0, [r3]
     e4c:	000d3e34 	andeq	r3, sp, r4, lsr lr
     e50:	64910200 	ldrvs	r0, [r1], #512	@ 0x200
     e54:	000a8c02 	andeq	r8, sl, r2, lsl #24
     e58:	3515d400 	ldrcc	sp, [r5, #-1024]	@ 0xfffffc00
     e5c:	00000d48 	andeq	r0, r0, r8, asr #26
     e60:	01609102 	cmneq	r0, r2, lsl #2
     e64:	00000714 	andeq	r0, r0, r4, lsl r7
     e68:	f51015d6 			@ <UNDEFINED> instruction: 0xf51015d6
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     e6c:	02000000 	andeq	r0, r0, #0
     e70:	02097491 	andeq	r7, r9, #-1862270976	@ 0x91000000
     e74:	5e00000f 	cdppl	0, 0, cr0, cr0, cr15, {0}
            xYieldPendings[ 0 ] = pdTRUE;
     e78:	01000000 	mrseq	r0, (UNDEF: 0)
     e7c:	0000053a 	andeq	r0, r0, sl, lsr r5
}
     e80:	321a15e0 	andscc	r1, sl, #224, 10	@ 0x38000000
     e84:	02000001 	andeq	r0, r0, #1
     e88:	08017091 	stmdaeq	r1, {r0, r4, r7, ip, sp, lr}
     e8c:	e1000004 	tst	r0, r4
     e90:	01321a15 	teqeq	r2, r5, lsl sl
     e94:	91020000 	mrsls	r0, (UNDEF: 2)
{
     e98:	0400006c 	streq	r0, [r0], #-108	@ 0xffffff94
     e9c:	00000316 	andeq	r0, r0, r6, lsl r3
    taskENTER_CRITICAL();
     ea0:	000d3905 	andeq	r3, sp, r5, lsl #18
        pxTimeOut->xOverflowCount = xNumOfOverflows;
     ea4:	01210400 			@ <UNDEFINED> instruction: 0x01210400
     ea8:	43050000 	movwmi	r0, #20480	@ 0x5000
        pxTimeOut->xTimeOnEntering = xTickCount;
     eac:	1400000d 	strne	r0, [r0], #-13
     eb0:	0000080b 	andeq	r0, r0, fp, lsl #16
    taskEXIT_CRITICAL();
     eb4:	c80615c7 	stmdagt	r6, {r0, r1, r2, r6, r7, r8, sl, ip}
}
     eb8:	2c00000e 	stccs	0, cr0, [r0], {14}
     ebc:	01000000 	mrseq	r0, (UNDEF: 0)
     ec0:	000d739c 	muleq	sp, ip, r3
     ec4:	07ca0200 	strbeq	r0, [sl, r0, lsl #4]
{
     ec8:	15c70000 	strbne	r0, [r7]
     ecc:	000d3e36 	andeq	r3, sp, r6, lsr lr
    pxTimeOut->xOverflowCount = xNumOfOverflows;
     ed0:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
     ed4:	02941700 	addseq	r1, r4, #0, 14
    pxTimeOut->xTimeOnEntering = xTickCount;
     ed8:	15b70000 	ldrne	r0, [r7, #0]!
     edc:	00000e98 	muleq	r0, r8, lr
}
     ee0:	00000030 	andeq	r0, r0, r0, lsr r0
     ee4:	0d989c01 	ldceq	12, cr9, [r8, #4]
     ee8:	ca020000 	bgt	80ef0 <xNumberOfSuccessfulFrees+0x7c274>
     eec:	b7000007 	strlt	r0, [r0, -r7]
     ef0:	0d3e2e15 	ldceq	14, cr2, [lr, #-84]!	@ 0xffffffac
{
     ef4:	91020000 	mrsls	r0, (UNDEF: 2)
     ef8:	a2140074 	andsge	r0, r4, #116	@ 0x74
     efc:	6f000005 	svcvs	0x00000005
    taskENTER_CRITICAL();
     f00:	0d540615 	ldcleq	6, cr0, [r4, #-84]	@ 0xffffffac
        const TickType_t xConstTickCount = xTickCount;
     f04:	01440000 	mrseq	r0, (UNDEF: 68)
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     f08:	9c010000 	stcls	0, cr0, [r1], {-0}
     f0c:	00000e2f 	andeq	r0, r0, pc, lsr #28
     f10:	000aec02 	andeq	lr, sl, r2, lsl #24
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) )
     f14:	36156f00 	ldrcc	r6, [r5], -r0, lsl #30
     f18:	00000212 	andeq	r0, r0, r2, lsl r2
     f1c:	02649102 	rsbeq	r9, r4, #-2147483648	@ 0x80000000
     f20:	00000947 	andeq	r0, r0, r7, asr #18
     f24:	323a1570 	eorscc	r1, sl, #112, 10	@ 0x1c000000
            xReturn = pdTRUE;
     f28:	02000001 	andeq	r0, r0, #1
            *pxTicksToWait = ( TickType_t ) 0;
     f2c:	d9016091 	stmdble	r1, {r0, r4, r7, sp, lr}
     f30:	72000003 	andvc	r0, r0, #3
        else if( xElapsedTime < *pxTicksToWait )
     f34:	03d70d15 	bicseq	r0, r7, #1344	@ 0x540
     f38:	91020000 	mrsls	r0, (UNDEF: 2)
     f3c:	0d6e0374 	stcleq	3, cr0, [lr, #-464]!	@ 0xfffffe30
            *pxTicksToWait -= xElapsedTime;
     f40:	003c0000 	eorseq	r0, ip, r0
     f44:	0df80000 	ldcleq	0, cr0, [r8]
     f48:	f8010000 			@ <UNDEFINED> instruction: 0xf8010000
            vTaskInternalSetTimeOutState( pxTimeOut );
     f4c:	8400000b 	strhi	r0, [r0], #-11
            xReturn = pdFALSE;
     f50:	04430515 	strbeq	r0, [r3], #-1301	@ 0xfffffaeb
     f54:	91020000 	mrsls	r0, (UNDEF: 2)
            *pxTicksToWait = ( TickType_t ) 0;
     f58:	aa030070 	bge	c1120 <xNumberOfSuccessfulFrees+0xbc4a4>
            xReturn = pdTRUE;
     f5c:	3e00000d 	cdpcc	0, 0, cr0, cr0, cr13, {0}
    taskEXIT_CRITICAL();
     f60:	15000000 	strne	r0, [r0, #-0]
    return xReturn;
     f64:	0100000e 	tsteq	r0, lr
}
     f68:	00000bf8 	strdeq	r0, [r0], -r8
     f6c:	43051597 	movwmi	r1, #21911	@ 0x5597
     f70:	02000004 	andeq	r0, r0, #4
     f74:	09006c91 	stmdbeq	r0, {r0, r4, r7, sl, fp, sp, lr}
{
     f78:	00000dfa 	strdeq	r0, [r0], -sl
    xYieldPendings[ portGET_CORE_ID() ] = pdTRUE;
     f7c:	00000070 	andeq	r0, r0, r0, ror r0
     f80:	00022701 	andeq	r2, r2, r1, lsl #14
}
     f84:	05159800 	ldreq	r9, [r5, #-2048]	@ 0xfffff800
     f88:	00000217 	andeq	r0, r0, r7, lsl r2
     f8c:	00689102 	rsbeq	r9, r8, r2, lsl #2
{
     f90:	05c40e00 	strbeq	r0, [r4, #3584]	@ 0xe00
     f94:	15120000 	ldrne	r0, [r2, #-0]
        prvCheckTasksWaitingTermination();
     f98:	0000f50c 	andeq	pc, r0, ip, lsl #10
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) configNUMBER_OF_CORES )
     f9c:	000bc000 	andeq	ip, fp, r0
     fa0:	00019400 	andeq	r9, r1, r0, lsl #8
                taskYIELD();
     fa4:	e79c0100 	ldr	r0, [ip, r0, lsl #2]
     fa8:	0200000e 	andeq	r0, r0, #14
     fac:	00000209 	andeq	r0, r0, r9, lsl #4
     fb0:	ec3b1512 	cfldr32	mvfx1, [fp], #-72	@ 0xffffffb8
        prvCheckTasksWaitingTermination();
     fb4:	0200000e 	andeq	r0, r0, #14
     fb8:	d9015c91 	stmdble	r1, {r0, r4, r7, sl, fp, ip, lr}
     fbc:	14000003 	strne	r0, [r0], #-3
{
     fc0:	03d70d15 	bicseq	r0, r7, #1344	@ 0x540
     fc4:	91020000 	mrsls	r0, (UNDEF: 2)
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
     fc8:	07140170 			@ <UNDEFINED> instruction: 0x07140170
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     fcc:	15150000 	ldrne	r0, [r5, #-0]
     fd0:	0000f510 	andeq	pc, r0, r0, lsl r5	@ <UNPREDICTABLE>
     fd4:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
     fd8:	000bd003 	andeq	sp, fp, r3
     fdc:	00003e00 	andeq	r3, r0, r0, lsl #28
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
     fe0:	000e9300 	andeq	r9, lr, r0, lsl #6
     fe4:	0bf80100 	bleq	ffe013ec <__StackTop+0xdfdff3ec>
     fe8:	152b0000 	strne	r0, [fp, #-0]!
    vListInitialise( &xDelayedTaskList1 );
     fec:	00044305 	andeq	r4, r4, r5, lsl #6
     ff0:	6c910200 	lfmvs	f0, 4, [r1], {0}
    vListInitialise( &xDelayedTaskList2 );
     ff4:	0c160300 	ldceq	3, cr0, [r6], {-0}
    vListInitialise( &xPendingReadyList );
     ff8:	003e0000 	eorseq	r0, lr, r0
     ffc:	0eb00000 	cdpeq	0, 11, cr0, cr0, cr0, {0}
    pxDelayedTaskList = &xDelayedTaskList1;
    1000:	f8010000 			@ <UNDEFINED> instruction: 0xf8010000
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1004:	2f00000b 	svccs	0x0000000b
    1008:	04430915 	strbeq	r0, [r3], #-2325	@ 0xfffff6eb
}
    100c:	91020000 	mrsls	r0, (UNDEF: 2)
    1010:	66030064 	strvs	r0, [r3], -r4, rrx
    1014:	7000000c 	andvc	r0, r0, ip
    1018:	cd000000 	stcgt	0, cr0, [r0, #-0]
    101c:	0100000e 	tsteq	r0, lr
    1020:	00000227 	andeq	r0, r0, r7, lsr #4
    1024:	17091530 	smladxne	r9, r0, r5, r1
    1028:	02000002 	andeq	r0, r0, #2
{
    102c:	09006091 	stmdbeq	r0, {r0, r4, r7, sp, lr}
}
    1030:	00000cd8 	ldrdeq	r0, [r0], -r8
    1034:	00000038 	andeq	r0, r0, r8, lsr r0
{
    1038:	00022701 	andeq	r2, r2, r1, lsl #14
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    103c:	09154400 	ldmdbeq	r5, {sl, lr}
    1040:	00000217 	andeq	r0, r0, r7, lsl r2
    1044:	00689102 	rsbeq	r9, r8, r2, lsl #2
        xNextTaskUnblockTime = portMAX_DELAY;
    1048:	02280400 	eoreq	r0, r8, #0, 8
    104c:	e7050000 	str	r0, [r5, -r0]
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    1050:	1700000e 	strne	r0, [r0, -lr]
    1054:	00000a5d 	andeq	r0, r0, sp, asr sl
    1058:	0b5014cd 	bleq	1406394 <xNumberOfSuccessfulFrees+0x1401718>
}
    105c:	00700000 	rsbseq	r0, r0, r0
    1060:	9c010000 	stcls	0, cr0, [r1], {-0}
    1064:	00000f4d 	andeq	r0, r0, sp, asr #30
    1068:	00020902 	andeq	r0, r2, r2, lsl #18
        {
    106c:	2f14cd00 	svccs	0x0014cd00
    1070:	00000439 	andeq	r0, r0, r9, lsr r4
            xReturn = pxCurrentTCB;
    1074:	026c9102 	rsbeq	r9, ip, #-2147483648	@ 0x80000000
            return xReturn;
    1078:	00000947 	andeq	r0, r0, r7, asr #18
        }
    107c:	323714ce 	eorscc	r1, r7, #-838860800	@ 0xce000000
    1080:	02000001 	andeq	r0, r0, #1
    1084:	8d026891 	stchi	8, cr6, [r2, #-580]	@ 0xfffffdbc
    {
    1088:	cf00000a 	svcgt	0x0000000a
    108c:	01323714 	teqeq	r2, r4, lsl r7
        TaskHandle_t xReturn = NULL;
    1090:	91020000 	mrsls	r0, (UNDEF: 2)
        if( taskVALID_CORE_ID( xCoreID ) != pdFALSE )
    1094:	0b680964 	bleq	1a0362c <xNumberOfSuccessfulFrees+0x19fe9b0>
    1098:	00420000 	subeq	r0, r2, r0
    109c:	27010000 	strcs	r0, [r1, -r0]
                xReturn = pxCurrentTCB;
    10a0:	e3000002 	movw	r0, #2
    10a4:	02170514 	andseq	r0, r7, #20, 10	@ 0x5000000
    }
    10a8:	91020000 	mrsls	r0, (UNDEF: 2)
    10ac:	17000074 	smlsdxne	r0, r4, r0, r0
    10b0:	0000056b 	andeq	r0, r0, fp, ror #10
    10b4:	0b2414b0 	bleq	90637c <xNumberOfSuccessfulFrees+0x901700>
{
    10b8:	002c0000 	eoreq	r0, ip, r0
    10bc:	9c010000 	stcls	0, cr0, [r1], {-0}
    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    10c0:	00000f81 	andeq	r0, r0, r1, lsl #31
    10c4:	00020902 	andeq	r0, r2, r2, lsl #18
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) );
    10c8:	2c14b000 	ldccs	0, cr11, [r4], {-0}
    10cc:	00000443 	andeq	r0, r0, r3, asr #8
    10d0:	02749102 	rsbseq	r9, r4, #-2147483648	@ 0x80000000
    10d4:	00000a8d 	andeq	r0, r0, sp, lsl #21
}
    10d8:	322e14b1 	eorcc	r1, lr, #-1325400064	@ 0xb1000000
    10dc:	02000001 	andeq	r0, r0, #1
    10e0:	14007091 	strne	r7, [r0], #-145	@ 0xffffff6f
    10e4:	000008be 			@ <UNDEFINED> instruction: 0x000008be
    {
    10e8:	980a13f5 	stmdals	sl, {r0, r2, r4, r5, r6, r7, r8, r9, ip}
    10ec:	8c00000a 	stchi	0, cr0, [r0], {10}
    10f0:	01000000 	mrseq	r0, (UNDEF: 0)
        BaseType_t xAlreadyYielded, xShouldBlock = pdFALSE;
    10f4:	000fef9c 	muleq	pc, ip, pc	@ <UNPREDICTABLE>
        if( ( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0U ) && ( xTicksToWait > ( TickType_t ) 0 ) )
    10f8:	0ab40900 	beq	fed03500 <__StackTop+0xded01500>
    10fc:	004e0000 	subeq	r0, lr, r0
    1100:	a6010000 	strge	r0, [r1], -r0
    1104:	2f00000a 	svccs	0x0000000a
    1108:	010b0d14 	tsteq	fp, r4, lsl sp
    110c:	91020000 	mrsls	r0, (UNDEF: 2)
            vTaskSuspendAll();
    1110:	0aca0374 	beq	ff281ee8 <__StackTop+0xdf27fee8>
                taskENTER_CRITICAL();
    1114:	00380000 	eorseq	r0, r8, r0
                    if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0U )
    1118:	0fcc0000 	svceq	0x00cc0000
    111c:	79010000 	stmdbvc	r1, {}	@ <UNPREDICTABLE>
    1120:	2f000001 	svccs	0x00000001
    1124:	04430d14 	strbeq	r0, [r3], #-3348	@ 0xfffff2ec
    1128:	91020000 	mrsls	r0, (UNDEF: 2)
                        pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
    112c:	d5160070 	ldrle	r0, [r6, #-112]	@ 0xffffff90
    1130:	ba000015 	blt	118c <ulTaskGenericNotifyTake+0xa4>
    1134:	0a00000a 	beq	1164 <ulTaskGenericNotifyTake+0x7c>
                        xShouldBlock = pdTRUE;
    1138:	2f000000 	svccs	0x00000000
                taskEXIT_CRITICAL();
    113c:	e21c0d14 	ands	r0, ip, #20, 26	@ 0x500
                if( xShouldBlock == pdTRUE )
    1140:	02000015 	andeq	r0, r0, #21
    1144:	ed0f6c91 	stc	12, cr6, [pc, #-580]	@ f08 <xTaskCheckForTimeOut+0x14>
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1148:	02000015 	andeq	r0, r0, #21
    114c:	00006b91 	muleq	r0, r1, fp
            xAlreadyYielded = xTaskResumeAll();
    1150:	02d20c00 	sbcseq	r0, r2, #0, 24
            if( ( xShouldBlock == pdTRUE ) && ( xAlreadyYielded == pdFALSE ) )
    1154:	12750000 	rsbsne	r0, r5, #0
    1158:	0000f50c 	andeq	pc, r0, ip, lsl #10
    115c:	00088800 	andeq	r8, r8, r0, lsl #16
                taskYIELD_WITHIN_API();
    1160:	00021000 	andeq	r1, r2, r0
    1164:	c09c0100 	addsgt	r0, ip, r0, lsl #2
    1168:	01000010 	tsteq	r0, r0, lsl r0
    116c:	00000b94 	muleq	r0, r4, fp
        taskENTER_CRITICAL();
    1170:	d70d1277 	smlsdxle	sp, r7, r2, r1
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];
    1174:	02000003 	andeq	r0, r0, #3
    1178:	47016891 			@ <UNDEFINED> instruction: 0x47016891
    117c:	78000009 	stmdavc	r0, {r0, r3}
    1180:	01211012 			@ <UNDEFINED> instruction: 0x01211012
            if( ulReturn != 0U )
    1184:	91020000 	mrsls	r0, (UNDEF: 2)
    1188:	09730164 	ldmdbeq	r3!, {r2, r5, r6, r8}^
                if( xClearCountOnExit != pdFALSE )
    118c:	12790000 	rsbsne	r0, r9, #0
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ( uint32_t ) 0U;
    1190:	0000f510 	andeq	pc, r0, r0, lsl r5	@ <UNPREDICTABLE>
    1194:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    1198:	00089c09 	andeq	r9, r8, r9, lsl #24
    119c:	0001bc00 	andeq	fp, r1, r0, lsl #24
    11a0:	053a0100 	ldreq	r0, [sl, #-256]!	@ 0xffffff00
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ulReturn - ( uint32_t ) 1;
    11a4:	128a0000 	addne	r0, sl, #0
    11a8:	0001321a 	andeq	r3, r1, sl, lsl r2
    11ac:	70910200 	addsvc	r0, r1, r0, lsl #4
    11b0:	0008b003 	andeq	fp, r8, r3
            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;
    11b4:	00002200 	andeq	r2, r0, r0, lsl #4
    11b8:	00106b00 	andseq	r6, r0, r0, lsl #22
    11bc:	04b10100 	ldrteq	r0, [r1], #256	@ 0x100
    11c0:	12920000 	addsne	r0, r2, #0
        taskEXIT_CRITICAL();
    11c4:	0004390d 	andeq	r3, r4, sp, lsl #18
    }
    11c8:	6c910200 	lfmvs	f0, 4, [r1], {0}
    11cc:	09120300 	ldmdbeq	r2, {r8, r9}
    11d0:	003e0000 	eorseq	r0, lr, r0
    11d4:	10880000 	addne	r0, r8, r0
    {
    11d8:	f8010000 			@ <UNDEFINED> instruction: 0xf8010000
    11dc:	c700000b 	strgt	r0, [r0, -fp]
    11e0:	04431512 	strbeq	r1, [r3], #-1298	@ 0xfffffaee
    11e4:	91020000 	mrsls	r0, (UNDEF: 2)
        BaseType_t xReturn, xAlreadyYielded, xShouldBlock = pdFALSE;
    11e8:	58030060 	stmdapl	r3, {r5, r6}
        if( ( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED ) && ( xTicksToWait > ( TickType_t ) 0 ) )
    11ec:	3e000009 	cdpcc	0, 0, cr0, cr0, cr9, {0}
    11f0:	a5000000 	strge	r0, [r0, #-0]
    11f4:	01000010 	tsteq	r0, r0, lsl r0
    11f8:	00000bf8 	strdeq	r0, [r0], -r8
    11fc:	431912cd 	tstmi	r9, #-805306356	@ 0xd000000c
    1200:	02000004 	andeq	r0, r0, #4
            vTaskSuspendAll();
    1204:	09005c91 	stmdbeq	r0, {r0, r4, r7, sl, fp, ip, lr}
                taskENTER_CRITICAL();
    1208:	000009a8 	andeq	r0, r0, r8, lsr #19
                    if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )
    120c:	00000070 	andeq	r0, r0, r0, ror r0
    1210:	00022701 	andeq	r2, r2, r1, lsl #14
    1214:	1512d600 	ldrne	sp, [r2, #-1536]	@ 0xfffffa00
    1218:	00000217 	andeq	r0, r0, r7, lsl r2
                        pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnEntry;
    121c:	00589102 	subseq	r9, r8, r2, lsl #2
    1220:	440c0000 	strmi	r0, [ip], #-0
    1224:	f9000003 			@ <UNDEFINED> instruction: 0xf9000003
    1228:	00f50c11 	rscseq	r0, r5, r1, lsl ip
    122c:	08540000 	ldmdaeq	r4, {}^	@ <UNPREDICTABLE>
    1230:	00340000 	eorseq	r0, r4, r0
    1234:	9c010000 	stcls	0, cr0, [r1], {-0}
    1238:	000010f9 	strdeq	r1, [r0], -r9
                        pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
    123c:	000b0902 	andeq	r0, fp, r2, lsl #18
    1240:	2a11f900 	bcs	47f648 <xNumberOfSuccessfulFrees+0x47a9cc>
    1244:	00000121 	andeq	r0, r0, r1, lsr #2
                        xShouldBlock = pdTRUE;
    1248:	016c9102 	cmneq	ip, r2, lsl #2
                taskEXIT_CRITICAL();
    124c:	000006b7 			@ <UNDEFINED> instruction: 0x000006b7
                if( xShouldBlock == pdTRUE )
    1250:	f51011fb 			@ <UNDEFINED> instruction: 0xf51011fb
    1254:	02000000 	andeq	r0, r0, #0
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1258:	0e007491 	mcreq	4, 0, r7, cr0, cr1, {4}
    125c:	00000a06 	andeq	r0, r0, r6, lsl #20
            xAlreadyYielded = xTaskResumeAll();
    1260:	86081082 	strhi	r1, [r8], -r2, lsl #1
            if( ( xShouldBlock == pdTRUE ) && ( xAlreadyYielded == pdFALSE ) )
    1264:	28000000 	stmdacs	r0, {}	@ <UNPREDICTABLE>
    1268:	2c000008 	stccs	0, cr0, [r0], {8}
    126c:	01000000 	mrseq	r0, (UNDEF: 0)
                taskYIELD_WITHIN_API();
    1270:	0011329c 	mulseq	r1, ip, r2
    1274:	087a0200 	ldmdaeq	sl!, {r9}^
    1278:	10820000 	addne	r0, r2, r0
    127c:	00022d24 	andeq	r2, r2, r4, lsr #26
        taskENTER_CRITICAL();
    1280:	6c910200 	lfmvs	f0, 4, [r1], {0}
            if( pulNotificationValue != NULL )
    1284:	000b9401 	andeq	r9, fp, r1, lsl #8
    1288:	0d108400 	cfldrseq	mvf8, [r0, #-0]
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];
    128c:	000003d7 	ldrdeq	r0, [r0], -r7
    1290:	00749102 	rsbseq	r9, r4, r2, lsl #2
    1294:	0001ad2e 	andeq	sl, r1, lr, lsr #26
    1298:	10760100 	rsbsne	r0, r6, r0, lsl #2
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )
    129c:	00010b0d 	andeq	r0, r1, sp, lsl #22
    12a0:	00081400 	andeq	r1, r8, r0, lsl #8
    12a4:	00001400 	andeq	r1, r0, r0, lsl #8
    12a8:	0e9c0100 	fmleqe	f0, f4, f0
    12ac:	0000042c 	andeq	r0, r0, ip, lsr #8
                xReturn = pdFALSE;
    12b0:	210c1053 	qaddcs	r1, r3, ip
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnExit;
    12b4:	f4000001 	vst4.8	{d0-d3}, [r0], r1
    12b8:	20000007 	andcs	r0, r0, r7
    12bc:	01000000 	mrseq	r0, (UNDEF: 0)
    12c0:	0011829c 	mulseq	r1, ip, r2
    12c4:	07140100 	ldreq	r0, [r4, -r0, lsl #2]
    12c8:	10550000 	subsne	r0, r5, r0
    12cc:	00012110 	andeq	r2, r1, r0, lsl r1
    12d0:	70910200 	addsvc	r0, r1, r0, lsl #4
                xReturn = pdTRUE;
    12d4:	00037901 	andeq	r7, r3, r1, lsl #18
            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;
    12d8:	11105600 	tstne	r0, r0, lsl #12
    12dc:	0000010b 	andeq	r0, r0, fp, lsl #2
    12e0:	00749102 	rsbseq	r9, r4, r2, lsl #2
        taskEXIT_CRITICAL();
    12e4:	0007ef0e 	andeq	lr, r7, lr, lsl #30
        return xReturn;
    12e8:	0c104000 	ldceq	0, cr4, [r0], {-0}
    }
    12ec:	00000121 	andeq	r0, r0, r1, lsr #2
    12f0:	000007d8 	ldrdeq	r0, [r0], -r8
    12f4:	0000001c 	andeq	r0, r0, ip, lsl r0
    12f8:	11ac9c01 			@ <UNDEFINED> instruction: 0x11ac9c01
    {
    12fc:	14010000 	strne	r0, [r1], #-0
    1300:	4200000a 	andmi	r0, r0, #10
    1304:	01211010 			@ <UNDEFINED> instruction: 0x01211010
    1308:	91020000 	mrsls	r0, (UNDEF: 2)
        BaseType_t xReturn = pdPASS;
    130c:	520c0074 	andpl	r0, ip, #116	@ 0x74
        pxTCB = xTaskToNotify;
    1310:	ab000009 	blge	133c <xTaskGenericNotify+0x40>
        taskENTER_CRITICAL();
    1314:	00f50c0f 	rscseq	r0, r5, pc, lsl #24
            if( pulPreviousNotificationValue != NULL )
    1318:	05e80000 	strbeq	r0, [r8, #0]!
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    131c:	01f00000 	mvnseq	r0, r0
    1320:	9c010000 	stcls	0, cr0, [r1], {-0}
    1324:	0000126e 	andeq	r1, r0, lr, ror #4
    1328:	000b9401 	andeq	r9, fp, r1, lsl #8
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    132c:	0d0fad00 	stceq	13, cr10, [pc, #-0]	@ 1334 <xTaskGenericNotify+0x38>
    1330:	000003d7 	ldrdeq	r0, [r0], -r7
    1334:	01749102 	cmneq	r4, r2, lsl #2
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1338:	00000ac2 	andeq	r0, r0, r2, asr #21
    133c:	f5100fae 			@ <UNDEFINED> instruction: 0xf5100fae
    1340:	02000000 	andeq	r0, r0, #0
            switch( eAction )
    1344:	fa097091 	blx	25d590 <xNumberOfSuccessfulFrees+0x258914>
    1348:	ac000005 	stcge	0, cr0, [r0], {5}
    134c:	01000001 	tsteq	r0, r1
    1350:	00000125 	andeq	r0, r0, r5, lsr #2
    1354:	061e0fbd 			@ <UNDEFINED> instruction: 0x061e0fbd
    1358:	02000001 	andeq	r0, r0, #1
    135c:	26036891 			@ <UNDEFINED> instruction: 0x26036891
    1360:	3e000006 	cdpcc	0, 0, cr0, cr0, cr6, {0}
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    1364:	19000000 	stmdbne	r0, {}	@ <UNPREDICTABLE>
    1368:	01000012 	tsteq	r0, r2, lsl r0
    136c:	00000bf8 	strdeq	r0, [r0], -r8
    1370:	43190fd2 	tstmi	r9, #840	@ 0x348
    1374:	02000004 	andeq	r0, r0, #4
    1378:	03006491 	movweq	r6, #1169	@ 0x491
    137c:	00000664 	andeq	r0, r0, r4, ror #12
                    break;
    1380:	0000003e 	andeq	r0, r0, lr, lsr r0
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    1384:	00001236 	andeq	r1, r0, r6, lsr r2
    1388:	000bf801 	andeq	pc, fp, r1, lsl #16
    138c:	190fd400 	stmdbne	pc, {sl, ip, lr, pc}	@ <UNPREDICTABLE>
    1390:	00000443 	andeq	r0, r0, r3, asr #8
    1394:	00609102 	rsbeq	r9, r0, r2, lsl #2
    1398:	0006b403 	andeq	fp, r6, r3, lsl #8
                    break;
    139c:	00007000 	andeq	r7, r0, r0
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    13a0:	00125300 	andseq	r5, r2, r0, lsl #6
    13a4:	02270100 	eoreq	r0, r7, #0, 2
    13a8:	0fd50000 	svceq	0x00d50000
                    break;
    13ac:	00021719 	andeq	r1, r2, r9, lsl r7
                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    13b0:	5c910200 	lfmpl	f0, 4, [r1], {0}
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    13b4:	07500900 	ldrbeq	r0, [r0, -r0, lsl #18]
    13b8:	00320000 	eorseq	r0, r2, r0
    13bc:	53010000 	movwpl	r0, #4096	@ 0x1000
    13c0:	02000002 	andeq	r0, r0, #2
                        xReturn = pdFAIL;
    13c4:	01212410 			@ <UNDEFINED> instruction: 0x01212410
                    break;
    13c8:	91020000 	mrsls	r0, (UNDEF: 2)
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    13cc:	0000006c 	andeq	r0, r0, ip, rrx
    13d0:	0004ca20 	andeq	ip, r4, r0, lsr #20
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    13d4:	cc0efd00 	stcgt	13, cr15, [lr], {-0}
    13d8:	1c000005 	stcne	0, cr0, [r0], {5}
    13dc:	01000000 	mrseq	r0, (UNDEF: 0)
    13e0:	0528179c 	streq	r1, [r8, #-1948]!	@ 0xfffff864
    13e4:	0ed20000 	cdpeq	0, 13, cr0, cr2, cr0, {0}
    13e8:	0000059c 	muleq	r0, ip, r5
    13ec:	00000030 	andeq	r0, r0, r0, lsr r0
    13f0:	12ae9c01 	adcne	r9, lr, #256	@ 0x100
    13f4:	bf160000 	svclt	0x00160000
    13f8:	a2000015 	andge	r0, r0, #21
    13fc:	14000005 	strne	r0, [r0], #-5
    1400:	f2000000 	vhadd.s8	d0, d0, d0
    1404:	c90f050e 	stmdbgt	pc, {r1, r2, r3, r8, sl}	@ <UNPREDICTABLE>
    1408:	02000015 	andeq	r0, r0, #21
    140c:	00007491 	muleq	r0, r1, r4
                prvAddTaskToReadyList( pxTCB );
    1410:	0000d417 	andeq	sp, r0, r7, lsl r4
    1414:	400e6900 	andmi	r6, lr, r0, lsl #18
    1418:	5c000005 	stcpl	0, cr0, [r0], {5}
    141c:	01000000 	mrseq	r0, (UNDEF: 0)
    1420:	0012ec9c 	mulseq	r2, ip, ip
    1424:	07140100 	ldreq	r0, [r4, -r0, lsl #2]
    1428:	0e6b0000 	cdpeq	0, 6, cr0, cr11, cr0, {0}
    142c:	0000f510 	andeq	pc, r0, r0, lsl r5	@ <UNPREDICTABLE>
    1430:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    1434:	0015bf16 	andseq	fp, r5, r6, lsl pc
    1438:	00055200 	andeq	r5, r5, r0, lsl #4
    143c:	00001400 	andeq	r1, r0, r0, lsl #8
    1440:	090e9600 	stmdbeq	lr, {r9, sl, ip, pc}
    1444:	0015c90f 	andseq	ip, r5, pc, lsl #18
    1448:	70910200 	addsvc	r0, r1, r0, lsl #4
    144c:	90210000 	eorls	r0, r1, r0
    1450:	d4000006 	strle	r0, [r0], #-6
    1454:	00f5130d 	rscseq	r1, r5, sp, lsl #6
    1458:	04940000 	ldreq	r0, [r4], #0
    145c:	00ac0000 	adceq	r0, ip, r0
    1460:	9c010000 	stcls	0, cr0, [r1], {-0}
    1464:	00001352 	andeq	r1, r0, r2, asr r3
    1468:	00071401 	andeq	r1, r7, r1, lsl #8
    146c:	100dd600 	andne	sp, sp, r0, lsl #12
    1470:	000000f5 	strdeq	r0, [r0], -r5
    1474:	01749102 	cmneq	r4, r2, lsl #2
    1478:	00000125 	andeq	r0, r0, r5, lsr #2
    147c:	f5100dd7 			@ <UNDEFINED> instruction: 0xf5100dd7
    1480:	02000000 	andeq	r0, r0, #0
    1484:	07017091 			@ <UNDEFINED> instruction: 0x07017091
    1488:	d8000009 	stmdale	r0, {r0, r3}
    148c:	03720a0d 	cmneq	r2, #53248	@ 0xd000
    1490:	91020000 	mrsls	r0, (UNDEF: 2)
                taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB );
    1494:	09b20158 	ldmibeq	r2!, {r3, r4, r6, r8}
    1498:	0dd90000 	ldcleq	0, cr0, [r9]
    149c:	0000c314 	andeq	ip, r0, r4, lsl r3
    14a0:	68910200 	ldmvs	r1, {r9}
    14a4:	00045a01 	andeq	r5, r4, r1, lsl #20
    14a8:	110dda00 	tstne	sp, r0, lsl #20
    14ac:	0000010b 	andeq	r0, r0, fp, lsl #2
        taskEXIT_CRITICAL();
    14b0:	006c9102 	rsbeq	r9, ip, r2, lsl #2
        return xReturn;
    14b4:	00066f15 	andeq	r6, r6, r5, lsl pc
    }
    14b8:	1107f900 	tstne	r7, r0, lsl #18	@ <UNPREDICTABLE>
    14bc:	0000036c 	andeq	r0, r0, ip, ror #6
    14c0:	00000128 	andeq	r0, r0, r8, lsr #2
    14c4:	13919c01 	orrsne	r9, r1, #256	@ 0x100
    14c8:	a3020000 	movwge	r0, #8192	@ 0x2000
    14cc:	f9000006 			@ <UNDEFINED> instruction: 0xf9000006
    {
    14d0:	03d73307 	bicseq	r3, r7, #469762048	@ 0x1c000000
    14d4:	91020000 	mrsls	r0, (UNDEF: 2)
    14d8:	03d6096c 	bicseq	r0, r6, #108, 18	@ 0x1b0000
    14dc:	00700000 	rsbseq	r0, r0, r0
        BaseType_t xReturn = pdPASS;
    14e0:	27010000 	strcs	r0, [r1, -r0]
        pxTCB = xTaskToNotify;
    14e4:	33000002 	movwcc	r0, #2
    __asm volatile
    14e8:	02170d08 	andseq	r0, r7, #8, 26	@ 0x200
    14ec:	91020000 	mrsls	r0, (UNDEF: 2)
    14f0:	15000074 	strne	r0, [r0, #-116]	@ 0xffffff8c
    14f4:	00000925 	andeq	r0, r0, r5, lsr #18
    14f8:	a20d0717 	andge	r0, sp, #6029312	@ 0x5c0000
    14fc:	ca000002 	bgt	150c <xTaskGenericNotifyFromISR+0x3c>
        uxSavedInterruptStatus = ( UBaseType_t ) taskENTER_CRITICAL_FROM_ISR();
    1500:	01000000 	mrseq	r0, (UNDEF: 0)
            if( pulPreviousNotificationValue != NULL )
    1504:	00143d9c 	mulseq	r4, ip, sp
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    1508:	06ac0200 	strteq	r0, [ip], r0, lsl #4
    150c:	07170000 	ldreq	r0, [r7, -r0]
    1510:	0000c332 	andeq	ip, r0, r2, lsr r3
    1514:	6c910200 	lfmvs	f0, 4, [r1], {0}
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    1518:	00054a02 	andeq	r4, r5, r2, lsl #20
    151c:	36071800 	strcc	r1, [r7], -r0, lsl #16
    1520:	0000009c 	muleq	r0, ip, r0
    1524:	02689102 	rsbeq	r9, r8, #-2147483648	@ 0x80000000
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1528:	000004da 	ldrdeq	r0, [r0], -sl
    152c:	f0400719 			@ <UNDEFINED> instruction: 0xf0400719
    1530:	02000000 	andeq	r0, r0, #0
            switch( eAction )
    1534:	3a026491 	bcc	9a780 <xNumberOfSuccessfulFrees+0x95b04>
    1538:	1a000009 	bne	1564 <xTaskGenericNotifyFromISR+0x94>
    153c:	00813007 	addeq	r3, r1, r7
    1540:	91020000 	mrsls	r0, (UNDEF: 2)
    1544:	016e0260 	cmneq	lr, r0, ror #4
    1548:	071b0000 	ldreq	r0, [fp, -r0]
    154c:	00010b2f 	andeq	r0, r1, pc, lsr #22
    1550:	00910200 	addseq	r0, r1, r0, lsl #4
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    1554:	000c0f02 	andeq	r0, ip, r2, lsl #30
    1558:	38071c00 	stmdacc	r7, {sl, fp, ip}
    155c:	00001442 	andeq	r1, r0, r2, asr #8
    1560:	02049102 	andeq	r9, r4, #-2147483648	@ 0x80000000
    1564:	000006a3 	andeq	r0, r0, r3, lsr #13
    1568:	d72b071d 			@ <UNDEFINED> instruction: 0xd72b071d
    156c:	02000003 	andeq	r0, r0, #3
                    break;
    1570:	19020891 	stmdbne	r2, {r0, r4, r7, fp}
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    1574:	1e00000b 	cdpne	0, 0, cr0, cr0, cr11, {0}
    1578:	144c4007 	strbne	r4, [ip], #-7
    157c:	91020000 	mrsls	r0, (UNDEF: 2)
    1580:	0bcc010c 	bleq	ff3019b8 <__StackTop+0xdf2ff9b8>
    1584:	07200000 	streq	r0, [r0, -r0]!
    1588:	00036813 	andeq	r6, r3, r3, lsl r8
                    break;
    158c:	70910200 	addsvc	r0, r1, r0, lsl #4
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    1590:	0100782f 	tsteq	r0, pc, lsr #16
    1594:	0b110721 	bleq	443220 <xNumberOfSuccessfulFrees+0x43e5a4>
    1598:	02000001 	andeq	r0, r0, #1
                    break;
    159c:	04007491 	streq	r7, [r0], #-1169	@ 0xfffffb6f
                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    15a0:	0000022d 	andeq	r0, r0, sp, lsr #4
    15a4:	00143d05 	andseq	r3, r4, r5, lsl #26
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    15a8:	03630400 	cmneq	r3, #0, 8
    15ac:	47050000 	strmi	r0, [r5, -r0]
    15b0:	0c000014 	stceq	0, cr0, [r0], {20}
                    break;
    15b4:	00000663 	andeq	r0, r0, r3, ror #12
                        xReturn = pdFAIL;
    15b8:	f51006cc 			@ <UNDEFINED> instruction: 0xf51006cc
                    break;
    15bc:	5c000000 	stcpl	0, cr0, [r0], {-0}
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    15c0:	46000002 	strmi	r0, [r0], -r2
    15c4:	01000000 	mrseq	r0, (UNDEF: 0)
                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
    15c8:	0014e49c 	mulseq	r4, ip, r4
    15cc:	06ac0200 	strteq	r0, [ip], r0, lsl #4
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    15d0:	06cc0000 	strbeq	r0, [ip], r0
    15d4:	0000c32c 	andeq	ip, r0, ip, lsr #6
    15d8:	6c910200 	lfmvs	f0, 4, [r1], {0}
    15dc:	00054a02 	andeq	r4, r5, r2, lsl #20
    15e0:	3006cd00 	andcc	ip, r6, r0, lsl #26
    15e4:	0000009c 	muleq	r0, ip, r0
    15e8:	02689102 	rsbeq	r9, r8, #-2147483648	@ 0x80000000
    15ec:	000004da 	ldrdeq	r0, [r0], -sl
    15f0:	f03a06ce 			@ <UNDEFINED> instruction: 0xf03a06ce
    15f4:	02000000 	andeq	r0, r0, #0
    15f8:	3a026491 	bcc	9a844 <xNumberOfSuccessfulFrees+0x95bc8>
    15fc:	cf000009 	svcgt	0x00000009
    1600:	00812a06 	addeq	r2, r1, r6, lsl #20
    1604:	91020000 	mrsls	r0, (UNDEF: 2)
    1608:	016e0260 	cmneq	lr, r0, ror #4
    160c:	06d00000 	ldrbeq	r0, [r0], r0
                    prvAddTaskToReadyList( pxTCB );
    1610:	00010b29 	andeq	r0, r1, r9, lsr #22
    1614:	00910200 	addseq	r0, r1, r0, lsl #4
    1618:	000c0f02 	andeq	r0, ip, r2, lsl #30
    161c:	3206d100 	andcc	sp, r6, #0, 2
    1620:	00001442 	andeq	r1, r0, r2, asr #8
    1624:	01049102 	tsteq	r4, r2, lsl #2
    1628:	000006a3 	andeq	r0, r0, r3, lsr #13
    162c:	d71106d3 			@ <UNDEFINED> instruction: 0xd71106d3
    1630:	02000003 	andeq	r0, r0, #3
    1634:	14017091 	strne	r7, [r1], #-145	@ 0xffffff6f
    1638:	d4000007 	strle	r0, [r0], #-7
    163c:	00f51406 	rscseq	r1, r5, r6, lsl #8
    1640:	91020000 	mrsls	r0, (UNDEF: 2)
    1644:	fa210074 	blx	84181c <xNumberOfSuccessfulFrees+0x83cba0>
    1648:	6a000003 	bvs	165c <xTaskGenericNotifyFromISR+0x18c>
    164c:	03d71406 	bicseq	r1, r7, #100663296	@ 0x6000000
    1650:	01e40000 	mvneq	r0, r0
    1654:	00780000 	rsbseq	r0, r8, r0
    1658:	9c010000 	stcls	0, cr0, [r1], {-0}
    165c:	00001581 	andeq	r1, r0, r1, lsl #11
    1660:	0006ac02 	andeq	sl, r6, r2, lsl #24
    1664:	32066a00 	andcc	r6, r6, #0, 20
    1668:	000000c3 	andeq	r0, r0, r3, asr #1
    166c:	026c9102 	rsbeq	r9, ip, #-2147483648	@ 0x80000000
    1670:	0000054a 	andeq	r0, r0, sl, asr #10
    1674:	9c36066b 	ldcls	6, cr0, [r6], #-428	@ 0xfffffe54
    1678:	02000000 	andeq	r0, r0, #0
    167c:	da026891 	ble	9b8c8 <xNumberOfSuccessfulFrees+0x96c4c>
    1680:	6c000004 	stcvs	0, cr0, [r0], {4}
    1684:	00f04006 	rscseq	r4, r0, r6
    1688:	91020000 	mrsls	r0, (UNDEF: 2)
    168c:	093a0264 	ldmdbeq	sl!, {r2, r5, r6, r9}
    1690:	066d0000 	strbteq	r0, [sp], -r0
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1694:	00008130 	andeq	r8, r0, r0, lsr r1
    1698:	60910200 	addsvs	r0, r1, r0, lsl #4
    169c:	00016e02 	andeq	r6, r1, r2, lsl #28
    16a0:	2f066e00 	svccs	0x00066e00
    16a4:	0000010b 	andeq	r0, r0, fp, lsl #2
    16a8:	02009102 	andeq	r9, r0, #-2147483648	@ 0x80000000
    16ac:	00000c0f 	andeq	r0, r0, pc, lsl #24
    16b0:	4238066f 	eorsmi	r0, r8, #116391936	@ 0x6f00000
    16b4:	02000014 	andeq	r0, r0, #20
    16b8:	a3010491 	movwge	r0, #5265	@ 0x1491
    16bc:	71000006 	tstvc	r0, r6
    16c0:	03d71106 	bicseq	r1, r7, #-2147483647	@ 0x80000001
    16c4:	91020000 	mrsls	r0, (UNDEF: 2)
    16c8:	01f20974 	mvnseq	r0, r4, ror r9
                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    16cc:	003e0000 	eorseq	r0, lr, r0
    16d0:	83010000 	movwhi	r0, #4096	@ 0x1000
    16d4:	96000009 	strls	r0, [r0], -r9
                        if( pxHigherPriorityTaskWoken != NULL )
    16d8:	03681b06 	cmneq	r8, #6144	@ 0x1800
    16dc:	91020000 	mrsls	r0, (UNDEF: 2)
                            *pxHigherPriorityTaskWoken = pdTRUE;
    16e0:	22000070 	andcs	r0, r0, #112	@ 0x70
                        xYieldPendings[ 0 ] = pdTRUE;
    16e4:	00000321 	andeq	r0, r0, r1, lsr #6
    16e8:	001597f8 			@ <UNDEFINED> instruction: 0x001597f8
    16ec:	084a2300 	stmdaeq	sl, {r8, r9, sp}^
    __asm volatile
    16f0:	38f80000 	ldmcc	r8!, {}^	@ <UNPREDICTABLE>
}
    16f4:	000000b2 	strheq	r0, [r0], -r2
    }
    16f8:	06ea3000 	strbteq	r3, [sl], r0
    16fc:	e4020000 	str	r0, [r2], #-0
    1700:	0000b222 	andeq	fp, r0, r2, lsr #4
    1704:	15bf0300 	ldrne	r0, [pc, #768]!	@ 1a0c <prvAddCurrentTaskToDelayedList+0x7c>
    1708:	b4180000 	ldrlt	r0, [r8], #-0
    170c:	e6000003 	str	r0, [r0], -r3
    1710:	0000b20e 	andeq	fp, r0, lr, lsl #4
    1714:	05f71800 	ldrbeq	r1, [r7, #2048]!	@ 0x800
    1718:	21e60000 	mvncs	r0, r0
    {
    171c:	000000b2 	strheq	r0, [r0], -r2
    1720:	09f42200 	ldmibeq	r4!, {r9, sp}^
    1724:	d5d40000 	ldrble	r0, [r4]
        pxTCB = xTaskToNotify;
    1728:	18000015 	stmdane	r0, {r0, r2, r4}
    __asm volatile
    172c:	000005f7 	strdeq	r0, [r0], -r7
    1730:	00b20ed6 	ldrsbteq	r0, [r2], r6
    1734:	31000000 	mrscc	r0, (UNDEF: 0)
    1738:	00000743 	andeq	r0, r0, r3, asr #14
    173c:	a13e9402 	teqge	lr, r2, lsl #8
    1740:	03000000 	movweq	r0, #0
    return ulOriginalBASEPRI;
    1744:	0002e523 	andeq	lr, r2, r3, lsr #10
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    1748:	b2609400 	rsblt	r9, r0, #0, 8
    174c:	18000000 	stmdane	r0, {}	@ <UNPREDICTABLE>
    1750:	000009c5 	andeq	r0, r0, r5, asr #19
    1754:	00a11196 	umlaleq	r1, r1, r6, r1	@ <UNPREDICTABLE>
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    1758:	00000000 	andeq	r0, r0, r0
    175c:	00000296 	muleq	r0, r6, r2
    1760:	04010005 	streq	r0, [r1], #-5
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    1764:	0000045f 	andeq	r0, r0, pc, asr r4
    1768:	0000650a 	andeq	r6, r0, sl, lsl #10
    176c:	0c631d00 	stcleq	13, cr1, [r3], #-0
    1770:	00070000 	andeq	r0, r7, r0
    1774:	1ad00000 	bne	ff40177c <__StackTop+0xdf3ff77c>
    1778:	015e0000 	cmpeq	lr, r0
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    177c:	0b130000 	bleq	4c1784 <xNumberOfSuccessfulFrees+0x4bcb08>
    1780:	04010000 	streq	r0, [r1], #-0
    1784:	00005807 	andeq	r5, r0, r7, lsl #16
                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
    1788:	05040b00 	streq	r0, [r4, #-2816]	@ 0xfffff500
    178c:	00746e69 	rsbseq	r6, r4, r9, ror #28
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    1790:	2d050801 	stccs	8, cr0, [r5, #-4]
    1794:	01000000 	mrseq	r0, (UNDEF: 0)
    1798:	00e80408 	rsceq	r0, r8, r8, lsl #8
    179c:	01010000 	mrseq	r0, (UNDEF: 1)
    17a0:	0000c206 	andeq	ip, r0, r6, lsl #4
    17a4:	08010100 	stmdaeq	r1, {r8}
    17a8:	000000c0 	andeq	r0, r0, r0, asr #1
    17ac:	f4050201 	vst1.8	{d0-d3}, [r5], r1
    17b0:	01000000 	mrseq	r0, (UNDEF: 0)
    17b4:	003b0702 	eorseq	r0, fp, r2, lsl #14
    17b8:	04010000 	streq	r0, [r1], #-0
    17bc:	00003205 	andeq	r3, r0, r5, lsl #4
    17c0:	07040100 	streq	r0, [r4, -r0, lsl #2]
    17c4:	00000053 	andeq	r0, r0, r3, asr r0
    17c8:	4e070801 	cdpmi	8, 0, cr0, cr7, cr1, {0}
                    prvAddTaskToReadyList( pxTCB );
    17cc:	0c000000 	stceq	0, cr0, [r0], {-0}
    17d0:	08010104 	stmdaeq	r1, {r2, r8}
    17d4:	000000c9 	andeq	r0, r0, r9, asr #1
    17d8:	00039004 	andeq	r9, r3, r4
    17dc:	19340200 	ldmdbne	r4!, {r9}
    17e0:	00000065 	andeq	r0, r0, r5, rrx
    17e4:	00060404 	andeq	r0, r6, r4, lsl #8
    17e8:	1a3c0300 	bne	f023f0 <xNumberOfSuccessfulFrees+0xefd774>
    17ec:	00000065 	andeq	r0, r0, r5, rrx
    17f0:	00088704 	andeq	r8, r8, r4, lsl #14
    17f4:	1a420300 	bne	10823fc <xNumberOfSuccessfulFrees+0x107d780>
    17f8:	0000007c 	andeq	r0, r0, ip, ror r0
    17fc:	00009407 	andeq	r9, r0, r7, lsl #8
    1800:	02610800 	rsbeq	r0, r1, #0, 16
    1804:	90140000 	andsls	r0, r4, r0
    1808:	0000ee08 	andeq	lr, r0, r8, lsl #28
    180c:	09470200 	stmdbeq	r7, {r9}^
    1810:	24930000 	ldrcs	r0, [r3], #0
    1814:	00000094 	muleq	r0, r4, r0
    1818:	07a60200 	streq	r0, [r6, r0, lsl #4]!
    181c:	2d940000 	ldccs	0, cr0, [r4]
    1820:	000000ee 	andeq	r0, r0, lr, ror #1
    1824:	04960204 	ldreq	r0, [r6], #516	@ 0x204
    1828:	2d950000 	ldccs	0, cr0, [r5]
    182c:	000000ee 	andeq	r0, r0, lr, ror #1
    1830:	0aba0208 	beq	fee82058 <__StackTop+0xdee80058>
    1834:	0c960000 	ldceq	0, cr0, [r6], {0}
    1838:	00000073 	andeq	r0, r0, r3, ror r0
    183c:	08e1020c 	stmiaeq	r1!, {r2, r3, r9}^
    1840:	28970000 	ldmcs	r7, {}	@ <UNPREDICTABLE>
    1844:	00000124 	andeq	r0, r0, r4, lsr #2
    1848:	a5050010 	strge	r0, [r5, #-16]
    184c:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1850:	00000522 	andeq	r0, r0, r2, lsr #10
    1854:	2410ac14 	ldrcs	sl, [r0], #-3092	@ 0xfffff3ec
    1858:	02000001 	andeq	r0, r0, #1
    185c:	00000138 	andeq	r0, r0, r8, lsr r1
    1860:	008825af 	addeq	r2, r8, pc, lsr #11
    1864:	02000000 	andeq	r0, r0, #0
    1868:	00000227 	andeq	r0, r0, r7, lsr #4
    186c:	017226b0 	ldrheq	r2, [r2, #-96]!	@ 0xffffffa0
    1870:	02040000 	andeq	r0, r4, #0
    1874:	00000633 	andeq	r0, r0, r3, lsr r6
    1878:	016614b1 	strheq	r1, [r6, #-65]!	@ 0xffffffbf
    187c:	00080000 	andeq	r0, r8, r0
    1880:	0000f305 	andeq	pc, r0, r5, lsl #6
    1884:	06580400 	ldrbeq	r0, [r8], -r0, lsl #8
                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    1888:	9a040000 	bls	101890 <xNumberOfSuccessfulFrees+0xfcc14>
    188c:	0000a51b 	andeq	sl, r0, fp, lsl r5
    1890:	05070800 	streq	r0, [r7, #-2048]	@ 0xfffff800
    1894:	9d0c0000 	stcls	0, cr0, [ip, #-0]
                        if( pxHigherPriorityTaskWoken != NULL )
    1898:	0001660c 	andeq	r6, r1, ip, lsl #12
                            *pxHigherPriorityTaskWoken = pdTRUE;
    189c:	09470200 	stmdbeq	r7, {r9}^
    18a0:	28a00000 	stmiacs	r0!, {}	@ <UNPREDICTABLE>
                        xYieldPendings[ 0 ] = pdTRUE;
    18a4:	00000094 	muleq	r0, r4, r0
    18a8:	07a60200 	streq	r0, [r6, r0, lsl #4]!
    __asm volatile
    18ac:	31a10000 			@ <UNDEFINED> instruction: 0x31a10000
    18b0:	000000ee 	andeq	r0, r0, lr, ror #1
    }
    18b4:	04960204 	ldreq	r0, [r6], #516	@ 0x204
    18b8:	31a20000 			@ <UNDEFINED> instruction: 0x31a20000
    18bc:	000000ee 	andeq	r0, r0, lr, ror #1
    18c0:	54040008 	strpl	r0, [r4], #-8
    18c4:	04000006 	streq	r0, [r0], #-6
    18c8:	013524a4 	teqeq	r5, r4, lsr #9
    18cc:	29050000 	stmdbcs	r5, {}	@ <UNPREDICTABLE>
    18d0:	07000001 	streq	r0, [r0, -r1]
    18d4:	00000172 	andeq	r0, r0, r2, ror r1
    {
    18d8:	00087304 	andeq	r7, r8, r4, lsl #6
    18dc:	03b30400 			@ <UNDEFINED> instruction: 0x03b30400
    18e0:	000000f3 	strdeq	r0, [r0], -r3
        pxTCB = prvGetTCBFromHandle( xTask );
    18e4:	0003a70d 	andeq	sl, r3, sp, lsl #14
    18e8:	0dd90100 	ldfeqe	f0, [r9]
    18ec:	00000088 	andeq	r0, r0, r8, lsl #1
    18f0:	00001bdc 	ldrdeq	r1, [r0], -ip
        taskENTER_CRITICAL();
    18f4:	00000052 	andeq	r0, r0, r2, asr r0
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    18f8:	01bf9c01 			@ <UNDEFINED> instruction: 0x01bf9c01
    18fc:	7d030000 	stcvc	0, cr0, [r3, #-0]
    1900:	d900000c 	stmdble	r0, {r2, r3}
    1904:	0001772e 	andeq	r7, r1, lr, lsr #14
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    1908:	6c910200 	lfmvs	f0, 4, [r1], {0}
    190c:	000bf806 	andeq	pc, fp, r6, lsl #16
    1910:	c414dd00 	ldrgt	sp, [r4], #-3328	@ 0xfffff300
                xReturn = pdPASS;
    1914:	02000001 	andeq	r0, r0, #1
                xReturn = pdFAIL;
    1918:	05007491 	streq	r7, [r0, #-1169]	@ 0xfffffb6f
        taskEXIT_CRITICAL();
    191c:	0000017c 	andeq	r0, r0, ip, ror r1
        return xReturn;
    1920:	0001bf07 	andeq	fp, r1, r7, lsl #30
    }
    1924:	0a9a0900 	beq	fe683d2c <__StackTop+0xde681d2c>
    1928:	6c8b0000 	stcvs	0, cr0, [fp], {0}
    192c:	7000001b 	andvc	r0, r0, fp, lsl r0
    {
    1930:	01000000 	mrseq	r0, (UNDEF: 0)
    1934:	0002169c 	muleq	r2, ip, r6
    1938:	0bf80300 	bleq	ffe02540 <__StackTop+0xdfe00540>
        pxTCB = prvGetTCBFromHandle( xTask );
    193c:	228b0000 	addcs	r0, fp, #0
    1940:	000001c4 	andeq	r0, r0, r4, asr #3
    1944:	036c9102 	cmneq	ip, #-2147483648	@ 0x80000000
    1948:	00000cbf 			@ <UNDEFINED> instruction: 0x00000cbf
        taskENTER_CRITICAL();
    194c:	0177268c 	cmneq	r7, ip, lsl #13
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    1950:	91020000 	mrsls	r0, (UNDEF: 2)
    1954:	0cb40668 	ldceq	6, cr0, [r4], #416	@ 0x1a0
    1958:	128e0000 	addne	r0, lr, #0
    195c:	00000172 	andeq	r0, r0, r2, ror r1
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    1960:	06749102 	ldrbteq	r9, [r4], -r2, lsl #2
    1964:	00000c9b 	muleq	r0, fp, ip
    1968:	00a0168f 	adceq	r1, r0, pc, lsl #13
    196c:	91020000 	mrsls	r0, (UNDEF: 2)
    1970:	8c090070 	stchi	0, cr0, [r9], {112}	@ 0x70
    1974:	6900000c 	stmdbvs	r0, {r2, r3}
    1978:	00001b26 	andeq	r1, r0, r6, lsr #22
        taskEXIT_CRITICAL();
    197c:	00000046 	andeq	r0, r0, r6, asr #32
        return ulReturn;
    1980:	02559c01 	subseq	r9, r5, #256	@ 0x100
    }
    1984:	f8030000 			@ <UNDEFINED> instruction: 0xf8030000
    1988:	6900000b 	stmdbvs	r0, {r0, r1, r3}
    198c:	0001c425 	andeq	ip, r1, r5, lsr #8
{
    1990:	6c910200 	lfmvs	f0, 4, [r1], {0}
    1994:	000cbf03 	andeq	fp, ip, r3, lsl #30
    1998:	77296a00 	strvc	r6, [r9, -r0, lsl #20]!
    const TickType_t xConstTickCount = xTickCount;
    199c:	02000001 	andeq	r0, r0, #1
    List_t * const pxDelayedList = pxDelayedTaskList;
    19a0:	27066891 			@ <UNDEFINED> instruction: 0x27066891
    19a4:	6c000002 	stcvs	0, cr0, [r0], {2}
    List_t * const pxOverflowDelayedList = pxOverflowDelayedTaskList;
    19a8:	00017718 	andeq	r7, r1, r8, lsl r7
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    19ac:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    19b0:	09110900 	ldmdbeq	r1, {r8, fp}
    19b4:	0e590000 	cdpeq	0, 5, cr0, cr9, cr0, {0}
    19b8:	1800001b 	stmdane	r0, {r0, r1, r3, r4}
    19bc:	01000000 	mrseq	r0, (UNDEF: 0)
        portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    19c0:	0002789c 	muleq	r2, ip, r8
    19c4:	0cad0300 	stceq	3, cr0, [sp]
    19c8:	2e590000 	cdpcs	0, 5, cr0, cr9, cr0, {0}
    19cc:	00000177 	andeq	r0, r0, r7, ror r1
    19d0:	00749102 	rsbseq	r9, r4, r2, lsl #2
    19d4:	000a7c0e 	andeq	r7, sl, lr, lsl #24
        xTimeToWake = xConstTickCount + xTicksToWait;
    19d8:	06310100 	ldrteq	r0, [r1], -r0, lsl #2
    19dc:	00001ad0 	ldrdeq	r1, [r0], -r0
        listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    19e0:	0000003e 	andeq	r0, r0, lr, lsr r0
    19e4:	f8039c01 			@ <UNDEFINED> instruction: 0xf8039c01
        if( xTimeToWake < xConstTickCount )
    19e8:	3100000b 	tstcc	r0, fp
    19ec:	0001c426 	andeq	ip, r1, r6, lsr #8
            vListInsert( pxOverflowDelayedList, &( pxCurrentTCB->xStateListItem ) );
    19f0:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    19f4:	049c0000 	ldreq	r0, [ip], #0
    19f8:	00050000 	andeq	r0, r5, r0
}
    19fc:	054b0401 	strbeq	r0, [fp, #-1025]	@ 0xfffffbff
            vListInsert( pxDelayedList, &( pxCurrentTCB->xStateListItem ) );
    1a00:	65100000 	ldrvs	r0, [r0, #-0]
    1a04:	1d000000 	stcne	0, cr0, [r0, #-0]
    1a08:	00000ec2 	andeq	r0, r0, r2, asr #29
            if( xTimeToWake < xNextTaskUnblockTime )
    1a0c:	00000007 	andeq	r0, r0, r7
    1a10:	00001c30 	andeq	r1, r0, r0, lsr ip
    1a14:	000004e8 	andeq	r0, r0, r8, ror #9
                xNextTaskUnblockTime = xTimeToWake;
    1a18:	00000cc3 	andeq	r0, r0, r3, asr #25
}
    1a1c:	0004f505 	andeq	pc, r4, r5, lsl #10
    1a20:	17d60200 	ldrbne	r0, [r6, r0, lsl #4]
    1a24:	00000037 	andeq	r0, r0, r7, lsr r0
    1a28:	00002611 	andeq	r2, r0, r1, lsl r6
    1a2c:	07040200 	streq	r0, [r4, -r0, lsl #4]
    1a30:	00000058 	andeq	r0, r0, r8, asr r0
    1a34:	69050412 	stmdbvs	r5, {r1, r4, sl}
    1a38:	0200746e 	andeq	r7, r0, #1845493760	@ 0x6e000000
{
    1a3c:	002d0508 	eoreq	r0, sp, r8, lsl #10
    1a40:	08020000 	stmdaeq	r2, {}	@ <UNPREDICTABLE>
        pxCurrentTCB = NULL;
    1a44:	0000e804 	andeq	lr, r0, r4, lsl #16
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
    1a48:	06010200 	streq	r0, [r1], -r0, lsl #4
    1a4c:	000000c2 	andeq	r0, r0, r2, asr #1
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    1a50:	c0080102 	andgt	r0, r8, r2, lsl #2
    uxTopReadyPriority = tskIDLE_PRIORITY;
    1a54:	02000000 	andeq	r0, r0, #0
    1a58:	00f40502 	rscseq	r0, r4, r2, lsl #10
    xSchedulerRunning = pdFALSE;
    1a5c:	02020000 	andeq	r0, r2, #0
    xPendedTicks = ( TickType_t ) 0U;
    1a60:	00003b07 	andeq	r3, r0, r7, lsl #22
    1a64:	05040200 	streq	r0, [r4, #-512]	@ 0xfffffe00
    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    1a68:	00000032 	andeq	r0, r0, r2, lsr r0
        xYieldPendings[ xCoreID ] = pdFALSE;
    1a6c:	53070402 	movwpl	r0, #29698	@ 0x7402
    1a70:	02000000 	andeq	r0, r0, #0
    1a74:	004e0708 	subeq	r0, lr, r8, lsl #14
    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    1a78:	04130000 	ldreq	r0, [r3], #-0
    1a7c:	c9080102 	stmdbgt	r8, {r1, r8}
    1a80:	05000000 	streq	r0, [r0, #-0]
    xNumOfOverflows = ( BaseType_t ) 0;
    1a84:	00000688 	andeq	r0, r0, r8, lsl #13
    uxTaskNumber = ( UBaseType_t ) 0U;
    1a88:	5a182e03 	bpl	60d29c <xNumberOfSuccessfulFrees+0x608620>
    1a8c:	05000000 	streq	r0, [r0, #-0]
    xNextTaskUnblockTime = ( TickType_t ) 0U;
    1a90:	00000390 	muleq	r0, r0, r3
    uxSchedulerSuspended = ( UBaseType_t ) 0U;
    1a94:	76193403 	ldrvc	r3, [r9], -r3, lsl #8
    1a98:	05000000 	streq	r0, [r0, #-0]
}
    1a9c:	00000605 	andeq	r0, r0, r5, lsl #12
    1aa0:	6f1a3b04 	svcvs	0x001a3b04
    1aa4:	06000000 	streq	r0, [r0], -r0
    1aa8:	0000008d 	andeq	r0, r0, sp, lsl #1
    1aac:	000cde0b 	andeq	sp, ip, fp, lsl #28
    1ab0:	9c051c00 	stcls	12, cr1, [r5], {-0}
    1ab4:	0000011e 	andeq	r0, r0, lr, lsl r1
    1ab8:	000e9a04 	andeq	r9, lr, r4, lsl #20
    1abc:	0c9e0500 	cfldr32eq	mvfx0, [lr], {0}
    1ac0:	00000026 	andeq	r0, r0, r6, lsr #32
    1ac4:	0f030400 	svceq	0x00030400
    1ac8:	9f050000 	svcls	0x00050000
    1acc:	0000260c 	andeq	r2, r0, ip, lsl #12
{
    1ad0:	9c040400 	cfstrsls	mvf0, [r4], {-0}
    1ad4:	0500000d 	streq	r0, [r0, #-13]
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );
    1ad8:	00260ca0 	eoreq	r0, r6, r0, lsr #25
    1adc:	04080000 	streq	r0, [r8], #-0
    1ae0:	00000d25 	andeq	r0, r0, r5, lsr #26
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    1ae4:	260ca105 	strcs	sl, [ip], -r5, lsl #2
    1ae8:	0c000000 	stceq	0, cr0, [r0], {-0}
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );
    1aec:	000ce904 	andeq	lr, ip, r4, lsl #18
    1af0:	0ca20500 	cfstr32eq	mvfx0, [r2]
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );
    1af4:	00000026 	andeq	r0, r0, r6, lsr #32
    1af8:	0e7b0410 	mrceq	4, 3, r0, cr11, cr0, {0}
    1afc:	a3050000 	movwge	r0, #20480	@ 0x5000
    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1b00:	0000260c 	andeq	r2, r0, ip, lsl #12
}
    1b04:	5d041400 	cfstrspl	mvf1, [r4, #-0]
    1b08:	0500000f 	streq	r0, [r0, #-15]
    1b0c:	00260ca4 	eoreq	r0, r6, r4, lsr #25
{
    1b10:	00180000 	andseq	r0, r8, r0
    1b14:	000d0805 	andeq	r0, sp, r5, lsl #16
    pxItem->pxContainer = NULL;
    1b18:	03a50500 			@ <UNDEFINED> instruction: 0x03a50500
}
    1b1c:	000000b6 	strheq	r0, [r0], -r6
    1b20:	00008d14 	andeq	r8, r0, r4, lsl sp
    1b24:	00013b00 	andeq	r3, r1, r0, lsl #22
{
    1b28:	00371500 	eorseq	r1, r7, r0, lsl #10
    1b2c:	27ff0000 	ldrbcs	r0, [pc, r0]!
    ListItem_t * const pxIndex = pxList->pxIndex;
    1b30:	0fe10100 	svceq	0x00e10100
    1b34:	245f0000 	ldrbcs	r0, [pc], #-0	@ 1b3c <vListInsertEnd+0x16>
    pxNewListItem->pxNext = pxIndex;
    1b38:	0000012a 	andeq	r0, r0, sl, lsr #2
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1b3c:	24640305 	strbtcs	r0, [r4], #-773	@ 0xfffffcfb
    1b40:	800b0000 	andhi	r0, fp, r0
    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1b44:	0800000d 	stmdaeq	r0, {r0, r2, r3}
    1b48:	01736401 	cmneq	r3, r1, lsl #8
    pxIndex->pxPrevious = pxNewListItem;
    1b4c:	3e040000 	cdpcc	0, 0, cr0, cr4, cr0, {0}
    1b50:	0100000f 	tsteq	r0, pc
    pxNewListItem->pxContainer = pxList;
    1b54:	01731b66 	cmneq	r3, r6, ror #22
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems + 1U );
    1b58:	04000000 	streq	r0, [r0], #-0
    1b5c:	00000f76 	andeq	r0, r0, r6, ror pc
    1b60:	260c6701 	strcs	r6, [ip], -r1, lsl #14
}
    1b64:	04000000 	streq	r0, [r0], #-0
    1b68:	014c0600 	cmpeq	ip, r0, lsl #12
{
    1b6c:	6f050000 	svcvs	0x00050000
    1b70:	0100000e 	tsteq	r0, lr
    1b74:	014c0368 	cmpeq	ip, r8, ror #6
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1b78:	bc010000 	stclt	0, cr0, [r1], {-0}
    if( xValueOfInsertion == portMAX_DELAY )
    1b7c:	9e00000d 	cdpls	0, 0, cr0, cr0, cr13, {0}
    1b80:	00003215 	andeq	r3, r0, r5, lsl r2
        pxIterator = pxList->xListEnd.pxPrevious;
    1b84:	84030500 	strhi	r0, [r3], #-1280	@ 0xfffffb00
    1b88:	01000023 	tsteq	r0, r3, lsr #32
        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1b8c:	00000f81 	andeq	r0, r0, r1, lsl #31
    1b90:	017824a1 	cmneq	r8, r1, lsr #9
    1b94:	03050000 	movweq	r0, #20480	@ 0x5000
    1b98:	00004c64 	andeq	r4, r0, r4, ror #24
    1b9c:	000d3901 	andeq	r3, sp, r1, lsl #18
    1ba0:	b726a200 	strlt	sl, [r6, -r0, lsl #4]!
    1ba4:	05000001 	streq	r0, [r0, #-1]
    pxNewListItem->pxNext = pxIterator->pxNext;
    1ba8:	004c6c03 	subeq	r6, ip, r3, lsl #24
    1bac:	01780600 	cmneq	r8, r0, lsl #12
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1bb0:	ef010000 	svc	0x00010000
    1bb4:	a600000e 	strge	r0, [r0], -lr
    pxNewListItem->pxPrevious = pxIterator;
    1bb8:	0000261f 	andeq	r2, r0, pc, lsl r6
    pxIterator->pxNext = pxNewListItem;
    1bbc:	70030500 	andvc	r0, r3, r0, lsl #10
    1bc0:	0100004c 	tsteq	r0, ip, asr #32
    pxNewListItem->pxContainer = pxList;
    1bc4:	00000ce9 	andeq	r0, r0, r9, ror #25
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems + 1U );
    1bc8:	00261fa7 	eoreq	r1, r6, r7, lsr #31
    1bcc:	03050000 	movweq	r0, #20480	@ 0x5000
    1bd0:	00004c74 	andeq	r4, r0, r4, ror ip
}
    1bd4:	000e7b01 	andeq	r7, lr, r1, lsl #22
    1bd8:	261fa800 	ldrcs	sl, [pc], -r0, lsl #16
{
    1bdc:	05000000 	streq	r0, [r0, #-0]
    1be0:	004c7803 	subeq	r7, ip, r3, lsl #16
    List_t * const pxList = pxItemToRemove->pxContainer;
    1be4:	0f5d0100 	svceq	0x005d0100
    1be8:	1fa90000 	svcne	0x00a90000
    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1bec:	00000026 	andeq	r0, r0, r6, lsr #32
    1bf0:	4c7c0305 	ldclmi	3, cr0, [ip], #-20	@ 0xffffffec
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1bf4:	480c0000 	stmdami	ip, {}	@ <UNPREDICTABLE>
    1bf8:	74000001 	strvc	r0, [r0], #-1
    1bfc:	0003310c 	andeq	r3, r3, ip, lsl #2
    if( pxList->pxIndex == pxItemToRemove )
    1c00:	13167300 	tstne	r6, #0, 6
    1c04:	07000001 	streq	r0, [r0, -r1]
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1c08:	00840921 	addeq	r0, r4, r1, lsr #18
    1c0c:	022c0000 	eoreq	r0, ip, #0
    pxItemToRemove->pxContainer = NULL;
    1c10:	84080000 	strhi	r0, [r8], #-0
    1c14:	08000000 	stmdaeq	r0, {}	@ <UNPREDICTABLE>
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems - 1U );
    1c18:	0000003e 	andeq	r0, r0, lr, lsr r0
    1c1c:	00002608 	andeq	r2, r0, r8, lsl #12
    return pxList->uxNumberOfItems;
    1c20:	52170000 	andspl	r0, r7, #0
}
    1c24:	06000009 	streq	r0, [r0], -r9
    1c28:	a50c0696 	strge	r0, [ip, #-1686]	@ 0xfffff96a
    1c2c:	18000000 	stmdane	r0, {}	@ <UNPREDICTABLE>
{
    1c30:	000004ca 	andeq	r0, r0, sl, asr #9
    1c34:	06065e06 	streq	r5, [r6], -r6, lsl #28
    void * pvReturn = NULL;
    1c38:	000e3209 	andeq	r3, lr, r9, lsl #4
    size_t xAllocatedBlockSize = 0;
    1c3c:	d8027500 	stmdale	r2, {r8, sl, ip, sp, lr}
    if( xWantedSize > 0 )
    1c40:	40000020 	andmi	r0, r0, r0, lsr #32
    1c44:	01000000 	mrseq	r0, (UNDEF: 0)
        if( heapADD_WILL_OVERFLOW( xWantedSize, xHeapStructSize ) == 0 )
    1c48:	0fc80d9c 	svceq	0x00c80d9c
    1c4c:	023c0000 	eorseq	r0, ip, #0
            xWantedSize += xHeapStructSize;
    1c50:	0000201c 	andeq	r2, r0, ip, lsl r0
    1c54:	000000bc 	strheq	r0, [r0], -ip
            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
    1c58:	02b49c01 	adcseq	r9, r4, #256	@ 0x100
    1c5c:	dd070000 	stcle	0, cr0, [r7, #-0]
    1c60:	3c00000c 	stccc	0, cr0, [r0], {12}
                xAdditionalRequiredSize = portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK );
    1c64:	02b42702 	adcseq	r2, r4, #524288	@ 0x80000
    1c68:	91020000 	mrsls	r0, (UNDEF: 2)
    1c6c:	0d140364 	ldceq	3, cr0, [r4, #-400]	@ 0xfffffe70
                if( heapADD_WILL_OVERFLOW( xWantedSize, xAdditionalRequiredSize ) == 0 )
    1c70:	023e0000 	eorseq	r0, lr, #0
    1c74:	0001b713 	andeq	fp, r1, r3, lsl r7
                    xWantedSize += xAdditionalRequiredSize;
    1c78:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
    1c7c:	000f8803 	andeq	r8, pc, r3, lsl #16
    1c80:	0c023f00 	stceq	15, cr3, [r2], {-0}
                    xWantedSize = 0;
    1c84:	00000026 	andeq	r0, r0, r6, lsr #32
            xWantedSize = 0;
    1c88:	03709102 	cmneq	r0, #-2147483648	@ 0x80000000
    vTaskSuspendAll();
    1c8c:	00000e46 	andeq	r0, r0, r6, asr #28
        if( pxEnd == NULL )
    1c90:	2619023f 			@ <UNDEFINED> instruction: 0x2619023f
    1c94:	02000000 	andeq	r0, r0, #0
            prvHeapInit();
    1c98:	1c036c91 	stcne	12, cr6, [r3], {145}	@ 0x91
        if( heapBLOCK_SIZE_IS_VALID( xWantedSize ) != 0 )
    1c9c:	3f00000d 	svccc	0x0000000d
    1ca0:	00262702 	eoreq	r2, r6, r2, lsl #14
            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    1ca4:	91020000 	mrsls	r0, (UNDEF: 2)
    1ca8:	1e060068 	cdpne	0, 0, cr0, cr6, cr8, {3}
    1cac:	0e000001 	cdpeq	0, 0, cr0, cr0, cr1, {0}
    1cb0:	00000d3f 	andeq	r0, r0, pc, lsr sp
                pxPreviousBlock = &xStart;
    1cb4:	1f6c01f8 	svcne	0x006c01f8
                pxBlock = heapPROTECT_BLOCK_POINTER( xStart.pxNextFreeBlock );
    1cb8:	00b00000 	adcseq	r0, r0, r0
                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != heapPROTECT_BLOCK_POINTER( NULL ) ) )
    1cbc:	9c010000 	stcls	0, cr0, [r1], {-0}
                    pxPreviousBlock = pxBlock;
    1cc0:	000002fc 	strdeq	r0, [r0], -ip
                    pxBlock = heapPROTECT_BLOCK_POINTER( pxBlock->pxNextFreeBlock );
    1cc4:	000f2e07 	andeq	r2, pc, r7, lsl #28
                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != heapPROTECT_BLOCK_POINTER( NULL ) ) )
    1cc8:	3701f800 	strcc	pc, [r1, -r0, lsl #16]
    1ccc:	000001b7 			@ <UNDEFINED> instruction: 0x000001b7
    1cd0:	036c9102 	cmneq	ip, #-2147483648	@ 0x80000000
    1cd4:	00000cb4 			@ <UNDEFINED> instruction: 0x00000cb4
    1cd8:	b71301fa 			@ <UNDEFINED> instruction: 0xb71301fa
                if( pxBlock != pxEnd )
    1cdc:	02000001 	andeq	r0, r0, #1
    1ce0:	700a7491 	mulvc	sl, r1, r4
                    pvReturn = ( void * ) ( ( ( uint8_t * ) heapPROTECT_BLOCK_POINTER( pxPreviousBlock->pxNextFreeBlock ) ) + xHeapStructSize );
    1ce4:	fb006375 	blx	1aac2 <xNumberOfSuccessfulFrees+0x15e46>
    1ce8:	00b10f01 	adcseq	r0, r1, r1, lsl #30
    1cec:	91020000 	mrsls	r0, (UNDEF: 2)
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1cf0:	220e0070 	andcs	r0, lr, #112	@ 0x70
    1cf4:	c800000f 	stmdagt	r0, {r0, r1, r2, r3}
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1cf8:	001eb801 	andseq	fp, lr, r1, lsl #16
    1cfc:	0000b400 	andeq	fp, r0, r0, lsl #8
    1d00:	4e9c0100 	fmlmie	f0, f4, f0
    1d04:	03000003 	movweq	r0, #3
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    1d08:	00000f95 	muleq	r0, r5, pc	@ <UNPREDICTABLE>
    1d0c:	b71301ca 	ldrlt	r0, [r3, -sl, asr #3]
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1d10:	02000001 	andeq	r0, r0, #1
    1d14:	8d036891 	stchi	8, cr6, [r3, #-580]	@ 0xfffffdbc
    1d18:	cb00000d 	blgt	1d54 <pvPortMalloc+0x124>
                        pxBlock->xBlockSize = xWantedSize;
    1d1c:	00991b01 	addseq	r1, r9, r1, lsl #22
                        pxNewBlockLink->pxNextFreeBlock = pxPreviousBlock->pxNextFreeBlock;
    1d20:	91020000 	mrsls	r0, (UNDEF: 2)
    1d24:	0de00374 	stcleq	3, cr0, [r0, #464]!	@ 0x1d0
                        pxPreviousBlock->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxNewBlockLink );
    1d28:	01cb0000 	biceq	r0, fp, r0
    1d2c:	0000992b 	andeq	r9, r0, fp, lsr #18
                    xFreeBytesRemaining -= pxBlock->xBlockSize;
    1d30:	6c910200 	lfmvs	f0, 4, [r1], {0}
    1d34:	000f4e03 	andeq	r4, pc, r3, lsl #28
    1d38:	0c01cc00 	stceq	12, cr12, [r1], {-0}
                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    1d3c:	00000026 	andeq	r0, r0, r6, lsr #32
    1d40:	00709102 	rsbseq	r9, r0, r2, lsl #2
    1d44:	000eb519 	andeq	fp, lr, r9, lsl r5
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    1d48:	01b50100 			@ <UNDEFINED> instruction: 0x01b50100
    1d4c:	00008408 	andeq	r8, r0, r8, lsl #8
                    xAllocatedBlockSize = pxBlock->xBlockSize;
    1d50:	001e5800 	andseq	r5, lr, r0, lsl #16
    1d54:	00006000 	andeq	r6, r0, r0
                    heapALLOCATE_BLOCK( pxBlock );
    1d58:	969c0100 	ldrls	r0, [ip], r0, lsl #2
    1d5c:	07000003 	streq	r0, [r0, -r3]
    1d60:	00000f90 	muleq	r0, r0, pc	@ <UNPREDICTABLE>
                    pxBlock->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( NULL );
    1d64:	261d01b5 			@ <UNDEFINED> instruction: 0x261d01b5
                    xNumberOfSuccessfulAllocations++;
    1d68:	02000000 	andeq	r0, r0, #0
    1d6c:	49076c91 	stmdbmi	r7, {r0, r4, r7, sl, fp, sp, lr}
    1d70:	b600000e 	strlt	r0, [r0], -lr
    ( void ) xTaskResumeAll();
    1d74:	00261d01 	eoreq	r1, r6, r1, lsl #26
}
    1d78:	91020000 	mrsls	r0, (UNDEF: 2)
    1d7c:	76700a68 	ldrbtvc	r0, [r0], -r8, ror #20
    1d80:	0c01b800 	stceq	8, cr11, [r1], {-0}
    1d84:	00000084 	andeq	r0, r0, r4, lsl #1
    1d88:	00749102 	rsbseq	r9, r4, r2, lsl #2
    1d8c:	000fb209 	andeq	fp, pc, r9, lsl #4
    1d90:	4c01af00 	stcmi	15, cr10, [r1], {-0}
{
    1d94:	0c00001e 	stceq	0, cr0, [r0], {30}
    1d98:	01000000 	mrseq	r0, (UNDEF: 0)
    uint8_t * puc = ( uint8_t * ) pv;
    1d9c:	0d5a099c 	vldreq.16	s1, [sl, #-312]	@ 0xfffffec8	@ <UNPREDICTABLE>
    if( pv != NULL )
    1da0:	01a90000 			@ <UNDEFINED> instruction: 0x01a90000
    1da4:	00001e30 	andeq	r1, r0, r0, lsr lr
        puc -= xHeapStructSize;
    1da8:	0000001c 	andeq	r0, r0, ip, lsl r0
    1dac:	4f0f9c01 	svcmi	0x000f9c01
        pxLink = ( void * ) puc;
    1db0:	a300000e 	movwge	r0, #14
        if( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 )
    1db4:	00002601 	andeq	r2, r0, r1, lsl #12
    1db8:	001e1c00 	andseq	r1, lr, r0, lsl #24
            if( pxLink->pxNextFreeBlock == heapPROTECT_BLOCK_POINTER( NULL ) )
    1dbc:	00001400 	andeq	r1, r0, r0, lsl #8
    1dc0:	0f9c0100 	svceq	0x009c0100
                heapFREE_BLOCK( pxLink );
    1dc4:	00000dfc 	strdeq	r0, [r0], -ip
    1dc8:	0026019d 	mlaeq	r6, sp, r1, r0
    1dcc:	1e080000 	cdpne	0, 0, cr0, cr8, cr0, {0}
                vTaskSuspendAll();
    1dd0:	00140000 	andseq	r0, r4, r0
                    xFreeBytesRemaining += pxLink->xBlockSize;
    1dd4:	9c010000 	stcls	0, cr0, [r1], {-0}
    1dd8:	0009a80d 	andeq	sl, r9, sp, lsl #16
    1ddc:	94016200 	strls	r6, [r1], #-512	@ 0xfffffe00
    1de0:	7400001d 	strvc	r0, [r0], #-29	@ 0xffffffe3
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    1de4:	01000000 	mrseq	r0, (UNDEF: 0)
                    xNumberOfSuccessfulFrees++;
    1de8:	0004259c 	muleq	r4, ip, r5
    1dec:	76701a00 	ldrbtvc	r1, [r0], -r0, lsl #20
    1df0:	01620100 	cmneq	r2, r0, lsl #2
                ( void ) xTaskResumeAll();
    1df4:	00008418 	andeq	r8, r0, r8, lsl r4
}
    1df8:	6c910200 	lfmvs	f0, 4, [r1], {0}
    1dfc:	6375700a 	cmnvs	r5, #10
    1e00:	0f016400 	svceq	0x00016400
    1e04:	000000b1 	strheq	r0, [r0], -r1
{
    1e08:	03749102 	cmneq	r4, #-2147483648	@ 0x80000000
    return xFreeBytesRemaining;
    1e0c:	00000fda 	ldrdeq	r0, [r0], -sl
}
    1e10:	b7130165 	ldrlt	r0, [r3, -r5, ror #2]
    1e14:	02000001 	andeq	r0, r0, #1
    1e18:	1b007091 	blne	1e064 <xNumberOfSuccessfulFrees+0x193e8>
{
    1e1c:	00000bd9 	ldrdeq	r0, [r0], -r9
    return xMinimumEverFreeBytesRemaining;
    1e20:	8408ad01 	strhi	sl, [r8], #-3329	@ 0xfffff2ff
}
    1e24:	30000000 	andcc	r0, r0, r0
    1e28:	6400001c 	strvs	r0, [r0], #-28	@ 0xffffffe4
    1e2c:	01000001 	tsteq	r0, r1
{
    1e30:	0fa61c9c 	svceq	0x00a61c9c
    xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    1e34:	ad010000 	stcge	0, cr0, [r1, #-0]
    1e38:	0000261d 	andeq	r2, r0, sp, lsl r6
}
    1e3c:	5c910200 	lfmpl	f0, 4, [r1], {0}
    1e40:	000d1401 	andeq	r1, sp, r1, lsl #8
    1e44:	b713af00 	ldrlt	sl, [r3, -r0, lsl #30]
    1e48:	02000001 	andeq	r0, r0, #1
{
    1e4c:	cd017491 	cfstrsgt	mvf7, [r1, #-580]	@ 0xfffffdbc
}
    1e50:	b000000c 	andlt	r0, r0, ip
    1e54:	0001b713 	andeq	fp, r1, r3, lsl r7
{
    1e58:	70910200 	addsvc	r0, r1, r0, lsl #4
    1e5c:	000ded01 	andeq	lr, sp, r1, lsl #26
    1e60:	b713b100 	ldrlt	fp, [r3, -r0, lsl #2]
    void * pv = NULL;
    1e64:	02000001 	andeq	r0, r0, #1
    if( heapMULTIPLY_WILL_OVERFLOW( xNum, xSize ) == 0 )
    1e68:	29016091 	stmdbcs	r1, {r0, r4, r7, sp, lr}
    1e6c:	b200000e 	andlt	r0, r0, #14
    1e70:	0000840c 	andeq	r8, r0, ip, lsl #8
    1e74:	6c910200 	lfmvs	f0, 4, [r1], {0}
    1e78:	000e1101 	andeq	r1, lr, r1, lsl #2
    1e7c:	260cb300 	strcs	fp, [ip], -r0, lsl #6
    1e80:	02000000 	andeq	r0, r0, #0
    1e84:	cc016491 	cfstrsgt	mvf6, [r1], {145}	@ 0x91
        pv = pvPortMalloc( xNum * xSize );
    1e88:	b400000d 	strlt	r0, [r0], #-13
    1e8c:	0000260c 	andeq	r2, r0, ip, lsl #12
    1e90:	68910200 	ldmvs	r1, {r9}
    1e94:	03070000 	movweq	r0, #28672	@ 0x7000
        if( pv != NULL )
    1e98:	00050000 	andeq	r0, r5, r0
            ( void ) memset( pv, 0, xNum * xSize );
    1e9c:	073e0401 	ldreq	r0, [lr, -r1, lsl #8]!
    1ea0:	650c0000 	strvs	r0, [ip, #-0]
    1ea4:	1d000000 	stcne	0, cr0, [r0, #-0]
    1ea8:	0000105a 	andeq	r1, r0, sl, asr r0
    1eac:	00000007 	andeq	r0, r0, r7
}
    1eb0:	00002118 	andeq	r2, r0, r8, lsl r1
    1eb4:	00000260 	andeq	r0, r0, r0, ror #4
{
    1eb8:	00001073 	andeq	r1, r0, r3, ror r0
    1ebc:	6905040d 	stmdbvs	r5, {r0, r2, r3, sl}
    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
    1ec0:	0100746e 	tsteq	r0, lr, ror #8
    uxStartAddress = ( portPOINTER_SIZE_TYPE ) ucHeap;
    1ec4:	00580704 	subseq	r0, r8, r4, lsl #14
    if( ( uxStartAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
    1ec8:	08010000 	stmdaeq	r1, {}	@ <UNPREDICTABLE>
    1ecc:	00002d05 	andeq	r2, r0, r5, lsl #26
    1ed0:	04080100 	streq	r0, [r8], #-256	@ 0xffffff00
        uxStartAddress += ( portBYTE_ALIGNMENT - 1 );
    1ed4:	000000e8 	andeq	r0, r0, r8, ror #1
        uxStartAddress &= ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK );
    1ed8:	c2060101 	andgt	r0, r6, #1073741824	@ 0x40000000
    1edc:	01000000 	mrseq	r0, (UNDEF: 0)
        xTotalHeapSize -= ( size_t ) ( uxStartAddress - ( portPOINTER_SIZE_TYPE ) ucHeap );
    1ee0:	00f40502 	rscseq	r0, r4, r2, lsl #10
    1ee4:	04010000 	streq	r0, [r1], #-0
    1ee8:	00003205 	andeq	r3, r0, r5, lsl #4
    xStart.pxNextFreeBlock = ( void * ) heapPROTECT_BLOCK_POINTER( uxStartAddress );
    1eec:	08010100 	stmdaeq	r1, {r8}
    1ef0:	000000c0 	andeq	r0, r0, r0, asr #1
    xStart.xBlockSize = ( size_t ) 0;
    1ef4:	3b070201 	blcc	1c2700 <xNumberOfSuccessfulFrees+0x1bda84>
    uxEndAddress = uxStartAddress + ( portPOINTER_SIZE_TYPE ) xTotalHeapSize;
    1ef8:	02000000 	andeq	r0, r0, #0
    1efc:	00000390 	muleq	r0, r0, r3
    uxEndAddress -= ( portPOINTER_SIZE_TYPE ) xHeapStructSize;
    1f00:	76193403 	ldrvc	r3, [r9], -r3, lsl #8
    1f04:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    uxEndAddress &= ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK );
    1f08:	00000065 	andeq	r0, r0, r5, rrx
    1f0c:	53070401 	movwpl	r0, #29697	@ 0x7401
    pxEnd = ( BlockLink_t * ) uxEndAddress;
    1f10:	01000000 	mrseq	r0, (UNDEF: 0)
    1f14:	004e0708 	subeq	r0, lr, r8, lsl #14
    pxEnd->xBlockSize = 0;
    1f18:	97020000 	strls	r0, [r2, -r0]
    1f1c:	04000007 	streq	r0, [r0], #-7
    pxEnd->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( NULL );
    1f20:	00901124 	addseq	r1, r0, r4, lsr #2
    1f24:	95030000 	strls	r0, [r3, #-0]
    pxFirstFreeBlock = ( BlockLink_t * ) uxStartAddress;
    1f28:	0f000000 	svceq	0x00000000
    pxFirstFreeBlock->xBlockSize = ( size_t ) ( uxEndAddress - ( portPOINTER_SIZE_TYPE ) pxFirstFreeBlock );
    1f2c:	000000a0 	andeq	r0, r0, r0, lsr #1
    1f30:	0000a010 	andeq	sl, r0, r0, lsl r0
    pxFirstFreeBlock->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxEnd );
    1f34:	04110000 	ldreq	r0, [r1], #-0
    1f38:	00022f02 	andeq	r2, r2, r2, lsl #30
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    1f3c:	1a3a0200 	bne	e82744 <xNumberOfSuccessfulFrees+0xe7dac8>
    1f40:	00000065 	andeq	r0, r0, r5, rrx
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    1f44:	00060502 	andeq	r0, r6, r2, lsl #10
    1f48:	1a3b0200 	bne	ec2750 <xNumberOfSuccessfulFrees+0xebdad4>
}
    1f4c:	00000050 	andeq	r0, r0, r0, asr r0
    1f50:	00060402 	andeq	r0, r6, r2, lsl #8
    1f54:	1a3c0200 	bne	f0275c <xNumberOfSuccessfulFrees+0xefdae0>
    1f58:	00000076 	andeq	r0, r0, r6, ror r0
    1f5c:	c9080101 	stmdbgt	r8, {r0, r8}
    1f60:	03000000 	movweq	r0, #0
    1f64:	000000a2 	andeq	r0, r0, r2, lsr #1
    1f68:	00109702 	andseq	r9, r0, r2, lsl #14
{
    1f6c:	12260100 	eorne	r0, r6, #0, 2
    1f70:	000000e3 	andeq	r0, r0, r3, ror #1
    for( pxIterator = &xStart; heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) < pxBlockToInsert; pxIterator = heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
    1f74:	0000d208 	andeq	sp, r0, r8, lsl #4
    1f78:	00e80300 	rsceq	r0, r8, r0, lsl #6
    1f7c:	09120000 	ldmdbeq	r2, {}	@ <UNPREDICTABLE>
    1f80:	0000102f 	andeq	r1, r0, pc, lsr #32
    1f84:	00ba148d 	adcseq	r1, sl, sp, lsl #9
    1f88:	03050000 	movweq	r0, #20480	@ 0x5000
    puc = ( uint8_t * ) pxIterator;
    1f8c:	00002388 	andeq	r2, r0, r8, lsl #7
    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    1f90:	0002d213 	andeq	sp, r2, r3, lsl r2
    1f94:	0dad0500 	cfstr32eq	mvfx0, [sp]
    1f98:	0000ae0c 	andeq	sl, r0, ip, lsl #28
        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    1f9c:	08be1400 	ldmeq	lr!, {sl, ip}
    1fa0:	08050000 	stmdaeq	r5, {}	@ <UNPREDICTABLE>
    1fa4:	41041b0e 	tstmi	r4, lr, lsl #22
    1fa8:	e7000010 	smlad	r0, r0, r0, r0
        pxBlockToInsert = pxIterator;
    1fac:	23442002 	movtcs	r2, #16386	@ 0x4002
    puc = ( uint8_t * ) pxBlockToInsert;
    1fb0:	00340000 	eorseq	r0, r4, r0
    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
    1fb4:	9c010000 	stcls	0, cr0, [r1], {-0}
    1fb8:	00101b15 	andseq	r1, r0, r5, lsl fp
    1fbc:	01eb0100 	mvneq	r0, r0, lsl #2
    1fc0:	0022fe06 	eoreq	pc, r2, r6, lsl #28
        if( heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) != pxEnd )
    1fc4:	00004600 	andeq	r4, r0, r0, lsl #12
    1fc8:	719c0100 	orrsvc	r0, ip, r0, lsl #2
    1fcc:	16000001 	strne	r0, [r0], -r1
            pxBlockToInsert->xBlockSize += heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock )->xBlockSize;
    1fd0:	000002f4 	strdeq	r0, [r0], -r4
    1fd4:	00002304 	andeq	r2, r0, r4, lsl #6
    1fd8:	00000014 	andeq	r0, r0, r4, lsl r0
    1fdc:	0501f101 	streq	pc, [r1, #-257]	@ 0xfffffeff
            pxBlockToInsert->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock )->pxNextFreeBlock;
    1fe0:	00000157 	andeq	r0, r0, r7, asr r1
    1fe4:	0002fd05 	andeq	pc, r2, r5, lsl #26
    1fe8:	74910200 	ldrvc	r0, [r1], #512	@ 0x200
            pxBlockToInsert->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxEnd );
    1fec:	02da0600 	sbcseq	r0, sl, #0, 12
    1ff0:	232e0000 			@ <UNDEFINED> instruction: 0x232e0000
        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    1ff4:	00080000 	andeq	r0, r8, r0
    1ff8:	02020000 	andeq	r0, r2, #0
    if( pxIterator != pxBlockToInsert )
    1ffc:	02e70a05 	rsceq	r0, r7, #20480	@ 0x5000
    2000:	91020000 	mrsls	r0, (UNDEF: 2)
        pxIterator->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxBlockToInsert );
    2004:	04000070 	streq	r0, [r0], #-112	@ 0xffffff90
    2008:	00000fef 	andeq	r0, r0, pc, ror #31
}
    200c:	b80601c7 	stmdalt	r6, {r0, r1, r2, r6, r7, r8}
    2010:	46000022 	strmi	r0, [r0], -r2, lsr #32
    2014:	01000000 	mrseq	r0, (UNDEF: 0)
    2018:	01480b9c 			@ <UNDEFINED> instruction: 0x01480b9c
{
    201c:	01bb0000 			@ <UNDEFINED> instruction: 0x01bb0000
    2020:	00002284 	andeq	r2, r0, r4, lsl #5
    size_t xBlocks = 0, xMaxSize = 0, xMinSize = SIZE_MAX;
    2024:	00000034 	andeq	r0, r0, r4, lsr r0
    2028:	01b29c01 			@ <UNDEFINED> instruction: 0x01b29c01
    202c:	da060000 	ble	182034 <xNumberOfSuccessfulFrees+0x17d3b8>
    2030:	a0000002 	andge	r0, r0, r2
    vTaskSuspendAll();
    2034:	08000022 	stmdaeq	r0, {r1, r5}
        pxBlock = heapPROTECT_BLOCK_POINTER( xStart.pxNextFreeBlock );
    2038:	c2000000 	andgt	r0, r0, #0
        if( pxBlock != NULL )
    203c:	e70a0901 	str	r0, [sl, -r1, lsl #18]
    2040:	02000002 	andeq	r0, r0, #2
                xBlocks++;
    2044:	00007491 	muleq	r0, r1, r4
    2048:	0003310b 	andeq	r3, r3, fp, lsl #2
                if( pxBlock->xBlockSize > xMaxSize )
    204c:	5001aa00 	andpl	sl, r1, r0, lsl #20
    2050:	34000022 	strcc	r0, [r0], #-34	@ 0xffffffde
                    xMaxSize = pxBlock->xBlockSize;
    2054:	01000000 	mrseq	r0, (UNDEF: 0)
    2058:	0001e19c 	muleq	r1, ip, r1
                if( pxBlock->xBlockSize < xMinSize )
    205c:	02f40600 	rscseq	r0, r4, #0, 12
    2060:	22560000 	subscs	r0, r6, #0
                    xMinSize = pxBlock->xBlockSize;
    2064:	00140000 	andseq	r0, r4, r0
    2068:	01ac0000 			@ <UNDEFINED> instruction: 0x01ac0000
                pxBlock = heapPROTECT_BLOCK_POINTER( pxBlock->pxNextFreeBlock );
    206c:	02fd0505 	rscseq	r0, sp, #20971520	@ 0x1400000
            while( pxBlock != pxEnd )
    2070:	91020000 	mrsls	r0, (UNDEF: 2)
    2074:	04000074 	streq	r0, [r0], #-116	@ 0xffffff8c
    2078:	00000be6 	andeq	r0, r0, r6, ror #23
    ( void ) xTaskResumeAll();
    207c:	440601a2 	strmi	r0, [r6], #-418	@ 0xfffffe5e
    pxHeapStats->xSizeOfLargestFreeBlockInBytes = xMaxSize;
    2080:	0c000022 	stceq	0, cr0, [r0], {34}	@ 0x22
    pxHeapStats->xSizeOfSmallestFreeBlockInBytes = xMinSize;
    2084:	01000000 	mrseq	r0, (UNDEF: 0)
    2088:	015a179c 			@ <UNDEFINED> instruction: 0x015a179c
    pxHeapStats->xNumberOfFreeBlocks = xBlocks;
    208c:	0c010000 	stceq	0, cr0, [r1], {-0}
    taskENTER_CRITICAL();
    2090:	00ae0c01 	adceq	r0, lr, r1, lsl #24
        pxHeapStats->xAvailableHeapSpaceInBytes = xFreeBytesRemaining;
    2094:	21ea0000 	mvncs	r0, r0
    2098:	005a0000 	subseq	r0, sl, r0
        pxHeapStats->xNumberOfSuccessfulAllocations = xNumberOfSuccessfulAllocations;
    209c:	9c010000 	stcls	0, cr0, [r1], {-0}
    20a0:	00000229 	andeq	r0, r0, r9, lsr #4
        pxHeapStats->xNumberOfSuccessfulFrees = xNumberOfSuccessfulFrees;
    20a4:	0021f018 	eoreq	pc, r1, r8, lsl r0	@ <UNPREDICTABLE>
    20a8:	00000600 	andeq	r0, r0, r0, lsl #12
        pxHeapStats->xMinimumEverFreeBytesRemaining = xMinimumEverFreeBytesRemaining;
    20ac:	10891900 	addne	r1, r9, r0, lsl #18
    20b0:	1c010000 	stcne	0, cr0, [r1], {-0}
    taskEXIT_CRITICAL();
    20b4:	022e2101 	eoreq	r2, lr, #1073741824	@ 0x40000000
}
    20b8:	91020000 	mrsls	r0, (UNDEF: 2)
    20bc:	03000074 	movweq	r0, #116	@ 0x74
    20c0:	000000de 	ldrdeq	r0, [r0], -lr
    20c4:	00022908 	andeq	r2, r2, r8, lsl #18
    20c8:	10b11a00 	adcsne	r1, r1, r0, lsl #20
    20cc:	f7010000 			@ <UNDEFINED> instruction: 0xf7010000
    20d0:	0021ca0d 	eoreq	ip, r1, sp, lsl #20
    20d4:	00002000 	andeq	r2, r0, r0
{
    20d8:	1b9c0100 	blne	fe7024e0 <__StackTop+0xde7004e0>
    pxEnd = NULL;
    20dc:	000010a1 	andeq	r1, r0, r1, lsr #1
    20e0:	a206e401 	andge	lr, r6, #16777216	@ 0x1000000
    xFreeBytesRemaining = ( size_t ) 0U;
    20e4:	28000021 	stmdacs	r0, {r0, r5}
    xMinimumEverFreeBytesRemaining = ( size_t ) 0U;
    20e8:	01000000 	mrseq	r0, (UNDEF: 0)
    20ec:	10021c9c 	mulne	r2, ip, ip
    xNumberOfSuccessfulAllocations = ( size_t ) 0U;
    20f0:	ca010000 	bgt	420f8 <xNumberOfSuccessfulFrees+0x3d47c>
    xNumberOfSuccessfulFrees = ( size_t ) 0U;
    20f4:	0021700d 	eoreq	r7, r1, sp
    20f8:	00003200 	andeq	r3, r0, r0, lsl #4
}
    20fc:	959c0100 	ldrls	r0, [ip, #256]	@ 0x100
    2100:	09000002 	stmdbeq	r0, {r1}
    2104:	00001013 	andeq	r1, r0, r3, lsl r0
    2108:	007117cc 	rsbseq	r1, r1, ip, asr #15
    210c:	91020000 	mrsls	r0, (UNDEF: 2)
    2110:	02f41d70 	rscseq	r1, r4, #112, 26	@ 0x1c00
    2114:	217a0000 	cmncs	sl, r0
{
    2118:	00140000 	andseq	r0, r4, r0
    211c:	d5010000 	strle	r0, [r1, #-0]
    2120:	02fd0505 	rscseq	r0, sp, #20971520	@ 0x1400000
    pxTopOfStack--;                                                      /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
    2124:	91020000 	mrsls	r0, (UNDEF: 2)
    2128:	1e000074 	mcrne	0, 0, r0, cr0, cr4, {3}
    *pxTopOfStack = portINITIAL_XPSR;                                    /* xPSR */
    212c:	000006fd 	strdeq	r0, [r0], -sp
    2130:	cd0fb601 	stcgt	6, cr11, [pc, #-4]	@ 2134 <pxPortInitialiseStack+0x1c>
    pxTopOfStack--;
    2134:	18000000 	stmdane	r0, {}	@ <UNPREDICTABLE>
    *pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK; /* PC */
    2138:	58000021 	stmdapl	r0, {r0, r5}
    213c:	01000000 	mrseq	r0, (UNDEF: 0)
    2140:	0002da9c 	muleq	r2, ip, sl
    pxTopOfStack--;
    2144:	0bcc0700 	bleq	ff303d4c <__StackTop+0xdf301d4c>
    *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;             /* LR */
    2148:	34b60000 	ldrtcc	r0, [r6], #0
    214c:	000000cd 	andeq	r0, r0, sp, asr #1
    pxTopOfStack -= 5;                                                   /* R12, R3, R2 and R1. */
    2150:	07749102 	ldrbeq	r9, [r4, -r2, lsl #2]!
    *pxTopOfStack = ( StackType_t ) pvParameters;                        /* R0 */
    2154:	00000fe8 	andeq	r0, r0, r8, ror #31
    2158:	008435b7 			@ <UNDEFINED> instruction: 0x008435b7
    pxTopOfStack -= 8;                                                   /* R11, R10, R9, R8, R7, R6, R5 and R4. */
    215c:	91020000 	mrsls	r0, (UNDEF: 2)
    return pxTopOfStack;
    2160:	093a0770 	ldmdbeq	sl!, {r4, r5, r6, r8, r9, sl}
}
    2164:	2db80000 	ldccs	0, cr0, [r8]
    2168:	000000a0 	andeq	r0, r0, r0, lsr #1
    216c:	006c9102 	rsbeq	r9, ip, r2, lsl #2
{
    2170:	0003211f 	andeq	r2, r3, pc, lsl r1
    2174:	1ef80200 	cdpne	2, 15, cr0, cr8, cr0, {0}
    volatile uint32_t ulDummy = 0UL;
    2178:	0002f403 	andeq	pc, r2, r3, lsl #8
    __asm volatile
    217c:	084a2000 	stmdaeq	sl, {sp}^
    2180:	f8020000 			@ <UNDEFINED> instruction: 0xf8020000
    2184:	00006538 	andeq	r6, r0, r8, lsr r5
    2188:	f4210000 	vld4.8	{d0-d3}, [r1], r0
}
    218c:	02000009 	andeq	r0, r0, #9
    while( ulDummy == 0 )
    2190:	22031ed4 	andcs	r1, r3, #212, 28	@ 0xd40
    2194:	000005f7 	strdeq	r0, [r0], -r7
}
    2198:	650ed602 	strvs	sp, [lr, #-1538]	@ 0xfffff9fe
    219c:	00000000 	andeq	r0, r0, r0
	...

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
   0:	10001101 	andne	r1, r0, r1, lsl #2
   4:	12011106 	andne	r1, r1, #-2147483647	@ 0x80000001
   8:	1b0e0301 	blne	380c14 <xNumberOfSuccessfulFrees+0x37bf98>
   c:	130e250e 	movwne	r2, #58638	@ 0xe50e
  10:	00000005 	andeq	r0, r0, r5
  14:	0b002401 	bleq	9020 <xNumberOfSuccessfulFrees+0x43a4>
  18:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
  1c:	0200000e 	andeq	r0, r0, #14
  20:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
  24:	0e030b13 	vmoveq.32	d3[0], r0
  28:	01110e1b 	tsteq	r1, fp, lsl lr
  2c:	17100612 			@ <UNDEFINED> instruction: 0x17100612
  30:	24030000 	strcs	r0, [r3], #-0
  34:	3e0b0b00 	vmlacc.f64	d0, d11, d0
  38:	0008030b 	andeq	r0, r8, fp, lsl #6
  3c:	002e0400 	eoreq	r0, lr, r0, lsl #8
  40:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
  44:	053b0b3a 	ldreq	r0, [fp, #-2874]!	@ 0xfffff4c6
  48:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
  4c:	0000193c 	andeq	r1, r0, ip, lsr r9
  50:	3f002e05 	svccc	0x00002e05
  54:	3a0e0319 	bcc	380cc0 <xNumberOfSuccessfulFrees+0x37c044>
  58:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  5c:	1201110b 	andne	r1, r1, #-1073741822	@ 0xc0000002
  60:	7c184006 	ldcvc	0, cr4, [r8], {6}
  64:	00000019 	andeq	r0, r0, r9, lsl r0
  68:	03000501 	movweq	r0, #1281	@ 0x501
  6c:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
  70:	3901213b 	stmdbcc	r1, {r0, r1, r3, r4, r5, r8, sp}
  74:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
  78:	02000018 	andeq	r0, r0, #24
  7c:	0b0b0024 	bleq	2c0114 <xNumberOfSuccessfulFrees+0x2bb498>
  80:	0e030b3e 	vmoveq.16	d3[0], r0
  84:	11030000 	mrsne	r0, (UNDEF: 3)
  88:	130e2501 	movwne	r2, #58625	@ 0xe501
  8c:	1b0e030b 	blne	380cc0 <xNumberOfSuccessfulFrees+0x37c044>
  90:	1201110e 	andne	r1, r1, #-2147483645	@ 0x80000003
  94:	00171006 	andseq	r1, r7, r6
  98:	012e0400 			@ <UNDEFINED> instruction: 0x012e0400
  9c:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
  a0:	0b3b0b3a 	bleq	ec2d90 <xNumberOfSuccessfulFrees+0xebe114>
  a4:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
  a8:	01111349 	tsteq	r1, r9, asr #6
  ac:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
  b0:	1301197a 	movwne	r1, #6522	@ 0x197a
  b4:	05050000 	streq	r0, [r5, #-0]
  b8:	3a080300 	bcc	200cc0 <xNumberOfSuccessfulFrees+0x1fc044>
  bc:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
  c0:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
  c4:	06000018 			@ <UNDEFINED> instruction: 0x06000018
  c8:	08030034 	stmdaeq	r3, {r2, r4, r5}
  cc:	0b3b0b3a 	bleq	ec2dbc <xNumberOfSuccessfulFrees+0xebe140>
  d0:	13490b39 	movtne	r0, #39737	@ 0x9b39
  d4:	00001802 	andeq	r1, r0, r2, lsl #16
  d8:	03003407 	movweq	r3, #1031	@ 0x407
  dc:	3b0b3a0e 	blcc	2ce91c <xNumberOfSuccessfulFrees+0x2c9ca0>
  e0:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
  e4:	00180213 	andseq	r0, r8, r3, lsl r2
  e8:	000f0800 	andeq	r0, pc, r0, lsl #16
  ec:	00000b0b 	andeq	r0, r0, fp, lsl #22
  f0:	0b002409 	bleq	911c <xNumberOfSuccessfulFrees+0x44a0>
  f4:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
  f8:	0a000008 	beq	120 <vector_table+0x120>
  fc:	0b0b000f 	bleq	2c0140 <xNumberOfSuccessfulFrees+0x2bb4c4>
 100:	00001349 	andeq	r1, r0, r9, asr #6
 104:	00340100 	eorseq	r0, r4, r0, lsl #2
 108:	213a0e03 	teqcs	sl, r3, lsl #28
 10c:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
 110:	0213490b 	andseq	r4, r3, #180224	@ 0x2c000
 114:	02000018 	andeq	r0, r0, #24
 118:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
 11c:	3b01213a 	blcc	4860c <xNumberOfSuccessfulFrees+0x43990>
 120:	490b3905 	stmdbmi	fp, {r0, r2, r8, fp, ip, sp}
 124:	00180213 	andseq	r0, r8, r3, lsl r2
 128:	010b0300 	mrseq	r0, (UNDEF: 59)
 12c:	06120111 			@ <UNDEFINED> instruction: 0x06120111
 130:	00001301 	andeq	r1, r0, r1, lsl #6
 134:	0b000f04 	bleq	3d4c <ucHeap+0x18e8>
 138:	13490421 	movtne	r0, #37921	@ 0x9421
 13c:	26050000 	strcs	r0, [r5], -r0
 140:	00134900 	andseq	r4, r3, r0, lsl #18
 144:	000d0600 	andeq	r0, sp, r0, lsl #12
 148:	0b3a0e03 	bleq	e8395c <xNumberOfSuccessfulFrees+0xe7ece0>
 14c:	0b390b3b 	bleq	e42e40 <xNumberOfSuccessfulFrees+0xe3e1c4>
 150:	0b381349 	bleq	e04e7c <xNumberOfSuccessfulFrees+0xe00200>
 154:	16070000 	strne	r0, [r7], -r0
 158:	3a0e0300 	bcc	380d60 <xNumberOfSuccessfulFrees+0x37c0e4>
 15c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 160:	0013490b 	andseq	r4, r3, fp, lsl #18
 164:	00050800 	andeq	r0, r5, r0, lsl #16
 168:	00001349 	andeq	r1, r0, r9, asr #6
 16c:	11010b09 	tstne	r1, r9, lsl #22
 170:	00061201 	andeq	r1, r6, r1, lsl #4
 174:	00240a00 	eoreq	r0, r4, r0, lsl #20
 178:	0b3e0b0b 	bleq	f82dac <xNumberOfSuccessfulFrees+0xf7e130>
 17c:	00000e03 	andeq	r0, r0, r3, lsl #28
 180:	4900350b 	stmdbmi	r0, {r0, r1, r3, r8, sl, ip, sp}
 184:	0c000013 	stceq	0, cr0, [r0], {19}
 188:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
 18c:	213a0e03 	teqcs	sl, r3, lsl #28
 190:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
 194:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
 198:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
{
 19c:	7c184006 	ldcvc	0, cr4, [r8], {6}
    vTaskStartScheduler();
 1a0:	00130119 	andseq	r0, r3, r9, lsl r1
    return;
 1a4:	000d0d00 	andeq	r0, sp, r0, lsl #26
void* memset(void* dst, int value, unsigned int size) {
 1a8:	213a0e03 	teqcs	sl, r3, lsl #28
 1ac:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
 1b0:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
    unsigned char *ptr = (unsigned char *)dst;
 1b4:	0e00000b 	cdpeq	0, 0, cr0, cr0, cr11, {0}
    unsigned char byte_value = (unsigned char)value;
 1b8:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
    while(size > 0){
 1bc:	213a0e03 	teqcs	sl, r3, lsl #28
        *ptr = byte_value;
 1c0:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
        ptr++;
 1c4:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
 1c8:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
        size--;
 1cc:	7a184006 	bvc	6101ec <xNumberOfSuccessfulFrees+0x60b570>
    while(size > 0){
 1d0:	00130119 	andseq	r0, r3, r9, lsl r1
 1d4:	00340f00 	eorseq	r0, r4, r0, lsl #30
 1d8:	18021331 	stmdane	r2, {r0, r4, r5, r8, r9, ip}
 1dc:	01100000 	tsteq	r0, r0
 1e0:	01134901 	tsteq	r3, r1, lsl #18
    {
 1e4:	11000013 	tstne	r0, r3, lsl r0
 1e8:	13490021 	movtne	r0, #36897	@ 0x9021
 1ec:	00000b2f 	andeq	r0, r0, pc, lsr #22
 1f0:	03011312 	movweq	r1, #4882	@ 0x1312
            pxStack = pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) );
 1f4:	3a0b0b0e 	bcc	2c2e34 <xNumberOfSuccessfulFrees+0x2be1b8>
 1f8:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 1fc:	0013010b 	andseq	r0, r3, fp, lsl #2
            if( pxStack != NULL )
 200:	00281300 	eoreq	r1, r8, r0, lsl #6
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 204:	0b1c0e03 	bleq	703a18 <xNumberOfSuccessfulFrees+0x6fed9c>
 208:	2e140000 	cdpcs	0, 1, cr0, cr4, cr0, {0}
                if( pxNewTCB != NULL )
 20c:	03193f01 	tsteq	r9, #1, 30
 210:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
                    ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 214:	0b39053b 	bleq	e41708 <xNumberOfSuccessfulFrees+0xe3ca8c>
 218:	01111927 	tsteq	r1, r7, lsr #18
                    pxNewTCB->pxStack = pxStack;
 21c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
 220:	1301197a 	movwne	r1, #6522	@ 0x197a
                    vPortFreeStack( pxStack );
 224:	2e150000 	cdpcs	0, 1, cr0, cr5, cr0, {0}
 228:	3a0e0301 	bcc	380e34 <xNumberOfSuccessfulFrees+0x37c1b8>
                pxNewTCB = NULL;
 22c:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
        if( pxNewTCB != NULL )
 230:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
 234:	06120111 			@ <UNDEFINED> instruction: 0x06120111
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 238:	197c1840 	ldmdbne	ip!, {r6, fp, ip}^
 23c:	00001301 	andeq	r1, r0, r1, lsl #6
 240:	31011d16 	tstcc	r1, r6, lsl sp
 244:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
 248:	01215806 			@ <UNDEFINED> instruction: 0x01215806
 24c:	0b570559 	bleq	15c17b8 <xNumberOfSuccessfulFrees+0x15bcb3c>
 250:	2e170000 	cdpcs	0, 1, cr0, cr7, cr0, {0}
    }
 254:	03193f01 	tsteq	r9, #1, 30
 258:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
    {
 25c:	2139053b 	teqcs	r9, fp, lsr r5
 260:	11192706 	tstne	r9, r6, lsl #14
 264:	40061201 	andmi	r1, r6, r1, lsl #4
 268:	01197c18 	tsteq	r9, r8, lsl ip
        pxNewTCB = prvCreateTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );
 26c:	18000013 	stmdane	r0, {r0, r1, r4}
 270:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
 274:	3b02213a 	blcc	88764 <xNumberOfSuccessfulFrees+0x83ae8>
 278:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
 27c:	19000013 	stmdbne	r0, {r0, r1, r4}
        if( pxNewTCB != NULL )
 280:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
 284:	213a0e03 	teqcs	sl, r3, lsl #28
            prvAddNewTaskToReadyList( pxNewTCB );
 288:	39053b06 	stmdbcc	r5, {r1, r2, r8, r9, fp, ip, sp}
            xReturn = pdPASS;
 28c:	19270621 	stmdbne	r7!, {r0, r5, r9, sl}
 290:	1301193c 	movwne	r1, #6460	@ 0x193c
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 294:	2e1a0000 	cdpcs	0, 1, cr0, cr10, cr0, {0}
        return xReturn;
 298:	03193f00 	tsteq	r9, #0, 30
    }
 29c:	3b0b3a0e 	blcc	2ceadc <xNumberOfSuccessfulFrees+0x2c9e60>
 2a0:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
{
 2a4:	00193c19 	andseq	r3, r9, r9, lsl ip
 2a8:	012e1b00 			@ <UNDEFINED> instruction: 0x012e1b00
 2ac:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
 2b0:	0b3b0b3a 	bleq	ec2fa0 <xNumberOfSuccessfulFrees+0xebe324>
 2b4:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
 2b8:	193c1349 	ldmdbne	ip!, {r0, r3, r6, r8, r9, ip}
 2bc:	00001301 	andeq	r1, r0, r1, lsl #6
 2c0:	3100051c 	tstcc	r0, ip, lsl r5
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 2c4:	00180213 	andseq	r0, r8, r3, lsl r2
 2c8:	00161d00 	andseq	r1, r6, r0, lsl #26
    if( pcName != NULL )
 2cc:	213a0e03 	teqcs	sl, r3, lsl #28
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 2d0:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
 2d4:	0013490b 	andseq	r4, r3, fp, lsl #18
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 2d8:	011d1e00 	tsteq	sp, r0, lsl #28
 2dc:	01111331 	tsteq	r1, r1, lsr r3
 2e0:	21580612 	cmpcs	r8, r2, lsl r6
 2e4:	57055901 	strpl	r5, [r5, -r1, lsl #18]
 2e8:	13013221 	movwne	r3, #4641	@ 0x1221
            if( pcName[ x ] == ( char ) 0x00 )
 2ec:	2e1f0000 	cdpcs	0, 1, cr0, cr15, cr0, {0}
 2f0:	3a0e0300 	bcc	380ef8 <xNumberOfSuccessfulFrees+0x37c27c>
 2f4:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 2f8:	270d2139 	smladxcs	sp, r9, r1, r2
 2fc:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
 300:	7a184006 	bvc	610320 <xNumberOfSuccessfulFrees+0x60b6a4>
                break;
 304:	20000019 	andcs	r0, r0, r9, lsl r0
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1U ] = '\0';
 308:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	@ <UNPREDICTABLE>
 30c:	213a0e03 	teqcs	sl, r3, lsl #28
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 310:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 314:	19270621 	stmdbne	r7!, {r0, r5, r9, sl}
    pxNewTCB->uxPriority = uxPriority;
 318:	06120111 			@ <UNDEFINED> instruction: 0x06120111
 31c:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 320:	2e210000 	cdpcs	0, 2, cr0, cr1, cr0, {0}
 324:	3a0e0301 	bcc	380f30 <xNumberOfSuccessfulFrees+0x37c2b4>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 328:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
 32c:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
 330:	01111349 	tsteq	r1, r9, asr #6
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 334:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );
 338:	1301197c 	movwne	r1, #6524	@ 0x197c
 33c:	2e220000 	cdpcs	0, 2, cr0, cr2, cr0, {0}
 340:	3a0e0301 	bcc	380f4c <xNumberOfSuccessfulFrees+0x37c2d0>
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 344:	0b3b0221 	bleq	ec0bd0 <xNumberOfSuccessfulFrees+0xebbf54>
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 348:	271e2139 			@ <UNDEFINED> instruction: 0x271e2139
 34c:	03212019 			@ <UNDEFINED> instruction: 0x03212019
 350:	00001301 	andeq	r1, r0, r1, lsl #6
 354:	03000523 	movweq	r0, #1315	@ 0x523
    if( pxCreatedTask != NULL )
 358:	02213a0e 	eoreq	r3, r1, #57344	@ 0xe000
 35c:	0b390b3b 	bleq	e43050 <xNumberOfSuccessfulFrees+0xe3e3d4>
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 360:	00001349 	andeq	r1, r0, r9, asr #6
}
 364:	25011124 	strcs	r1, [r1, #-292]	@ 0xfffffedc
 368:	030b130e 	movweq	r1, #45838	@ 0xb30e
    {
 36c:	110e1b0e 	tstne	lr, lr, lsl #22
 370:	10061201 	andne	r1, r6, r1, lsl #4
        taskENTER_CRITICAL();
 374:	25000017 	strcs	r0, [r0, #-23]	@ 0xffffffe9
            uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );
 378:	0b0b0024 	bleq	2c0410 <xNumberOfSuccessfulFrees+0x2bb794>
 37c:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
 380:	0f260000 	svceq	0x00260000
            if( pxCurrentTCB == NULL )
 384:	000b0b00 	andeq	r0, fp, r0, lsl #22
 388:	01152700 	tsteq	r5, r0, lsl #14
                pxCurrentTCB = pxNewTCB;
 38c:	13011927 	movwne	r1, #6439	@ 0x1927
                if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 390:	13280000 			@ <UNDEFINED> instruction: 0x13280000
 394:	0b0e0301 	bleq	380fa0 <xNumberOfSuccessfulFrees+0x37c324>
                    prvInitialiseTaskLists();
 398:	3b0b3a0b 	blcc	2cebcc <xNumberOfSuccessfulFrees+0x2c9f50>
 39c:	010b3905 	tsteq	fp, r5, lsl #18
                if( xSchedulerRunning == pdFALSE )
 3a0:	29000013 	stmdbcs	r0, {r0, r1, r4}
 3a4:	0b3e0104 	bleq	f807bc <xNumberOfSuccessfulFrees+0xf7bb40>
                    if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 3a8:	13490b0b 	movtne	r0, #39691	@ 0x9b0b
 3ac:	0b3b0b3a 	bleq	ec309c <xNumberOfSuccessfulFrees+0xebe420>
 3b0:	13010b39 	movwne	r0, #6969	@ 0x1b39
                        pxCurrentTCB = pxNewTCB;
 3b4:	342a0000 	strtcc	r0, [sl], #-0
 3b8:	3a0e0300 	bcc	380fc0 <xNumberOfSuccessfulFrees+0x37c344>
            uxTaskNumber++;
 3bc:	39053b0b 	stmdbcc	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
 3c0:	3f13490b 	svccc	0x0013490b
            prvAddTaskToReadyList( pxNewTCB );
 3c4:	00180219 	andseq	r0, r8, r9, lsl r2
 3c8:	012e2b00 			@ <UNDEFINED> instruction: 0x012e2b00
 3cc:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
 3d0:	053b0b3a 	ldreq	r0, [fp, #-2874]!	@ 0xfffff4c6
 3d4:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
 3d8:	193c1349 	ldmdbne	ip!, {r0, r3, r6, r8, r9, ip}
 3dc:	00001301 	andeq	r1, r0, r1, lsl #6
 3e0:	3f002e2c 	svccc	0x00002e2c
 3e4:	3a0e0319 	bcc	381050 <xNumberOfSuccessfulFrees+0x37c3d4>
 3e8:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 3ec:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
 3f0:	00193c13 	andseq	r3, r9, r3, lsl ip
 3f4:	012e2d00 			@ <UNDEFINED> instruction: 0x012e2d00
 3f8:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
 3fc:	0b3b0b3a 	bleq	ec30ec <xNumberOfSuccessfulFrees+0xebe470>
 400:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
 404:	1301193c 	movwne	r1, #6460	@ 0x193c
 408:	2e2e0000 	cdpcs	0, 2, cr0, cr14, cr0, {0}
 40c:	03193f00 	tsteq	r9, #0, 30
 410:	3b0b3a0e 	blcc	2cec50 <xNumberOfSuccessfulFrees+0x2c9fd4>
 414:	270b3905 	strcs	r3, [fp, -r5, lsl #18]
 418:	11134919 	tstne	r3, r9, lsl r9
 41c:	40061201 	andmi	r1, r6, r1, lsl #4
 420:	00197a18 	andseq	r7, r9, r8, lsl sl
 424:	00342f00 	eorseq	r2, r4, r0, lsl #30
 428:	0b3a0803 	bleq	e8243c <xNumberOfSuccessfulFrees+0xe7d7c0>
 42c:	0b39053b 	bleq	e41920 <xNumberOfSuccessfulFrees+0xe3cca4>
 430:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
 434:	2e300000 	cdpcs	0, 3, cr0, cr0, cr0, {0}
 438:	3a0e0301 	bcc	381044 <xNumberOfSuccessfulFrees+0x37c3c8>
 43c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 440:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
 444:	010b2013 	tsteq	fp, r3, lsl r0
        taskEXIT_CRITICAL();
 448:	31000013 	tstcc	r0, r3, lsl r0
        if( xSchedulerRunning != pdFALSE )
 44c:	0e03012e 	adfeqsp	f0, f3, #0.5
 450:	0b3b0b3a 	bleq	ec3140 <xNumberOfSuccessfulFrees+0xebe4c4>
            taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
 454:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
 458:	0b201349 	bleq	805184 <xNumberOfSuccessfulFrees+0x800508>
 45c:	01000000 	mrseq	r0, (UNDEF: 0)
 460:	0b0b0024 	bleq	2c04f8 <xNumberOfSuccessfulFrees+0x2bb87c>
 464:	0e030b3e 	vmoveq.16	d3[0], r0
 468:	0d020000 	stceq	0, cr0, [r2, #-0]
 46c:	3a0e0300 	bcc	381074 <xNumberOfSuccessfulFrees+0x37c3f8>
    }
 470:	0b3b0421 	bleq	ec14fc <xNumberOfSuccessfulFrees+0xebc880>
 474:	13490b39 	movtne	r0, #39737	@ 0x9b39
 478:	00000b38 	andeq	r0, r0, r8, lsr fp
 47c:	03000503 	movweq	r0, #1283	@ 0x503
 480:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
 484:	0b390b3b 	bleq	e43178 <xNumberOfSuccessfulFrees+0xe3e4fc>
 488:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
 48c:	16040000 	strne	r0, [r4], -r0
 490:	3a0e0300 	bcc	381098 <xNumberOfSuccessfulFrees+0x37c41c>
{
 494:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 498:	0013490b 	andseq	r4, r3, fp, lsl #18
    BaseType_t xReturn = pdPASS;
 49c:	000f0500 	andeq	r0, pc, r0, lsl #10
    char cIdleName[ configMAX_TASK_NAME_LEN ] = { 0 };
 4a0:	4904210b 	stmdbmi	r4, {r0, r1, r3, r8, sp}
 4a4:	06000013 			@ <UNDEFINED> instruction: 0x06000013
 4a8:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    TaskFunction_t pxIdleTaskFunction = NULL;
 4ac:	3b01213a 	blcc	4899c <xNumberOfSuccessfulFrees+0x43d20>
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
 4b0:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
        cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
 4b4:	00180213 	andseq	r0, r8, r3, lsl r2
 4b8:	00260700 	eoreq	r0, r6, r0, lsl #14
 4bc:	00001349 	andeq	r1, r0, r9, asr #6
 4c0:	03011308 	movweq	r1, #4872	@ 0x1308
 4c4:	3a0b0b0e 	bcc	2c3104 <xNumberOfSuccessfulFrees+0x2be488>
        if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
 4c8:	0b3b0421 	bleq	ec1554 <xNumberOfSuccessfulFrees+0xebc8d8>
 4cc:	13010b39 	movwne	r0, #6969	@ 0x1b39
 4d0:	2e090000 	cdpcs	0, 0, cr0, cr9, cr0, {0}
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
 4d4:	03193f01 	tsteq	r9, #1, 30
 4d8:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
 4dc:	21390b3b 	teqcs	r9, fp, lsr fp
            break;
 4e0:	11192706 	tstne	r9, r6, lsl #14
    cIdleName[ xIdleTaskNameIndex ] = '\0';
 4e4:	40061201 	andmi	r1, r6, r1, lsl #4
 4e8:	01197a18 	tsteq	r9, r8, lsl sl
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
 4ec:	0a000013 	beq	540 <vTaskStartScheduler>
 4f0:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
            pxIdleTaskFunction = &prvIdleTask;
 4f4:	0e030b13 	vmoveq.32	d3[0], r0
            xReturn = xTaskCreate( pxIdleTaskFunction,
 4f8:	01110e1b 	tsteq	r1, fp, lsl lr
 4fc:	17100612 			@ <UNDEFINED> instruction: 0x17100612
 500:	240b0000 	strcs	r0, [fp], #-0
 504:	3e0b0b00 	vmlacc.f64	d0, d11, d0
 508:	0008030b 	andeq	r0, r8, fp, lsl #6
 50c:	000f0c00 	andeq	r0, pc, r0, lsl #24
 510:	00000b0b 	andeq	r0, r0, fp, lsl #22
        if( xReturn != pdPASS )
 514:	3f012e0d 	svccc	0x00012e0d
 518:	3a0e0319 	bcc	381184 <xNumberOfSuccessfulFrees+0x37c508>
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
 51c:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 520:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
 524:	12011113 	andne	r1, r1, #-1073741820	@ 0xc0000004
            break;
 528:	7a184006 	bvc	610548 <xNumberOfSuccessfulFrees+0x60b8cc>
}
 52c:	00130119 	andseq	r0, r3, r9, lsl r1
 530:	012e0e00 			@ <UNDEFINED> instruction: 0x012e0e00
 534:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
 538:	0b3b0b3a 	bleq	ec3228 <xNumberOfSuccessfulFrees+0xebe5ac>
 53c:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
{
 540:	06120111 			@ <UNDEFINED> instruction: 0x06120111
 544:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    xReturn = prvCreateIdleTasks();
 548:	01000000 	mrseq	r0, (UNDEF: 0)
    if( xReturn == pdPASS )
 54c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
 550:	3b01213a 	blcc	48a40 <xNumberOfSuccessfulFrees+0x43dc4>
    __asm volatile
 554:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
 558:	00180213 	andseq	r0, r8, r3, lsl r2
 55c:	00240200 	eoreq	r0, r4, r0, lsl #4
 560:	0b3e0b0b 	bleq	f83194 <xNumberOfSuccessfulFrees+0xf7e518>
}
 564:	00000e03 	andeq	r0, r0, r3, lsl #28
        xNextTaskUnblockTime = portMAX_DELAY;
 568:	03003403 	movweq	r3, #1027	@ 0x403
 56c:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
        xSchedulerRunning = pdTRUE;
 570:	0b39053b 	bleq	e41a64 <xNumberOfSuccessfulFrees+0xe3cde8>
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 574:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
 578:	0d040000 	stceq	0, cr0, [r4, #-0]
        ( void ) xPortStartScheduler();
 57c:	3a0e0300 	bcc	381184 <xNumberOfSuccessfulFrees+0x37c508>
    ( void ) uxTopUsedPriority;
 580:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
}
 584:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
 588:	0500000b 	streq	r0, [r0, #-11]
 58c:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
 590:	0b3b0b3a 	bleq	ec3280 <xNumberOfSuccessfulFrees+0xebe604>
 594:	13490b39 	movtne	r0, #39737	@ 0x9b39
 598:	0f060000 	svceq	0x00060000
{
 59c:	04210b00 	strteq	r0, [r1], #-2816	@ 0xfffff500
 5a0:	00001349 	andeq	r1, r0, r9, asr #6
    __asm volatile
 5a4:	03000507 	movweq	r0, #1287	@ 0x507
 5a8:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
 5ac:	0b39053b 	bleq	e41aa0 <xNumberOfSuccessfulFrees+0xe3ce24>
 5b0:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
}
 5b4:	05080000 	streq	r0, [r8, #-0]
    xSchedulerRunning = pdFALSE;
 5b8:	00134900 	andseq	r4, r3, r0, lsl #18
    vPortEndScheduler();
 5bc:	002e0900 	eoreq	r0, lr, r0, lsl #18
}
 5c0:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
 5c4:	3b01213a 	blcc	48ab4 <xNumberOfSuccessfulFrees+0x43e38>
 5c8:	06213905 	strteq	r3, [r1], -r5, lsl #18
{
 5cc:	01111927 	tsteq	r1, r7, lsr #18
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
 5d0:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
 5d4:	0000197a 	andeq	r1, r0, sl, ror r9
 5d8:	0300340a 	movweq	r3, #1034	@ 0x40a
}
 5dc:	01213a08 			@ <UNDEFINED> instruction: 0x01213a08
 5e0:	0b39053b 	bleq	e41ad4 <xNumberOfSuccessfulFrees+0xe3ce58>
 5e4:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
{
 5e8:	130b0000 	movwne	r0, #45056	@ 0xb000
 5ec:	0b0e0301 	bleq	3811f8 <xNumberOfSuccessfulFrees+0x37c57c>
    TCB_t * pxTCB = NULL;
 5f0:	3b0b3a0b 	blcc	2cee24 <xNumberOfSuccessfulFrees+0x2ca1a8>
    BaseType_t xAlreadyYielded = pdFALSE;
 5f4:	1021390b 	eorne	r3, r1, fp, lsl #18
        taskENTER_CRITICAL();
 5f8:	00001301 	andeq	r1, r0, r1, lsl #6
            const BaseType_t xCoreID = ( BaseType_t ) portGET_CORE_ID();
 5fc:	3f002e0c 	svccc	0x00002e0c
            uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended - 1U );
 600:	3a0e0319 	bcc	38126c <xNumberOfSuccessfulFrees+0x37c5f0>
 604:	0b3b0421 	bleq	ec1690 <xNumberOfSuccessfulFrees+0xebca14>
            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 608:	270d2139 	smladxcs	sp, r9, r1, r2
 60c:	00193c19 	andseq	r3, r9, r9, lsl ip
 610:	012e0d00 			@ <UNDEFINED> instruction: 0x012e0d00
                if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 614:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
 618:	3b01213a 	blcc	48b08 <xNumberOfSuccessfulFrees+0x43e8c>
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 61c:	06213905 	strteq	r3, [r1], -r5, lsl #18
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 620:	01111927 	tsteq	r1, r7, lsr #18
 624:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 628:	1301197c 	movwne	r1, #6524	@ 0x197c
 62c:	2e0e0000 	cdpcs	0, 0, cr0, cr14, cr0, {0}
 630:	3a0e0301 	bcc	38123c <xNumberOfSuccessfulFrees+0x37c5c0>
 634:	053b0121 	ldreq	r0, [fp, #-289]!	@ 0xfffffedf
 638:	270d2139 	smladxcs	sp, r9, r1, r2
 63c:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
 640:	7a184006 	bvc	610660 <xNumberOfSuccessfulFrees+0x60b9e4>
 644:	00130119 	andseq	r0, r3, r9, lsl r1
 648:	002e0f00 	eoreq	r0, lr, r0, lsl #30
 64c:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
 650:	3b01213a 	blcc	48b40 <xNumberOfSuccessfulFrees+0x43ec4>
 654:	08213905 	stmdaeq	r1!, {r0, r2, r8, fp, ip, sp}
 658:	13491927 	movtne	r1, #39207	@ 0x9927
 65c:	06120111 			@ <UNDEFINED> instruction: 0x06120111
 660:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 664:	11100000 	tstne	r0, r0
 668:	130e2501 	movwne	r2, #58625	@ 0xe501
 66c:	1b0e030b 	blne	3812a0 <xNumberOfSuccessfulFrees+0x37c624>
 670:	1201110e 	andne	r1, r1, #-2147483645	@ 0x80000003
 674:	00171006 	andseq	r1, r7, r6
 678:	00261100 	eoreq	r1, r6, r0, lsl #2
 67c:	00001349 	andeq	r1, r0, r9, asr #6
 680:	0b002412 	bleq	96d0 <xNumberOfSuccessfulFrees+0x4a54>
 684:	030b3e0b 	movweq	r3, #48651	@ 0xbe0b
 688:	13000008 	movwne	r0, #8
 68c:	0b0b000f 	bleq	2c06d0 <xNumberOfSuccessfulFrees+0x2bba54>
 690:	01140000 	tsteq	r4, r0
 694:	01134901 	tsteq	r3, r1, lsl #18
 698:	15000013 	strne	r0, [r0, #-19]	@ 0xffffffed
 69c:	13490021 	movtne	r0, #36897	@ 0x9021
 6a0:	0000052f 	andeq	r0, r0, pc, lsr #10
                        prvAddTaskToReadyList( pxTCB );
 6a4:	3f012e16 	svccc	0x00012e16
 6a8:	3a0e0319 	bcc	381314 <xNumberOfSuccessfulFrees+0x37c698>
 6ac:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 6b0:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
 6b4:	01193c13 	tsteq	r9, r3, lsl ip
 6b8:	17000013 	smladne	r0, r3, r0, r0
 6bc:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	@ <UNPREDICTABLE>
 6c0:	0b3a0e03 	bleq	e83ed4 <xNumberOfSuccessfulFrees+0xe7f258>
 6c4:	0b39053b 	bleq	e41bb8 <xNumberOfSuccessfulFrees+0xe3cf3c>
 6c8:	13491927 	movtne	r1, #39207	@ 0x9927
 6cc:	0000193c 	andeq	r1, r0, ip, lsr r9
 6d0:	3f002e18 	svccc	0x00002e18
 6d4:	3a0e0319 	bcc	381340 <xNumberOfSuccessfulFrees+0x37c6c4>
 6d8:	39053b0b 	stmdbcc	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
 6dc:	3c19270b 	ldccc	7, cr2, [r9], {11}
 6e0:	19000019 	stmdbne	r0, {r0, r3, r4}
 6e4:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
 6e8:	0b3a0e03 	bleq	e83efc <xNumberOfSuccessfulFrees+0xe7f280>
 6ec:	0b39053b 	bleq	e41be0 <xNumberOfSuccessfulFrees+0xe3cf64>
 6f0:	13491927 	movtne	r1, #39207	@ 0x9927
 6f4:	06120111 			@ <UNDEFINED> instruction: 0x06120111
 6f8:	197c1840 	ldmdbne	ip!, {r6, fp, ip}^
 6fc:	00001301 	andeq	r1, r0, r1, lsl #6
 700:	0300051a 	movweq	r0, #1306	@ 0x51a
 704:	3b0b3a08 	blcc	2cef2c <xNumberOfSuccessfulFrees+0x2ca2b0>
 708:	490b3905 	stmdbmi	fp, {r0, r2, r8, fp, ip, sp}
 70c:	00180213 	andseq	r0, r8, r3, lsl r2
 710:	012e1b00 			@ <UNDEFINED> instruction: 0x012e1b00
 714:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
 718:	0b3b0b3a 	bleq	ec3408 <xNumberOfSuccessfulFrees+0xebe78c>
 71c:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
 720:	01111349 	tsteq	r1, r9, asr #6
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 724:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
 728:	0000197c 	andeq	r1, r0, ip, ror r9
 72c:	0300051c 	movweq	r0, #1308	@ 0x51c
 730:	3b0b3a0e 	blcc	2cef70 <xNumberOfSuccessfulFrees+0x2ca2f4>
                                xYieldPendings[ xCoreID ] = pdTRUE;
 734:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
 738:	00180213 	andseq	r0, r8, r3, lsl r2
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 73c:	24010000 	strcs	r0, [r1], #-0
 740:	3e0b0b00 	vmlacc.f64	d0, d11, d0
 744:	000e030b 	andeq	r0, lr, fp, lsl #6
                    if( pxTCB != NULL )
 748:	00160200 	andseq	r0, r6, r0, lsl #4
                        prvResetNextTaskUnblockTime();
 74c:	0b3a0e03 	bleq	e83f60 <xNumberOfSuccessfulFrees+0xe7f2e4>
                        TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 750:	0b390b3b 	bleq	e43444 <xNumberOfSuccessfulFrees+0xe3e7c8>
 754:	00001349 	andeq	r1, r0, r9, asr #6
                        if( xPendedCounts > ( TickType_t ) 0U )
 758:	0b000f03 	bleq	436c <ucHeap+0x1f08>
                                if( xTaskIncrementTick() != pdFALSE )
 75c:	13490421 	movtne	r0, #37921	@ 0x9421
 760:	2e040000 	cdpcs	0, 0, cr0, cr4, cr0, {0}
 764:	03193f00 	tsteq	r9, #0, 30
                                    xYieldPendings[ xCoreID ] = pdTRUE;
 768:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
 76c:	0b39053b 	bleq	e41c60 <xNumberOfSuccessfulFrees+0xe3cfe4>
                                --xPendedCounts;
 770:	01111927 	tsteq	r1, r7, lsr #18
 774:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
                            } while( xPendedCounts > ( TickType_t ) 0U );
 778:	0000197a 	andeq	r1, r0, sl, ror r9
                            xPendedTicks = 0;
 77c:	31003405 	tstcc	r0, r5, lsl #8
 780:	00180213 	andseq	r0, r8, r3, lsl r2
                    if( xYieldPendings[ xCoreID ] != pdFALSE )
 784:	011d0600 	tsteq	sp, r0, lsl #12
 788:	01111331 	tsteq	r1, r1, lsr r3
 78c:	21580612 	cmpcs	r8, r2, lsl r6
                            xAlreadyYielded = pdTRUE;
 790:	57055901 	strpl	r5, [r5, -r1, lsl #18]
                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
 794:	0700000b 	streq	r0, [r0, -fp]
 798:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
 79c:	3b01213a 	blcc	48c8c <xNumberOfSuccessfulFrees+0x44010>
 7a0:	490b390b 	stmdbmi	fp, {r0, r1, r3, r8, fp, ip, sp}
 7a4:	00180213 	andseq	r0, r8, r3, lsl r2
        taskEXIT_CRITICAL();
 7a8:	00260800 	eoreq	r0, r6, r0, lsl #16
}
 7ac:	00001349 	andeq	r1, r0, r9, asr #6
 7b0:	03003409 	movweq	r3, #1033	@ 0x409
 7b4:	01213a0e 			@ <UNDEFINED> instruction: 0x01213a0e
 7b8:	0b390b3b 	bleq	e434ac <xNumberOfSuccessfulFrees+0xe3e830>
 7bc:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
 7c0:	050a0000 	streq	r0, [sl, #-0]
 7c4:	02133100 	andseq	r3, r3, #0, 2
 7c8:	0b000018 	bleq	830 <pcTaskGetName+0x8>
 7cc:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
 7d0:	213a0e03 	teqcs	sl, r3, lsl #28
 7d4:	39053b01 	stmdbcc	r5, {r0, r8, r9, fp, ip, sp}
{
 7d8:	19270621 	stmdbne	r7!, {r0, r5, r9, sl}
 7dc:	06120111 			@ <UNDEFINED> instruction: 0x06120111
        xTicks = xTickCount;
 7e0:	197a1840 	ldmdbne	sl!, {r6, fp, ip}^
    return xTicks;
 7e4:	00001301 	andeq	r1, r0, r1, lsl #6
}
 7e8:	2501110c 	strcs	r1, [r1, #-268]	@ 0xfffffef4
 7ec:	030b130e 	movweq	r1, #45838	@ 0xb30e
 7f0:	110e1b0e 	tstne	lr, lr, lsl #22
{
 7f4:	10061201 	andne	r1, r6, r1, lsl #4
 7f8:	0d000017 	stceq	0, cr0, [r0, #-92]	@ 0xffffffa4
    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 7fc:	0b0b0024 	bleq	2c0894 <xNumberOfSuccessfulFrees+0x2bbc18>
        xReturn = xTickCount;
 800:	08030b3e 	stmdaeq	r3, {r1, r2, r3, r4, r5, r8, r9, fp}
    return xReturn;
 804:	350e0000 	strcc	r0, [lr, #-0]
}
 808:	00134900 	andseq	r4, r3, r0, lsl #18
 80c:	01150f00 	tsteq	r5, r0, lsl #30
 810:	13011927 	movwne	r1, #6439	@ 0x1927
{
 814:	05100000 	ldreq	r0, [r0, #-0]
    return uxCurrentNumberOfTasks;
 818:	00134900 	andseq	r4, r3, r0, lsl #18
}
 81c:	000f1100 	andeq	r1, pc, r0, lsl #2
 820:	00000b0b 	andeq	r0, r0, fp, lsl #22
 824:	27001512 	smladcs	r0, r2, r5, r1
{
 828:	13000019 	movwne	r0, #25
 82c:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	@ <UNPREDICTABLE>
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 830:	0b3a0e03 	bleq	e84044 <xNumberOfSuccessfulFrees+0xe7f3c8>
 834:	0b39053b 	bleq	e41d28 <xNumberOfSuccessfulFrees+0xe3d0ac>
 838:	13491927 	movtne	r1, #39207	@ 0x9927
 83c:	0000193c 	andeq	r1, r0, ip, lsr r9
    return &( pxTCB->pcTaskName[ 0 ] );
 840:	3f002e14 	svccc	0x00002e14
}
 844:	3a0e0319 	bcc	3814b0 <xNumberOfSuccessfulFrees+0x37c834>
 848:	39053b0b 	stmdbcc	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
 84c:	3c19270b 	ldccc	7, cr2, [r9], {11}
 850:	15000019 	strne	r0, [r0, #-25]	@ 0xffffffe7
{
 854:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	@ <UNPREDICTABLE>
 858:	0b3a0e03 	bleq	e8406c <xNumberOfSuccessfulFrees+0xe7f3f0>
    vTaskSuspendAll();
 85c:	0b39053b 	bleq	e41d50 <xNumberOfSuccessfulFrees+0xe3d0d4>
    taskENTER_CRITICAL();
 860:	01111927 	tsteq	r1, r7, lsr #18
        xPendedTicks += xTicksToCatchUp;
 864:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
 868:	1301197c 	movwne	r1, #6524	@ 0x197c
 86c:	1d160000 	ldcne	0, cr0, [r6, #-0]
    taskEXIT_CRITICAL();
 870:	11133101 	tstne	r3, r1, lsl #2
    xYieldOccurred = xTaskResumeAll();
 874:	58061201 	stmdapl	r6, {r0, r9, ip}
 878:	5705590b 	strpl	r5, [r5, -fp, lsl #18]
}
 87c:	0013010b 	andseq	r0, r3, fp, lsl #2
 880:	012e1700 			@ <UNDEFINED> instruction: 0x012e1700
 884:	0e03193f 			@ <UNDEFINED> instruction: 0x0e03193f
{
 888:	053b0b3a 	ldreq	r0, [fp, #-2874]!	@ 0xfffff4c6
 88c:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
    BaseType_t xSwitchRequired = pdFALSE;
 890:	01111349 	tsteq	r1, r9, asr #6
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 894:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
 898:	1301197c 	movwne	r1, #6524	@ 0x197c
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 89c:	0b180000 	bleq	6008a4 <xNumberOfSuccessfulFrees+0x5fbc28>
 8a0:	12011101 	andne	r1, r1, #1073741824	@ 0x40000000
        xTickCount = xConstTickCount;
 8a4:	19000006 	stmdbne	r0, {r1, r2}
 8a8:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
        if( xConstTickCount == ( TickType_t ) 0U )
 8ac:	053b0b3a 	ldreq	r0, [fp, #-2874]!	@ 0xfffff4c6
            taskSWITCH_DELAYED_LISTS();
 8b0:	13490b39 	movtne	r0, #39737	@ 0x9b39
 8b4:	00001802 	andeq	r1, r0, r2, lsl #16
 8b8:	03002e1a 	movweq	r2, #3610	@ 0xe1a
 8bc:	3b0b3a0e 	blcc	2cf0fc <xNumberOfSuccessfulFrees+0x2ca480>
 8c0:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
 8c4:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
 8c8:	7a184006 	bvc	6108e8 <xNumberOfSuccessfulFrees+0x60bc6c>
 8cc:	1b000019 	blne	938 <xTaskIncrementTick+0xb0>
 8d0:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	@ <UNPREDICTABLE>
        if( xConstTickCount >= xNextTaskUnblockTime )
 8d4:	0b3a0e03 	bleq	e840e8 <xNumberOfSuccessfulFrees+0xe7f46c>
 8d8:	0b390b3b 	bleq	e435cc <xNumberOfSuccessfulFrees+0xe3e950>
 8dc:	01111927 	tsteq	r1, r7, lsr #18
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8e0:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
 8e4:	0000197a 	andeq	r1, r0, sl, ror r9
                    xNextTaskUnblockTime = portMAX_DELAY;
 8e8:	03012e1c 	movweq	r2, #7708	@ 0x1e1c
 8ec:	3b0b3a0e 	blcc	2cf12c <xNumberOfSuccessfulFrees+0x2ca4b0>
                    break;
 8f0:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8f4:	12011119 	andne	r1, r1, #1073741830	@ 0x40000006
 8f8:	7a184006 	bvc	610918 <xNumberOfSuccessfulFrees+0x60bc9c>
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8fc:	00130119 	andseq	r0, r3, r9, lsl r1
 900:	011d1d00 	tsteq	sp, r0, lsl #26
                    if( xConstTickCount < xItemValue )
 904:	01111331 	tsteq	r1, r1, lsr r3
 908:	0b580612 	bleq	1602158 <xNumberOfSuccessfulFrees+0x15fd4dc>
                        xNextTaskUnblockTime = xItemValue;
 90c:	0b570b59 	bleq	15c3678 <xNumberOfSuccessfulFrees+0x15be9fc>
                        break;
 910:	2e1e0000 	cdpcs	0, 1, cr0, cr14, cr0, {0}
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 914:	03193f01 	tsteq	r9, #1, 30
 918:	3b0b3a0e 	blcc	2cf158 <xNumberOfSuccessfulFrees+0x2ca4dc>
 91c:	270b390b 	strcs	r3, [fp, -fp, lsl #18]
 920:	11134919 	tstne	r3, r9, lsl r9
 924:	40061201 	andmi	r1, r6, r1, lsl #4
 928:	01197a18 	tsteq	r9, r8, lsl sl
 92c:	1f000013 	svcne	0x00000013
 930:	0e03012e 	adfeqsp	f0, f3, #0.5
 934:	0b3b0b3a 	bleq	ec3624 <xNumberOfSuccessfulFrees+0xebe9a8>
 938:	19270b39 	stmdbne	r7!, {r0, r3, r4, r5, r8, r9, fp}
 93c:	13010b20 	movwne	r0, #6944	@ 0x1b20
 940:	05200000 	streq	r0, [r0, #-0]!
 944:	3a0e0300 	bcc	38154c <xNumberOfSuccessfulFrees+0x37c8d0>
 948:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 94c:	0013490b 	andseq	r4, r3, fp, lsl #18
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 950:	012e2100 			@ <UNDEFINED> instruction: 0x012e2100
 954:	0b3a0e03 	bleq	e84168 <xNumberOfSuccessfulFrees+0xe7f4ec>
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 958:	0b390b3b 	bleq	e4364c <xNumberOfSuccessfulFrees+0xe3e9d0>
 95c:	0b201927 	bleq	806e00 <xNumberOfSuccessfulFrees+0x802184>
 960:	34220000 	strtcc	r0, [r2], #-0
 964:	3a0e0300 	bcc	38156c <xNumberOfSuccessfulFrees+0x37c8f0>
 968:	390b3b0b 	stmdbcc	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
 96c:	0013490b 	andseq	r4, r3, fp, lsl #18
	...

Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	0000001c 	andeq	r0, r0, ip, lsl r0
   4:	00000002 	andeq	r0, r0, r2
   8:	00040000 	andeq	r0, r4, r0
   c:	00000000 	andeq	r0, r0, r0
  10:	00000198 	muleq	r0, r8, r1
  14:	00000004 	andeq	r0, r0, r4
	...
  20:	0000001c 	andeq	r0, r0, ip, lsl r0
  24:	00260002 	eoreq	r0, r6, r2
  28:	00040000 	andeq	r0, r4, r0
  2c:	00000000 	andeq	r0, r0, r0
  30:	0000019c 	muleq	r0, ip, r1
  34:	0000000c 	andeq	r0, r0, ip
	...
  40:	0000001c 	andeq	r0, r0, ip, lsl r0
  44:	00bc0002 	adcseq	r0, ip, r2
  48:	00040000 	andeq	r0, r4, r0
  4c:	00000000 	andeq	r0, r0, r0
  50:	000001a8 	andeq	r0, r0, r8, lsr #3
  54:	0000003a 	andeq	r0, r0, sl, lsr r0
	...
  60:	0000001c 	andeq	r0, r0, ip, lsl r0
  64:	01620002 	cmneq	r2, r2
  68:	00040000 	andeq	r0, r4, r0
  6c:	00000000 	andeq	r0, r0, r0
  70:	000001e4 	andeq	r0, r0, r4, ror #3
  74:	000018ec 	andeq	r1, r0, ip, ror #17
	...
  80:	0000001c 	andeq	r0, r0, ip, lsl r0
  84:	175c0002 	ldrbne	r0, [ip, -r2]
  88:	00040000 	andeq	r0, r4, r0
  8c:	00000000 	andeq	r0, r0, r0
  90:	00001ad0 	ldrdeq	r1, [r0], -r0
  94:	0000015e 	andeq	r0, r0, lr, asr r1
	...
  a0:	0000001c 	andeq	r0, r0, ip, lsl r0
  a4:	19f60002 	ldmibne	r6!, {r1}^
  a8:	00040000 	andeq	r0, r4, r0
  ac:	00000000 	andeq	r0, r0, r0
  b0:	00001c30 	andeq	r1, r0, r0, lsr ip
  b4:	000004e8 	andeq	r0, r0, r8, ror #9
	...
  c0:	0000001c 	andeq	r0, r0, ip, lsl r0
  c4:	1e960002 	cdpne	0, 9, cr0, cr6, cr2, {0}
  c8:	00040000 	andeq	r0, r4, r0
  cc:	00000000 	andeq	r0, r0, r0
  d0:	00002118 	andeq	r2, r0, r8, lsl r1
  d4:	00000260 	andeq	r0, r0, r0, ror #4
	...

Disassembly of section .debug_str:

00000000 <.debug_str>:
       0:	746f6f62 	strbtvc	r6, [pc], #-3938	@ 8 <vector_table+0x8>
       4:	2f00532e 	svccs	0x0000532e
       8:	6b726f77 	blvs	1c9bdec <xNumberOfSuccessfulFrees+0x1c97170>
       c:	63617073 	cmnvs	r1, #115	@ 0x73
      10:	462f7365 	strtmi	r7, [pc], -r5, ror #6
      14:	52656572 	rsbpl	r6, r5, #478150656	@ 0x1c800000
      18:	2f534f54 	svccs	0x00534f54
      1c:	74726f70 	ldrbtvc	r6, [r2], #-3952	@ 0xfffff090
      20:	554e4700 	strbpl	r4, [lr, #-1792]	@ 0xfffff900
      24:	20534120 	subscs	r4, r3, r0, lsr #2
      28:	32342e32 	eorscc	r2, r4, #800	@ 0x320
      2c:	6e6f6c00 	cdpvs	12, 6, cr6, cr15, cr0, {0}
      30:	6f6c2067 	svcvs	0x006c2067
      34:	6920676e 	stmdbvs	r0!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}
      38:	7300746e 	movwvc	r7, #1134	@ 0x46e
      3c:	74726f68 	ldrbtvc	r6, [r2], #-3944	@ 0xfffff098
      40:	736e7520 	cmnvc	lr, #32, 10	@ 0x8000000
      44:	656e6769 	strbvs	r6, [lr, #-1897]!	@ 0xfffff897
      48:	6e692064 	cdpvs	0, 6, cr2, cr9, cr4, {3}
      4c:	6f6c0074 	svcvs	0x006c0074
      50:	6c20676e 	stcvs	7, cr6, [r0], #-440	@ 0xfffffe48
      54:	20676e6f 	rsbcs	r6, r7, pc, ror #28
      58:	69736e75 	ldmdbvs	r3!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
      5c:	64656e67 	strbtvs	r6, [r5], #-3687	@ 0xfffff199
      60:	746e6920 	strbtvc	r6, [lr], #-2336	@ 0xfffff6e0
      64:	554e4700 	strbpl	r4, [lr, #-1792]	@ 0xfffff900
      68:	37314320 	ldrcc	r4, [r1, -r0, lsr #6]!
      6c:	2e333120 	rsfcssp	f3, f3, f0
      70:	20312e32 	eorscs	r2, r1, r2, lsr lr
      74:	33323032 	teqcc	r2, #50	@ 0x32
      78:	39303031 	ldmdbcc	r0!, {r0, r4, r5, ip, sp}
      7c:	746d2d20 	strbtvc	r2, [sp], #-3360	@ 0xfffff2e0
      80:	626d7568 	rsbvs	r7, sp, #104, 10	@ 0x1a000000
      84:	636d2d20 	cmnvs	sp, #32, 26	@ 0x800
      88:	633d7570 	teqvs	sp, #112, 10	@ 0x1c000000
      8c:	6574726f 	ldrbvs	r7, [r4, #-623]!	@ 0xfffffd91
      90:	336d2d78 	cmncc	sp, #120, 26	@ 0x1e00
      94:	666d2d20 	strbtvs	r2, [sp], -r0, lsr #26
      98:	74616f6c 	strbtvc	r6, [r1], #-3948	@ 0xfffff094
      9c:	6962612d 	stmdbvs	r2!, {r0, r2, r3, r5, r8, sp, lr}^
      a0:	666f733d 			@ <UNDEFINED> instruction: 0x666f733d
      a4:	6d2d2074 	stcvs	0, cr2, [sp, #-464]!	@ 0xfffffe30
      a8:	68637261 	stmdavs	r3!, {r0, r5, r6, r9, ip, sp, lr}^
      ac:	6d72613d 	ldfvse	f6, [r2, #-244]!	@ 0xffffff0c
      b0:	6d2d3776 	stcvs	7, cr3, [sp, #-472]!	@ 0xfffffe28
      b4:	00672d20 	rsbeq	r2, r7, r0, lsr #26
      b8:	72617473 	rsbvc	r7, r1, #1929379840	@ 0x73000000
      bc:	00632e74 	rsbeq	r2, r3, r4, ror lr
      c0:	69736e75 	ldmdbvs	r3!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
      c4:	64656e67 	strbtvs	r6, [r5], #-3687	@ 0xfffff199
      c8:	61686320 	cmnvs	r8, r0, lsr #6
      cc:	74730072 	ldrbtvc	r0, [r3], #-114	@ 0xffffff8e
      d0:	00747261 	rsbseq	r7, r4, r1, ror #4
      d4:	73615476 	cmnvc	r1, #1979711488	@ 0x76000000
      d8:	6174536b 	cmnvs	r4, fp, ror #6
      dc:	63537472 	cmpvs	r3, #1912602624	@ 0x72000000
      e0:	75646568 	strbvc	r6, [r4, #-1384]!	@ 0xfffffa98
      e4:	0072656c 	rsbseq	r6, r2, ip, ror #10
      e8:	676e6f6c 	strbvs	r6, [lr, -ip, ror #30]!
      ec:	756f6420 	strbvc	r6, [pc, #-1056]!	@ fffffcd4 <__StackTop+0xdfffdcd4>
      f0:	00656c62 	rsbeq	r6, r5, r2, ror #24
      f4:	726f6873 	rsbvc	r6, pc, #7536640	@ 0x730000
      f8:	6e692074 	mcrvs	0, 3, r2, cr9, cr4, {3}
      fc:	6f700074 	svcvs	0x00700074
     100:	75467472 	strbvc	r7, [r6, #-1138]	@ 0xfffffb8e
     104:	6974636e 	ldmdbvs	r4!, {r1, r2, r3, r5, r6, r8, r9, sp, lr}^
     108:	2e736e6f 	cdpcs	14, 7, cr6, cr3, cr15, {3}
     10c:	69730063 	ldmdbvs	r3!, {r0, r1, r5, r6}^
     110:	6d00657a 	cfstr32vs	mvfx6, [r0, #-488]	@ 0xfffffe18
     114:	65736d65 	ldrbvs	r6, [r3, #-3429]!	@ 0xfffff29b
     118:	79620074 	stmdbvc	r2!, {r2, r4, r5, r6}^
     11c:	765f6574 			@ <UNDEFINED> instruction: 0x765f6574
     120:	65756c61 	ldrbvs	r6, [r5, #-3169]!	@ 0xfffff39f
     124:	6f437800 	svcvs	0x00437800
     128:	44496572 	strbmi	r6, [r9], #-1394	@ 0xfffffa8e
     12c:	54637000 	strbtpl	r7, [r3], #-0
     130:	4e6b7361 	cdpmi	3, 6, cr7, cr11, cr1, {3}
     134:	00656d61 	rsbeq	r6, r5, r1, ror #26
     138:	754e7875 	strbvc	r7, [lr, #-2165]	@ 0xfffff78b
     13c:	7265626d 	rsbvc	r6, r5, #-805306362	@ 0xd0000006
     140:	7449664f 	strbvc	r6, [r9], #-1615	@ 0xfffff9b1
     144:	00736d65 	rsbseq	r6, r3, r5, ror #26
     148:	726f5076 	rsbvc	r5, pc, #118	@ 0x76
     14c:	69784574 	ldmdbvs	r8!, {r2, r4, r5, r6, r8, sl, lr}^
     150:	69724374 	ldmdbvs	r2!, {r2, r4, r5, r6, r8, r9, lr}^
     154:	61636974 	smcvs	13972	@ 0x3694
     158:	5078006c 	rsbspl	r0, r8, ip, rrx
     15c:	5374726f 	cmnpl	r4, #-268435450	@ 0xf0000006
     160:	74726174 	ldrbtvc	r6, [r2], #-372	@ 0xfffffe8c
     164:	65686353 	strbvs	r6, [r8, #-851]!	@ 0xfffffcad
     168:	656c7564 	strbvs	r7, [ip, #-1380]!	@ 0xfffffa9c
     16c:	78750072 	ldmdavc	r5!, {r1, r4, r5, r6}^
     170:	6f697250 	svcvs	0x00697250
     174:	79746972 	ldmdbvc	r4!, {r1, r4, r5, r6, r8, fp, sp, lr}^
     178:	43787000 	cmnmi	r8, #0
     17c:	74736e6f 	ldrbtvc	r6, [r3], #-3695	@ 0xfffff191
     180:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
     184:	6b737400 	blvs	1cdd18c <xNumberOfSuccessfulFrees+0x1cd8510>
     188:	6b736154 	blvs	1cd86e0 <xNumberOfSuccessfulFrees+0x1cd3a64>
     18c:	746e6f43 	strbtvc	r6, [lr], #-3907	@ 0xfffff0bd
     190:	426c6f72 	rsbmi	r6, ip, #456	@ 0x1c8
     194:	6b636f6c 	blvs	18dbf4c <xNumberOfSuccessfulFrees+0x18d72d0>
     198:	426c7500 	rsbmi	r7, ip, #0, 10
{
     19c:	54737469 	ldrbtpl	r7, [r3], #-1129	@ 0xfffffb97
    vTaskStartScheduler();
     1a0:	656c436f 	strbvs	r4, [ip, #-879]!	@ 0xfffffc91
    return;
     1a4:	6e4f7261 	cdpvs	2, 4, cr7, cr15, cr1, {3}
void* memset(void* dst, int value, unsigned int size) {
     1a8:	74697845 	strbtvc	r7, [r9], #-2117	@ 0xfffff7bb
     1ac:	54787500 	ldrbtpl	r7, [r8], #-1280	@ 0xfffffb00
     1b0:	476b7361 	strbmi	r7, [fp, -r1, ror #6]!
    unsigned char *ptr = (unsigned char *)dst;
     1b4:	754e7465 	strbvc	r7, [lr, #-1125]	@ 0xfffffb9b
    unsigned char byte_value = (unsigned char)value;
     1b8:	7265626d 	rsbvc	r6, r5, #-805306362	@ 0xd0000006
    while(size > 0){
     1bc:	6154664f 	cmpvs	r4, pc, asr #12
        *ptr = byte_value;
     1c0:	00736b73 	rsbseq	r6, r3, r3, ror fp
        ptr++;
     1c4:	69487870 	stmdbvs	r8, {r4, r5, r6, fp, ip, sp, lr}^
     1c8:	72656867 	rsbvc	r6, r5, #6750208	@ 0x670000
        size--;
     1cc:	6f697250 	svcvs	0x00697250
    while(size > 0){
     1d0:	79746972 	ldmdbvc	r4!, {r1, r4, r5, r6, r8, fp, sp, lr}^
     1d4:	6b736154 	blvs	1cd872c <xNumberOfSuccessfulFrees+0x1cd3ab0>
     1d8:	656b6f57 	strbvs	r6, [fp, #-3927]!	@ 0xfffff0a9
     1dc:	4e65006e 	cdpmi	0, 6, cr0, cr5, cr14, {3}
     1e0:	7463416f 	strbtvc	r4, [r3], #-367	@ 0xfffffe91
    {
     1e4:	006e6f69 	rsbeq	r6, lr, r9, ror #30
     1e8:	6f547875 	svcvs	0x00547875
     1ec:	61655270 	smcvs	21792	@ 0x5520
     1f0:	72507964 	subsvc	r7, r0, #100, 18	@ 0x190000
            pxStack = pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) );
     1f4:	69726f69 	ldmdbvs	r2!, {r0, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
     1f8:	70007974 	andvc	r7, r0, r4, ror r9
     1fc:	6c654478 	cfstrdvs	mvd4, [r5], #-480	@ 0xfffffe20
            if( pxStack != NULL )
     200:	64657961 	strbtvs	r7, [r5], #-2401	@ 0xfffff69f
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     204:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
     208:	45787000 	ldrbmi	r7, [r8, #-0]!
                if( pxNewTCB != NULL )
     20c:	746e6576 	strbtvc	r6, [lr], #-1398	@ 0xfffffa8a
     210:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
                    ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
     214:	63537800 	cmpvs	r3, #0, 16
     218:	75646568 	strbvc	r6, [r4, #-1384]!	@ 0xfffffa98
                    pxNewTCB->pxStack = pxStack;
     21c:	5272656c 	rsbspl	r6, r2, #108, 10	@ 0x1b000000
     220:	696e6e75 	stmdbvs	lr!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
                    vPortFreeStack( pxStack );
     224:	7000676e 	andvc	r6, r0, lr, ror #14
     228:	646e4978 	strbtvs	r4, [lr], #-2424	@ 0xfffff688
                pxNewTCB = NULL;
     22c:	53007865 	movwpl	r7, #2149	@ 0x865
        if( pxNewTCB != NULL )
     230:	6b636174 	blvs	18d8808 <xNumberOfSuccessfulFrees+0x18d3b8c>
     234:	65707954 	ldrbvs	r7, [r0, #-2388]!	@ 0xfffff6ac
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
     238:	7800745f 	stmdavc	r0, {r0, r1, r2, r3, r4, r6, sl, ip, sp, lr}
     23c:	454d4954 	strbmi	r4, [sp, #-2388]	@ 0xfffff6ac
     240:	54554f5f 	ldrbpl	r4, [r5], #-3935	@ 0xfffff0a1
     244:	426c7500 	rsbmi	r7, ip, #0, 10
     248:	54737469 	ldrbtpl	r7, [r3], #-1129	@ 0xfffffb97
     24c:	656c436f 	strbvs	r4, [ip, #-879]!	@ 0xfffffc91
     250:	78007261 	stmdavc	r0, {r0, r5, r6, r9, ip, sp, lr}
    }
     254:	646e6550 	strbtvs	r6, [lr], #-1360	@ 0xfffffab0
     258:	6f436465 	svcvs	0x00436465
    {
     25c:	73746e75 	cmnvc	r4, #1872	@ 0x750
     260:	494c7800 	stmdbmi	ip, {fp, ip, sp, lr}^
     264:	495f5453 	ldmdbmi	pc, {r0, r1, r4, r6, sl, ip, lr}^	@ <UNPREDICTABLE>
     268:	004d4554 	subeq	r4, sp, r4, asr r5
        pxNewTCB = prvCreateTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );
     26c:	65527870 	ldrbvs	r7, [r2, #-2160]	@ 0xfffff790
     270:	54796461 	ldrbtpl	r6, [r9], #-1121	@ 0xfffffb9f
     274:	736b7361 	cmnvc	fp, #-2080374783	@ 0x84000001
     278:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
     27c:	63750073 	cmnvs	r5, #115	@ 0x73
        if( pxNewTCB != NULL )
     280:	6769724f 	strbvs	r7, [r9, -pc, asr #4]!
     284:	6c616e69 	stclvs	14, cr6, [r1], #-420	@ 0xfffffe5c
            prvAddNewTaskToReadyList( pxNewTCB );
     288:	69746f4e 	ldmdbvs	r4!, {r1, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
            xReturn = pdPASS;
     28c:	74537966 	ldrbvc	r7, [r3], #-2406	@ 0xfffff69a
     290:	00657461 	rsbeq	r7, r5, r1, ror #8
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     294:	73615476 	cmnvc	r1, #1979711488	@ 0x76000000
        return xReturn;
     298:	7465536b 	strbtvc	r5, [r5], #-875	@ 0xfffffc95
    }
     29c:	656d6954 	strbvs	r6, [sp, #-2388]!	@ 0xfffff6ac
     2a0:	5374754f 	cmnpl	r4, #331350016	@ 0x13c00000
{
     2a4:	65746174 	ldrbvs	r6, [r4, #-372]!	@ 0xfffffe8c
     2a8:	61547800 	cmpvs	r4, r0, lsl #16
     2ac:	65476b73 	strbvs	r6, [r7, #-2931]	@ 0xfffff48d
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
     2b0:	6972656e 	ldmdbvs	r2!, {r1, r2, r3, r5, r6, r8, sl, sp, lr}^
     2b4:	746f4e63 	strbtvc	r4, [pc], #-3683	@ 2bc <prvInitialiseNewTask+0x1a>
     2b8:	46796669 	ldrbtmi	r6, [r9], -r9, ror #12
     2bc:	496d6f72 	stmdbmi	sp!, {r1, r4, r5, r6, r8, r9, sl, fp, sp, lr}^
     2c0:	78005253 	stmdavc	r0, {r0, r1, r4, r6, r9, ip, lr}
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     2c4:	6c656959 			@ <UNDEFINED> instruction: 0x6c656959
     2c8:	6e655064 	cdpvs	0, 6, cr5, cr5, cr4, {3}
    if( pcName != NULL )
     2cc:	676e6964 	strbvs	r6, [lr, -r4, ror #18]!
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     2d0:	54780073 	ldrbtpl	r0, [r8], #-115	@ 0xffffff8d
     2d4:	496b7361 	stmdbmi	fp!, {r0, r5, r6, r8, r9, ip, sp, lr}^
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
     2d8:	6572636e 	ldrbvs	r6, [r2, #-878]!	@ 0xfffffc92
     2dc:	746e656d 	strbtvc	r6, [lr], #-1389	@ 0xfffffa93
     2e0:	6b636954 	blvs	18da838 <xNumberOfSuccessfulFrees+0x18d5bbc>
     2e4:	426c7500 	rsbmi	r7, ip, #0, 10
     2e8:	616d7469 	cmnvs	sp, r9, ror #8
            if( pcName[ x ] == ( char ) 0x00 )
     2ec:	44780070 	ldrbtmi	r0, [r8], #-112	@ 0xffffff90
     2f0:	79616c65 	stmdbvc	r1!, {r0, r2, r5, r6, sl, fp, sp, lr}^
     2f4:	61546465 	cmpvs	r4, r5, ror #8
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     2f8:	694c6b73 	stmdbvs	ip, {r0, r1, r4, r5, r6, r8, r9, fp, sp, lr}^
     2fc:	00317473 	eorseq	r7, r1, r3, ror r4
     300:	6c654478 	cfstrdvs	mvd4, [r5], #-480	@ 0xfffffe20
                break;
     304:	64657961 	strbtvs	r7, [r5], #-2401	@ 0xfffff69f
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1U ] = '\0';
     308:	6b736154 	blvs	1cd8860 <xNumberOfSuccessfulFrees+0x1cd3be4>
     30c:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
     310:	4f780032 	svcmi	0x00780032
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
     314:	66726576 			@ <UNDEFINED> instruction: 0x66726576
    pxNewTCB->uxPriority = uxPriority;
     318:	43776f6c 	cmnmi	r7, #108, 30	@ 0x1b0
     31c:	746e756f 	strbtvc	r7, [lr], #-1391	@ 0xfffffa91
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
     320:	6f507600 	svcvs	0x00507600
     324:	65537472 	ldrbvs	r7, [r3, #-1138]	@ 0xfffffb8e
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
     328:	53414274 	movtpl	r4, #4724	@ 0x1274
     32c:	49525045 	ldmdbmi	r2, {r0, r2, r6, ip, lr}^
     330:	6f507600 	svcvs	0x00507600
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
     334:	6e457472 	mcrvs	4, 2, r7, cr5, cr2, {3}
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );
     338:	43726574 	cmnmi	r2, #116, 10	@ 0x1d000000
     33c:	69746972 	ldmdbvs	r4!, {r1, r4, r5, r6, r8, fp, sp, lr}^
     340:	006c6163 	rsbeq	r6, ip, r3, ror #2
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
     344:	73615478 	cmnvc	r1, #120, 8	@ 0x78000000
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     348:	7461436b 	strbtvc	r4, [r1], #-875	@ 0xfffffc95
     34c:	70556863 	subsvc	r6, r5, r3, ror #16
     350:	6b636954 	blvs	18da8a8 <xNumberOfSuccessfulFrees+0x18d5c2c>
     354:	6c750073 	ldclvs	0, cr0, [r5], #-460	@ 0xfffffe34
    if( pxCreatedTask != NULL )
     358:	61726150 	cmnvs	r2, r0, asr r1
     35c:	6574656d 	ldrbvs	r6, [r4, #-1389]!	@ 0xfffffa93
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     360:	75007372 	strvc	r7, [r0, #-882]	@ 0xfffffc8e
}
     364:	646e4978 	strbtvs	r4, [lr], #-2424	@ 0xfffff688
     368:	6f547865 	svcvs	0x00547865
    {
     36c:	61656c43 	cmnvs	r5, r3, asr #24
     370:	73740072 	cmnvc	r4, #114	@ 0x72
        taskENTER_CRITICAL();
     374:	4243546b 	submi	r5, r3, #1795162112	@ 0x6b000000
            uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );
     378:	53787500 	cmnpl	r8, #0, 10
     37c:	64657661 	strbtvs	r7, [r5], #-1633	@ 0xfffff99f
     380:	65746e49 	ldrbvs	r6, [r4, #-3657]!	@ 0xfffff1b7
            if( pxCurrentTCB == NULL )
     384:	70757272 	rsbsvc	r7, r5, r2, ror r2
     388:	61745374 	cmnvs	r4, r4, ror r3
                pxCurrentTCB = pxNewTCB;
     38c:	00737574 	rsbseq	r7, r3, r4, ror r5
                if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     390:	746e6975 	strbtvc	r6, [lr], #-2421	@ 0xfffff68b
     394:	745f3233 	ldrbvc	r3, [pc], #-563	@ 39c <prvAddNewTaskToReadyList+0x30>
                    prvInitialiseTaskLists();
     398:	4e637500 	cdpmi	5, 6, cr7, cr3, cr0, {0}
     39c:	6669746f 	strbtvs	r7, [r9], -pc, ror #8
                if( xSchedulerRunning == pdFALSE )
     3a0:	61745379 	cmnvs	r4, r9, ror r3
     3a4:	75006574 	strvc	r6, [r0, #-1396]	@ 0xfffffa8c
                    if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
     3a8:	73694c78 	cmnvc	r9, #120, 24	@ 0x7800
     3ac:	6d655274 	sfmvs	f5, 2, [r5, #-464]!	@ 0xfffffe30
     3b0:	0065766f 	rsbeq	r7, r5, pc, ror #12
                        pxCurrentTCB = pxNewTCB;
     3b4:	724f6c75 	subvc	r6, pc, #29952	@ 0x7500
     3b8:	6e696769 	cdpvs	7, 6, cr6, cr9, cr9, {3}
            uxTaskNumber++;
     3bc:	41426c61 	cmpmi	r2, r1, ror #24
     3c0:	52504553 	subspl	r4, r0, #348127232	@ 0x14c00000
            prvAddTaskToReadyList( pxNewTCB );
     3c4:	54780049 	ldrbtpl	r0, [r8], #-73	@ 0xffffffb7
     3c8:	476b7361 	strbmi	r7, [fp, -r1, ror #6]!
     3cc:	72656e65 	rsbvc	r6, r5, #1616	@ 0x650
     3d0:	6f4e6369 	svcvs	0x004e6369
     3d4:	79666974 	stmdbvc	r6!, {r2, r4, r5, r6, r8, fp, sp, lr}^
     3d8:	55787000 	ldrbpl	r7, [r8, #-0]!
     3dc:	6f6c626e 	svcvs	0x006c626e
     3e0:	64656b63 	strbtvs	r6, [r5], #-2915	@ 0xfffff49d
     3e4:	00424354 	subeq	r4, r2, r4, asr r3
     3e8:	656c4378 	strbvs	r4, [ip, #-888]!	@ 0xfffffc88
     3ec:	6f437261 	svcvs	0x00437261
     3f0:	4f746e75 	svcmi	0x00746e75
     3f4:	6978456e 	ldmdbvs	r8!, {r1, r2, r3, r5, r6, r8, sl, lr}^
     3f8:	72700074 	rsbsvc	r0, r0, #116	@ 0x74
     3fc:	65724376 	ldrbvs	r4, [r2, #-886]!	@ 0xfffffc8a
     400:	54657461 	strbtpl	r7, [r5], #-1121	@ 0xfffffb9f
     404:	006b7361 	rsbeq	r7, fp, r1, ror #6
     408:	616c4578 	smcvs	50264	@ 0xc458
     40c:	64657370 	strbtvs	r7, [r5], #-880	@ 0xfffffc90
     410:	656d6954 	strbvs	r6, [sp, #-2388]!	@ 0xfffff6ac
     414:	65536500 	ldrbvs	r6, [r3, #-1280]	@ 0xfffffb00
     418:	6c615674 	stclvs	6, cr5, [r1], #-464	@ 0xfffffe30
     41c:	69576575 	ldmdbvs	r7, {r0, r2, r4, r5, r6, r8, sl, sp, lr}^
     420:	764f6874 			@ <UNDEFINED> instruction: 0x764f6874
     424:	72777265 	rsbsvc	r7, r7, #1342177286	@ 0x50000006
     428:	00657469 	rsbeq	r7, r5, r9, ror #8
     42c:	73615478 	cmnvc	r1, #120, 8	@ 0x78000000
     430:	7465476b 	strbtvc	r4, [r5], #-1899	@ 0xfffff895
     434:	6b636954 	blvs	18da98c <xNumberOfSuccessfulFrees+0x18d5d10>
     438:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
     43c:	6f724674 	svcvs	0x00724674
     440:	5253496d 	subspl	r4, r3, #1785856	@ 0x1b4000
     444:	426c7500 	rsbmi	r7, ip, #0, 10
        taskEXIT_CRITICAL();
     448:	54737469 	ldrbtpl	r7, [r3], #-1129	@ 0xfffffb97
        if( xSchedulerRunning != pdFALSE )
     44c:	656c436f 	strbvs	r4, [ip, #-879]!	@ 0xfffffc91
     450:	6e4f7261 	cdpvs	2, 4, cr7, cr15, cr1, {3}
            taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
     454:	72746e45 	rsbsvc	r6, r4, #1104	@ 0x450
     458:	49780079 	ldmdbmi	r8!, {r0, r3, r4, r5, r6}^
     45c:	54656c64 	strbtpl	r6, [r5], #-3172	@ 0xfffff39c
     460:	4e6b7361 	cdpmi	3, 6, cr7, cr11, cr1, {3}
     464:	49656d61 	stmdbmi	r5!, {r0, r5, r6, r8, sl, fp, sp, lr}^
     468:	7865646e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, sp, lr}^
     46c:	65507800 	ldrbvs	r7, [r0, #-2048]	@ 0xfffff800
    }
     470:	6e69646e 	cdpvs	4, 6, cr6, cr9, cr14, {3}
     474:	61655267 	cmnvs	r5, r7, ror #4
     478:	694c7964 	stmdbvs	ip, {r2, r5, r6, r8, fp, ip, sp, lr}^
     47c:	70007473 	andvc	r7, r0, r3, ror r4
     480:	6e497672 	mcrvs	6, 2, r7, cr9, cr2, {3}
     484:	61697469 	cmnvs	r9, r9, ror #8
     488:	6573696c 	ldrbvs	r6, [r3, #-2412]!	@ 0xfffff694
     48c:	6b736154 	blvs	1cd89e4 <xNumberOfSuccessfulFrees+0x1cd3d68>
     490:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
{
     494:	78700073 	ldmdavc	r0!, {r0, r1, r4, r5, r6}^
     498:	76657250 			@ <UNDEFINED> instruction: 0x76657250
    BaseType_t xReturn = pdPASS;
     49c:	73756f69 	cmnvc	r5, #420	@ 0x1a4
    char cIdleName[ configMAX_TASK_NAME_LEN ] = { 0 };
     4a0:	61547600 	cmpvs	r4, r0, lsl #12
     4a4:	65526b73 	ldrbvs	r6, [r2, #-2931]	@ 0xfffff48d
     4a8:	53746573 	cmnpl	r4, #482344960	@ 0x1cc00000
    TaskFunction_t pxIdleTaskFunction = NULL;
     4ac:	65746174 	ldrbvs	r6, [r4, #-372]!	@ 0xfffffe8c
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
     4b0:	54787000 	ldrbtpl	r7, [r8], #-0
        cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
     4b4:	00706d65 	rsbseq	r6, r0, r5, ror #26
     4b8:	6f547875 	svcvs	0x00547875
     4bc:	65735570 	ldrbvs	r5, [r3, #-1392]!	@ 0xfffffa90
     4c0:	69725064 	ldmdbvs	r2!, {r2, r5, r6, ip, lr}^
     4c4:	7469726f 	strbtvc	r7, [r9], #-623	@ 0xfffffd91
        if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
     4c8:	54760079 	ldrbtpl	r0, [r6], #-121	@ 0xffffff87
     4cc:	536b7361 	cmnpl	fp, #-2080374783	@ 0x84000001
     4d0:	65707375 	ldrbvs	r7, [r0, #-885]!	@ 0xfffffc8b
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
     4d4:	6c41646e 	cfstrdvs	mvd6, [r1], {110}	@ 0x6e
     4d8:	7875006c 	ldmdavc	r5!, {r2, r3, r5, r6}^
     4dc:	63617453 	cmnvs	r1, #1392508928	@ 0x53000000
            break;
     4e0:	7065446b 	rsbvc	r4, r5, fp, ror #8
    cIdleName[ xIdleTaskNameIndex ] = '\0';
     4e4:	65006874 	strvs	r6, [r0, #-2164]	@ 0xfffff78c
     4e8:	69746f4e 	ldmdbvs	r4!, {r1, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
     4ec:	63417966 	movtvs	r7, #6502	@ 0x1966
     4f0:	6e6f6974 			@ <UNDEFINED> instruction: 0x6e6f6974
            pxIdleTaskFunction = &prvIdleTask;
     4f4:	7a697300 	bvc	1a5d0fc <xNumberOfSuccessfulFrees+0x1a58480>
            xReturn = xTaskCreate( pxIdleTaskFunction,
     4f8:	00745f65 	rsbseq	r5, r4, r5, ror #30
     4fc:	636e4965 	cmnvs	lr, #1654784	@ 0x194000
     500:	656d6572 	strbvs	r6, [sp, #-1394]!	@ 0xfffffa8e
     504:	7800746e 	stmdavc	r0, {r1, r2, r3, r5, r6, sl, ip, sp, lr}
     508:	494e494d 	stmdbmi	lr, {r0, r2, r3, r6, r8, fp, lr}^
     50c:	53494c5f 	movtpl	r4, #40031	@ 0x9c5f
     510:	54495f54 	strbpl	r5, [r9], #-3924	@ 0xfffff0ac
        if( xReturn != pdPASS )
     514:	78004d45 	stmdavc	r0, {r0, r2, r6, r8, sl, fp, lr}
     518:	6b636954 	blvs	18daa70 <xNumberOfSuccessfulFrees+0x18d5df4>
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
     51c:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
     520:	4c780074 	ldclmi	0, cr0, [r8], #-464	@ 0xfffffe30
     524:	00545349 	subseq	r5, r4, r9, asr #6
            break;
     528:	73615476 	cmnvc	r1, #1979711488	@ 0x76000000
}
     52c:	646e456b 	strbtvs	r4, [lr], #-1387	@ 0xfffffa95
     530:	65686353 	strbvs	r6, [r8, #-851]!	@ 0xfffffcad
     534:	656c7564 	strbvs	r7, [ip, #-1380]!	@ 0xfffffa9c
     538:	43780072 	cmnmi	r8, #114	@ 0x72
     53c:	74736e6f 	ldrbtvc	r6, [r3], #-3695	@ 0xfffff191
{
     540:	6b636954 	blvs	18daa98 <xNumberOfSuccessfulFrees+0x18d5e1c>
     544:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
    xReturn = prvCreateIdleTasks();
     548:	63700074 	cmnvs	r0, #116	@ 0x74
    if( xReturn == pdPASS )
     54c:	656d614e 	strbvs	r6, [sp, #-334]!	@ 0xfffffeb2
     550:	4f787000 	svcmi	0x00787000
    __asm volatile
     554:	66726576 			@ <UNDEFINED> instruction: 0x66726576
     558:	44776f6c 	ldrbtmi	r6, [r7], #-3948	@ 0xfffff094
     55c:	79616c65 	stmdbvc	r1!, {r0, r2, r5, r6, sl, fp, sp, lr}^
     560:	61546465 	cmpvs	r4, r5, ror #8
}
     564:	694c6b73 	stmdbvs	ip, {r0, r1, r4, r5, r6, r8, r9, fp, sp, lr}^
        xNextTaskUnblockTime = portMAX_DELAY;
     568:	76007473 			@ <UNDEFINED> instruction: 0x76007473
     56c:	6b736154 	blvs	1cd8ac4 <xNumberOfSuccessfulFrees+0x1cd3e48>
        xSchedulerRunning = pdTRUE;
     570:	63616c50 	cmnvs	r1, #80, 24	@ 0x5000
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
     574:	456e4f65 	strbmi	r4, [lr, #-3941]!	@ 0xfffff09b
     578:	746e6576 	strbtvc	r6, [lr], #-1398	@ 0xfffffa8a
        ( void ) xPortStartScheduler();
     57c:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
    ( void ) uxTopUsedPriority;
     580:	64497800 	strbvs	r7, [r9], #-2048	@ 0xfffff800
}
     584:	6154656c 	cmpvs	r4, ip, ror #10
     588:	61486b73 	hvcvs	34483	@ 0x86b3
     58c:	656c646e 	strbvs	r6, [ip, #-1134]!	@ 0xfffffb92
     590:	6c750073 	ldclvs	0, cr0, [r5], #-460	@ 0xfffffe34
     594:	69746f4e 	ldmdbvs	r4!, {r1, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
     598:	64656966 	strbtvs	r6, [r5], #-2406	@ 0xfffff69a
{
     59c:	756c6156 	strbvc	r6, [ip, #-342]!	@ 0xfffffeaa
     5a0:	54760065 	ldrbtpl	r0, [r6], #-101	@ 0xffffff9b
    __asm volatile
     5a4:	526b7361 	rsbpl	r7, fp, #-2080374783	@ 0x84000001
     5a8:	766f6d65 	strbtvc	r6, [pc], -r5, ror #26
     5ac:	6f724665 	svcvs	0x00724665
     5b0:	6f6e556d 	svcvs	0x006e556d
}
     5b4:	72656472 	rsbvc	r6, r5, #1912602624	@ 0x72000000
    xSchedulerRunning = pdFALSE;
     5b8:	76456465 	strbvc	r6, [r5], -r5, ror #8
    vPortEndScheduler();
     5bc:	4c746e65 	ldclmi	14, cr6, [r4], #-404	@ 0xfffffe6c
}
     5c0:	00747369 	rsbseq	r7, r4, r9, ror #6
     5c4:	73615478 	cmnvc	r1, #120, 8	@ 0x78000000
     5c8:	6d65526b 	sfmvs	f5, 2, [r5, #-428]!	@ 0xfffffe54
{
     5cc:	4665766f 	strbtmi	r7, [r5], -pc, ror #12
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
     5d0:	456d6f72 	strbmi	r6, [sp, #-3954]!	@ 0xfffff08e
     5d4:	746e6576 	strbtvc	r6, [lr], #-1398	@ 0xfffffa8a
     5d8:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
}
     5dc:	65536500 	ldrbvs	r6, [r3, #-1280]	@ 0xfffffb00
     5e0:	6c615674 	stclvs	6, cr5, [r1], #-464	@ 0xfffffe30
     5e4:	69576575 	ldmdbvs	r7, {r0, r2, r4, r5, r6, r8, sl, sp, lr}^
{
     5e8:	756f6874 	strbvc	r6, [pc, #-2164]!	@ fffffd7c <__StackTop+0xdfffdd7c>
     5ec:	65764f74 	ldrbvs	r4, [r6, #-3956]!	@ 0xfffff08c
    TCB_t * pxTCB = NULL;
     5f0:	69727772 	ldmdbvs	r2!, {r1, r4, r5, r6, r8, r9, sl, ip, sp, lr}^
    BaseType_t xAlreadyYielded = pdFALSE;
     5f4:	75006574 	strvc	r6, [r0, #-1396]	@ 0xfffffa8c
        taskENTER_CRITICAL();
     5f8:	77654e6c 	strbvc	r4, [r5, -ip, ror #28]!
            const BaseType_t xCoreID = ( BaseType_t ) portGET_CORE_ID();
     5fc:	45534142 	ldrbmi	r4, [r3, #-322]	@ 0xfffffebe
            uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended - 1U );
     600:	00495250 	subeq	r5, r9, r0, asr r2
     604:	73614255 	cmnvc	r1, #1342177285	@ 0x50000005
            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     608:	70795465 	rsbsvc	r5, r9, r5, ror #8
     60c:	00745f65 	rsbseq	r5, r4, r5, ror #30
     610:	73615478 	cmnvc	r1, #120, 8	@ 0x78000000
                if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     614:	6e65476b 	cdpvs	7, 6, cr4, cr5, cr11, {3}
     618:	63697265 	cmnvs	r9, #1342177286	@ 0x50000006
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     61c:	69746f4e 	ldmdbvs	r4!, {r1, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     620:	61577966 	cmpvs	r7, r6, ror #18
     624:	70007469 	andvc	r7, r0, r9, ror #8
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
     628:	64497672 	strbvs	r7, [r9], #-1650	@ 0xfffff98e
     62c:	6154656c 	cmpvs	r4, ip, ror #10
     630:	78006b73 	stmdavc	r0, {r0, r1, r4, r5, r6, r8, r9, fp, sp, lr}
     634:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
     638:	00646e45 	rsbeq	r6, r4, r5, asr #28
     63c:	61546c75 	cmpvs	r4, r5, ror ip
     640:	65476b73 	strbvs	r6, [r7, #-2931]	@ 0xfffff48d
     644:	6972656e 	ldmdbvs	r2!, {r1, r2, r3, r5, r6, r8, sl, sp, lr}^
     648:	746f4e63 	strbtvc	r4, [pc], #-3683	@ 650 <xTaskResumeAll+0x68>
     64c:	54796669 	ldrbtpl	r6, [r9], #-1641	@ 0xfffff997
     650:	00656b61 	rsbeq	r6, r5, r1, ror #22
     654:	696e694d 	stmdbvs	lr!, {r0, r2, r3, r6, r8, fp, sp, lr}^
     658:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
     65c:	6d657449 	cfstrdvs	mvd7, [r5, #-292]!	@ 0xfffffedc
     660:	7800745f 	stmdavc	r0, {r0, r1, r2, r3, r4, r6, sl, ip, sp, lr}
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
     664:	6b736154 	blvs	1cd8bbc <xNumberOfSuccessfulFrees+0x1cd3f40>
     668:	61657243 	cmnvs	r5, r3, asr #4
     66c:	70006574 	andvc	r6, r0, r4, ror r5
     670:	64417672 	strbvs	r7, [r1], #-1650	@ 0xfffff98e
     674:	77654e64 	strbvc	r4, [r5, -r4, ror #28]!
     678:	6b736154 	blvs	1cd8bd0 <xNumberOfSuccessfulFrees+0x1cd3f54>
     67c:	65526f54 	ldrbvs	r6, [r2, #-3924]	@ 0xfffff0ac
     680:	4c796461 	cfldrdmi	mvd6, [r9], #-388	@ 0xfffffe7c
     684:	00747369 	rsbseq	r7, r4, r9, ror #6
     688:	746e6975 	strbtvc	r6, [lr], #-2421	@ 0xfffff68b
     68c:	00745f38 	rsbseq	r5, r4, r8, lsr pc
     690:	43767270 	cmnmi	r6, #112, 4
     694:	74616572 	strbtvc	r6, [r1], #-1394	@ 0xfffffa8e
     698:	6c644965 			@ <UNDEFINED> instruction: 0x6c644965
     69c:	73615465 	cmnvc	r1, #1694498816	@ 0x65000000
     6a0:	7000736b 	andvc	r7, r0, fp, ror #6
                        prvAddTaskToReadyList( pxTCB );
     6a4:	77654e78 			@ <UNDEFINED> instruction: 0x77654e78
     6a8:	00424354 	subeq	r4, r2, r4, asr r3
     6ac:	61547870 	cmpvs	r4, r0, ror r8
     6b0:	6f436b73 	svcvs	0x00436b73
     6b4:	78006564 	stmdavc	r0, {r2, r5, r6, r8, sl, sp, lr}
     6b8:	6c656959 			@ <UNDEFINED> instruction: 0x6c656959
     6bc:	63634f64 	cmnvs	r3, #100, 30	@ 0x190
     6c0:	65727275 	ldrbvs	r7, [r2, #-629]!	@ 0xfffffd8b
     6c4:	654d0064 	strbvs	r0, [sp, #-100]	@ 0xffffff9c
     6c8:	79726f6d 	ldmdbvc	r2!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
     6cc:	69676552 	stmdbvs	r7!, {r1, r4, r6, r8, sl, sp, lr}^
     6d0:	745f6e6f 	ldrbvc	r6, [pc], #-3695	@ 6d8 <xTaskResumeAll+0xf0>
     6d4:	654e7800 	strbvs	r7, [lr, #-2048]	@ 0xfffff800
     6d8:	61547478 	cmpvs	r4, r8, ror r4
     6dc:	6e556b73 	vmovvs.s8	r6, d5[3]
     6e0:	636f6c62 	cmnvs	pc, #25088	@ 0x6200
     6e4:	6d69546b 	cfstrdvs	mvd5, [r9, #-428]!	@ 0xfffffe54
     6e8:	6c750065 	ldclvs	0, cr0, [r5], #-404	@ 0xfffffe6c
     6ec:	74726f50 	ldrbtvc	r6, [r2], #-3920	@ 0xfffff0b0
     6f0:	73696152 	cmnvc	r9, #-2147483628	@ 0x80000014
     6f4:	53414265 	movtpl	r4, #4709	@ 0x1265
     6f8:	49525045 	ldmdbmi	r2, {r0, r2, r6, ip, lr}^
     6fc:	50787000 	rsbspl	r7, r8, r0
     700:	4974726f 	ldmdbmi	r4!, {r0, r1, r2, r3, r5, r6, r9, ip, sp, lr}^
     704:	6974696e 	ldmdbvs	r4!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
     708:	73696c61 	cmnvc	r9, #24832	@ 0x6100
     70c:	61745365 	cmnvs	r4, r5, ror #6
     710:	75006b63 	strvc	r6, [r0, #-2915]	@ 0xfffff49d
     714:	74655278 	strbtvc	r5, [r5], #-632	@ 0xfffffd88
     718:	006e7275 	rsbeq	r7, lr, r5, ror r2
     71c:	65526c75 	ldrbvs	r6, [r2, #-3189]	@ 0xfffff38b
     720:	6e727574 	mrcvs	5, 3, r7, cr2, cr4, {3}
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     724:	546c7500 	strbtpl	r7, [ip], #-1280	@ 0xfffffb00
     728:	476b7361 	strbmi	r7, [fp, -r1, ror #6]!
     72c:	72656e65 	rsbvc	r6, r5, #1616	@ 0x650
     730:	6f4e6369 	svcvs	0x004e6369
                                xYieldPendings[ xCoreID ] = pdTRUE;
     734:	79666974 	stmdbvc	r6!, {r2, r4, r5, r6, r8, fp, sp, lr}^
     738:	756c6156 	strbvc	r6, [ip, #-342]!	@ 0xfffffeaa
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     73c:	656c4365 	strbvs	r4, [ip, #-869]!	@ 0xfffffc9b
     740:	75007261 	strvc	r7, [r0, #-609]	@ 0xfffffd9f
     744:	726f5063 	rsbvc	r5, pc, #99	@ 0x63
                    if( pxTCB != NULL )
     748:	756f4374 	strbvc	r4, [pc, #-884]!	@ 3dc <prvAddNewTaskToReadyList+0x70>
                        prvResetNextTaskUnblockTime();
     74c:	654c746e 	strbvs	r7, [ip, #-1134]	@ 0xfffffb92
                        TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
     750:	6e696461 	cdpvs	4, 6, cr6, cr9, cr1, {3}
     754:	72655a67 	rsbvc	r5, r5, #421888	@ 0x67000
                        if( xPendedCounts > ( TickType_t ) 0U )
     758:	7500736f 	strvc	r7, [r0, #-879]	@ 0xfffffc91
                                if( xTaskIncrementTick() != pdFALSE )
     75c:	6e654c6c 	cdpvs	12, 6, cr4, cr5, cr12, {3}
     760:	49687467 	stmdbmi	r8!, {r0, r1, r2, r5, r6, sl, ip, sp, lr}^
     764:	7479426e 	ldrbtvc	r4, [r9], #-622	@ 0xfffffd92
                                    xYieldPendings[ xCoreID ] = pdTRUE;
     768:	70007365 	andvc	r7, r0, r5, ror #6
     76c:	65527672 	ldrbvs	r7, [r2, #-1650]	@ 0xfffff98e
                                --xPendedCounts;
     770:	4e746573 	mrcmi	5, 3, r6, cr4, cr3, {3}
     774:	54747865 	ldrbtpl	r7, [r4], #-2149	@ 0xfffff79b
                            } while( xPendedCounts > ( TickType_t ) 0U );
     778:	556b7361 	strbpl	r7, [fp, #-865]!	@ 0xfffffc9f
                            xPendedTicks = 0;
     77c:	6f6c626e 	svcvs	0x006c626e
     780:	69546b63 	ldmdbvs	r4, {r0, r1, r5, r6, r8, r9, fp, sp, lr}^
                    if( xYieldPendings[ xCoreID ] != pdFALSE )
     784:	7800656d 	stmdavc	r0, {r0, r2, r3, r5, r6, r8, sl, sp, lr}
     788:	656d6954 	strbvs	r6, [sp, #-2388]!	@ 0xfffff6ac
     78c:	6e456e4f 	cdpvs	14, 4, cr6, cr5, cr15, {2}
                            xAlreadyYielded = pdTRUE;
     790:	69726574 	ldmdbvs	r2!, {r2, r4, r5, r6, r8, sl, sp, lr}^
                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
     794:	5400676e 	strpl	r6, [r0], #-1902	@ 0xfffff892
     798:	466b7361 	strbtmi	r7, [fp], -r1, ror #6
     79c:	74636e75 	strbtvc	r6, [r3], #-3701	@ 0xfffff18b
     7a0:	5f6e6f69 	svcpl	0x006e6f69
     7a4:	78700074 	ldmdavc	r0!, {r2, r4, r5, r6}^
        taskEXIT_CRITICAL();
     7a8:	7478654e 	ldrbtvc	r6, [r8], #-1358	@ 0xfffffab2
}
     7ac:	6c757000 	ldclvs	0, cr7, [r5], #-0
     7b0:	76657250 			@ <UNDEFINED> instruction: 0x76657250
     7b4:	73756f69 	cmnvc	r5, #420	@ 0x1a4
     7b8:	69746f4e 	ldmdbvs	r4!, {r1, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
     7bc:	61636966 	cmnvs	r3, r6, ror #18
     7c0:	6e6f6974 			@ <UNDEFINED> instruction: 0x6e6f6974
     7c4:	756c6156 	strbvc	r6, [ip, #-342]!	@ 0xfffffeaa
     7c8:	78700065 	ldmdavc	r0!, {r0, r2, r5, r6}^
     7cc:	656d6954 	strbvs	r6, [sp, #-2388]!	@ 0xfffff6ac
     7d0:	0074754f 	rsbseq	r7, r4, pc, asr #10
     7d4:	462f2e2e 	strtmi	r2, [pc], -lr, lsr #28
{
     7d8:	52656572 	rsbpl	r6, r5, #478150656	@ 0x1c800000
     7dc:	2d534f54 	ldclcs	15, cr4, [r3, #-336]	@ 0xfffffeb0
        xTicks = xTickCount;
     7e0:	6e72654b 	cdpvs	5, 7, cr6, cr2, cr11, {2}
    return xTicks;
     7e4:	742f6c65 	strtvc	r6, [pc], #-3173	@ 7ec <xTaskGetTickCount+0x14>
}
     7e8:	736b7361 	cmnvc	fp, #-2080374783	@ 0x84000001
     7ec:	7800632e 	stmdavc	r0, {r1, r2, r3, r5, r8, r9, sp, lr}
     7f0:	6b736154 	blvs	1cd8d48 <xNumberOfSuccessfulFrees+0x1cd40cc>
{
     7f4:	54746547 	ldrbtpl	r6, [r4], #-1351	@ 0xfffffab9
     7f8:	436b6369 	cmnmi	fp, #-1543503871	@ 0xa4000001
    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
     7fc:	746e756f 	strbtvc	r7, [lr], #-1391	@ 0xfffffa91
        xReturn = xTickCount;
     800:	6d695400 	cfstrdvs	mvd5, [r9, #-0]
    return xReturn;
     804:	74754f65 	ldrbtvc	r4, [r5], #-3941	@ 0xfffff09b
}
     808:	7600745f 			@ <UNDEFINED> instruction: 0x7600745f
     80c:	6b736154 	blvs	1cd8d64 <xNumberOfSuccessfulFrees+0x1cd40e8>
     810:	65746e49 	ldrbvs	r6, [r4, #-3657]!	@ 0xfffff1b7
{
     814:	6c616e72 	stclvs	14, cr6, [r1], #-456	@ 0xfffffe38
    return uxCurrentNumberOfTasks;
     818:	54746553 	ldrbtpl	r6, [r4], #-1363	@ 0xfffffaad
}
     81c:	4f656d69 	svcmi	0x00656d69
     820:	74537475 	ldrbvc	r7, [r3], #-1141	@ 0xfffffb8b
     824:	00657461 	rsbeq	r7, r5, r1, ror #8
{
     828:	61547875 	cmpvs	r4, r5, ror r8
     82c:	754e6b73 	strbvc	r6, [lr, #-2931]	@ 0xfffff48d
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
     830:	7265626d 	rsbvc	r6, r5, #-805306362	@ 0xd0000006
     834:	73615400 	cmnvc	r1, #0, 8
     838:	6e61486b 	cdpvs	8, 6, cr4, cr1, cr11, {3}
     83c:	5f656c64 	svcpl	0x00656c64
    return &( pxTCB->pcTaskName[ 0 ] );
     840:	41650074 	smcmi	20484	@ 0x5004
}
     844:	6f697463 	svcvs	0x00697463
     848:	6c75006e 	ldclvs	0, cr0, [r5], #-440	@ 0xfffffe48
     84c:	4d77654e 	cfldr64mi	mvdx6, [r7, #-312]!	@ 0xfffffec8
     850:	566b7361 	strbtpl	r7, [fp], -r1, ror #6
{
     854:	65756c61 	ldrbvs	r6, [r5, #-3169]!	@ 0xfffff39f
     858:	54787500 	ldrbtpl	r7, [r8], #-1280	@ 0xfffffb00
    vTaskSuspendAll();
     85c:	526b7361 	rsbpl	r7, fp, #-2080374783	@ 0x84000001
    taskENTER_CRITICAL();
     860:	74657365 	strbtvc	r7, [r5], #-869	@ 0xfffffc9b
        xPendedTicks += xTicksToCatchUp;
     864:	6e657645 	cdpvs	6, 6, cr7, cr5, cr5, {2}
     868:	65744974 	ldrbvs	r4, [r4, #-2420]!	@ 0xfffff68c
     86c:	6c61566d 	stclvs	6, cr5, [r1], #-436	@ 0xfffffe4c
    taskEXIT_CRITICAL();
     870:	4c006575 	cfstr32mi	mvfx6, [r0], {117}	@ 0x75
    xYieldOccurred = xTaskResumeAll();
     874:	5f747369 	svcpl	0x00747369
     878:	54780074 	ldrbtpl	r0, [r8], #-116	@ 0xffffff8c
}
     87c:	546b7361 	strbtpl	r7, [fp], #-865	@ 0xfffffc9f
     880:	6575516f 	ldrbvs	r5, [r5, #-367]!	@ 0xfffffe91
     884:	54007972 	strpl	r7, [r0], #-2418	@ 0xfffff68e
{
     888:	546b6369 	strbtpl	r6, [fp], #-873	@ 0xfffffc97
     88c:	5f657079 	svcpl	0x00657079
    BaseType_t xSwitchRequired = pdFALSE;
     890:	54780074 	ldrbtpl	r0, [r8], #-116	@ 0xffffff8c
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     894:	546b7361 	strbtpl	r7, [fp], #-865	@ 0xfffffc9f
     898:	746f4e6f 	strbtvc	r4, [pc], #-3695	@ 8a0 <xTaskIncrementTick+0x18>
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
     89c:	00796669 	rsbseq	r6, r9, r9, ror #12
     8a0:	73615478 	cmnvc	r1, #120, 8	@ 0x78000000
        xTickCount = xConstTickCount;
     8a4:	5365006b 	cmnpl	r5, #107	@ 0x6b
     8a8:	69427465 	stmdbvs	r2, {r0, r2, r5, r6, sl, ip, sp, lr}^
        if( xConstTickCount == ( TickType_t ) 0U )
     8ac:	78007374 	stmdavc	r0, {r2, r4, r5, r6, r8, r9, ip, sp, lr}
            taskSWITCH_DELAYED_LISTS();
     8b0:	4f4d454d 	svcmi	0x004d454d
     8b4:	525f5952 	subspl	r5, pc, #1343488	@ 0x148000
     8b8:	4f494745 	svcmi	0x00494745
     8bc:	5476004e 	ldrbtpl	r0, [r6], #-78	@ 0xffffffb2
     8c0:	536b7361 	cmnpl	fp, #-2080374783	@ 0x84000001
     8c4:	63746977 	cmnvs	r4, #1949696	@ 0x1dc000
     8c8:	6e6f4368 	cdpvs	3, 6, cr4, cr15, cr8, {3}
     8cc:	74786574 	ldrbtvc	r6, [r8], #-1396	@ 0xfffffa8c
     8d0:	754e7800 	strbvc	r7, [lr, #-2048]	@ 0xfffff800
        if( xConstTickCount >= xNextTaskUnblockTime )
     8d4:	4f664f6d 	svcmi	0x00664f6d
     8d8:	66726576 			@ <UNDEFINED> instruction: 0x66726576
     8dc:	73776f6c 	cmnvc	r7, #108, 30	@ 0x1b0
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     8e0:	43767000 	cmnmi	r6, #0
     8e4:	61746e6f 	cmnvs	r4, pc, ror #28
                    xNextTaskUnblockTime = portMAX_DELAY;
     8e8:	72656e69 	rsbvc	r6, r5, #1680	@ 0x690
     8ec:	43787000 	cmnmi	r8, #0
                    break;
     8f0:	65727275 	ldrbvs	r7, [r2, #-629]!	@ 0xfffffd8b
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     8f4:	4354746e 	cmpmi	r4, #1845493760	@ 0x6e000000
     8f8:	53780042 	cmnpl	r8, #66	@ 0x42
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     8fc:	6c756f68 	ldclvs	15, cr6, [r5], #-416	@ 0xfffffe60
     900:	6f6c4264 	svcvs	0x006c4264
                    if( xConstTickCount < xItemValue )
     904:	63006b63 	movwvs	r6, #2915	@ 0xb63
     908:	656c6449 	strbvs	r6, [ip, #-1097]!	@ 0xfffffbb7
                        xNextTaskUnblockTime = xItemValue;
     90c:	656d614e 	strbvs	r6, [sp, #-334]!	@ 0xfffffeb2
                        break;
     910:	694c7600 	stmdbvs	ip, {r9, sl, ip, sp, lr}^
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
     914:	6e497473 	mcrvs	4, 2, r7, cr9, cr3, {3}
     918:	61697469 	cmnvs	r9, r9, ror #8
     91c:	6573696c 	ldrbvs	r6, [r3, #-2412]!	@ 0xfffff694
     920:	6d657449 	cfstrdvs	mvd7, [r5, #-292]!	@ 0xfffffedc
     924:	76727000 	ldrbtvc	r7, [r2], -r0
     928:	74696e49 	strbtvc	r6, [r9], #-3657	@ 0xfffff1b7
     92c:	696c6169 	stmdbvs	ip!, {r0, r3, r5, r6, r8, sp, lr}^
     930:	654e6573 	strbvs	r6, [lr, #-1395]	@ 0xfffffa8d
     934:	73615477 	cmnvc	r1, #1996488704	@ 0x77000000
     938:	7670006b 	ldrbtvc	r0, [r0], -fp, rrx
     93c:	61726150 	cmnvs	r2, r0, asr r1
     940:	6574656d 	ldrbvs	r6, [r4, #-1389]!	@ 0xfffffa93
     944:	78007372 	stmdavc	r0, {r1, r4, r5, r6, r8, r9, ip, sp, lr}
     948:	6d657449 	cfstrdvs	mvd7, [r5, #-292]!	@ 0xfffffedc
     94c:	756c6156 	strbvc	r6, [ip, #-342]!	@ 0xfffffeaa
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     950:	54780065 	ldrbtpl	r0, [r8], #-101	@ 0xffffff9b
     954:	526b7361 	rsbpl	r7, fp, #-2080374783	@ 0x84000001
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
     958:	6d757365 	ldclvs	3, cr7, [r5, #-404]!	@ 0xfffffe6c
     95c:	6c6c4165 	stfvse	f4, [ip], #-404	@ 0xfffffe6c
     960:	44787000 	ldrbtmi	r7, [r8], #-0
     964:	79616c65 	stmdbvc	r1!, {r0, r2, r5, r6, sl, fp, sp, lr}^
     968:	61546465 	cmpvs	r4, r5, ror #8
     96c:	694c6b73 	stmdbvs	ip, {r0, r1, r4, r5, r6, r8, r9, fp, sp, lr}^
     970:	78007473 	stmdavc	r0, {r0, r1, r4, r5, r6, sl, ip, sp, lr}
     974:	74697753 	strbtvc	r7, [r9], #-1875	@ 0xfffff8ad
     978:	65526863 	ldrbvs	r6, [r2, #-2147]	@ 0xfffff79d
     97c:	72697571 	rsbvc	r7, r9, #473956352	@ 0x1c400000
     980:	70006465 	andvc	r6, r0, r5, ror #8
     984:	61745378 	cmnvs	r4, r8, ror r3
     988:	75006b63 	strvc	r6, [r0, #-2915]	@ 0xfffff49d
     98c:	6c61566c 	stclvs	6, cr5, [r1], #-432	@ 0xfffffe50
     990:	78006575 	stmdavc	r0, {r0, r2, r4, r5, r6, r8, sl, sp, lr}
     994:	6b736154 	blvs	1cd8eec <xNumberOfSuccessfulFrees+0x1cd4270>
                    prvAddTaskToReadyList( pxTCB );
     998:	63656843 	cmnvs	r5, #4390912	@ 0x430000
     99c:	726f466b 	rsbvc	r4, pc, #112197632	@ 0x6b00000
     9a0:	656d6954 	strbvs	r6, [sp, #-2388]!	@ 0xfffff6ac
     9a4:	0074754f 	rsbseq	r7, r4, pc, asr #10
     9a8:	726f5076 	rsbvc	r5, pc, #118	@ 0x76
     9ac:	65724674 	ldrbvs	r4, [r2, #-1652]!	@ 0xfffff98c
     9b0:	78700065 	ldmdavc	r0!, {r0, r2, r5, r6}^
     9b4:	656c6449 	strbvs	r6, [ip, #-1097]!	@ 0xfffffbb7
     9b8:	6b736154 	blvs	1cd8f10 <xNumberOfSuccessfulFrees+0x1cd4294>
     9bc:	636e7546 	cmnvs	lr, #293601280	@ 0x11800000
     9c0:	6e6f6974 			@ <UNDEFINED> instruction: 0x6e6f6974
     9c4:	52637500 	rsbpl	r7, r3, #0, 10
     9c8:	72757465 	rsbsvc	r7, r5, #1694498816	@ 0x65000000
     9cc:	7570006e 	ldrbvc	r0, [r0, #-110]!	@ 0xffffff92
     9d0:	746f4e6c 	strbtvc	r4, [pc], #-3692	@ 9d8 <xTaskIncrementTick+0x150>
     9d4:	63696669 	cmnvs	r9, #110100480	@ 0x6900000
     9d8:	6f697461 	svcvs	0x00697461
     9dc:	6c61566e 	stclvs	6, cr5, [r1], #-440	@ 0xfffffe48
     9e0:	76006575 			@ <UNDEFINED> instruction: 0x76006575
     9e4:	6b736154 	blvs	1cd8f3c <xNumberOfSuccessfulFrees+0x1cd42c0>
     9e8:	7373694d 	cmnvc	r3, #1261568	@ 0x134000
     9ec:	69596465 	ldmdbvs	r9, {r0, r2, r5, r6, sl, sp, lr}^
     9f0:	00646c65 	rsbeq	r6, r4, r5, ror #24
     9f4:	726f5076 	rsbvc	r5, pc, #118	@ 0x76
     9f8:	69615274 	stmdbvs	r1!, {r2, r4, r5, r6, r9, ip, lr}^
     9fc:	41426573 	hvcmi	9811	@ 0x2653
     a00:	52504553 	subspl	r4, r0, #348127232	@ 0x14c00000
     a04:	63700049 	cmnvs	r0, #73	@ 0x49
     a08:	6b736154 	blvs	1cd8f60 <xNumberOfSuccessfulFrees+0x1cd42e4>
     a0c:	4e746547 	cdpmi	5, 7, cr6, cr4, cr7, {2}
     a10:	00656d61 	rsbeq	r6, r5, r1, ror #26
     a14:	63695478 	cmnvs	r9, #120, 8	@ 0x78000000
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
     a18:	7800736b 	stmdavc	r0, {r0, r1, r3, r5, r6, r8, r9, ip, sp, lr}
     a1c:	426e6143 	rsbmi	r6, lr, #-1073741808	@ 0xc0000010
     a20:	6b636f6c 	blvs	18dc7d8 <xNumberOfSuccessfulFrees+0x18d7b5c>
     a24:	65646e49 	strbvs	r6, [r4, #-3657]!	@ 0xfffff1b7
                                xSwitchRequired = pdTRUE;
     a28:	696e6966 	stmdbvs	lr!, {r1, r2, r5, r6, r8, fp, sp, lr}^
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     a2c:	796c6574 	stmdbvc	ip!, {r2, r4, r5, r6, r8, sl, sp, lr}^
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > 1U )
     a30:	42767000 	rsbsmi	r7, r6, #0
     a34:	41657361 	cmnmi	r5, r1, ror #6
     a38:	65726464 	ldrbvs	r6, [r2, #-1124]!	@ 0xfffffb9c
     a3c:	76007373 			@ <UNDEFINED> instruction: 0x76007373
     a40:	6b736154 	blvs	1cd8f98 <xNumberOfSuccessfulFrees+0x1cd431c>
     a44:	656e6547 	strbvs	r6, [lr, #-1351]!	@ 0xfffffab9
                    xSwitchRequired = pdTRUE;
     a48:	4e636972 			@ <UNDEFINED> instruction: 0x4e636972
                if( xYieldPendings[ 0 ] != pdFALSE )
     a4c:	6669746f 	strbtvs	r7, [r9], -pc, ror #8
     a50:	76694779 			@ <UNDEFINED> instruction: 0x76694779
                    xSwitchRequired = pdTRUE;
     a54:	6f724665 	svcvs	0x00724665
        xPendedTicks += 1U;
     a58:	5253496d 	subspl	r4, r3, #1785856	@ 0x1b4000
     a5c:	61547600 	cmpvs	r4, r0, lsl #12
     a60:	6c506b73 	mrrcvs	11, 7, r6, r0, cr3
}
     a64:	4f656361 	svcmi	0x00656361
     a68:	6f6e556e 	svcvs	0x006e556e
     a6c:	72656472 	rsbvc	r6, r5, #1912602624	@ 0x72000000
     a70:	76456465 	strbvc	r6, [r5], -r5, ror #8
     a74:	4c746e65 	ldclmi	14, cr6, [r4], #-404	@ 0xfffffe6c
     a78:	00747369 	rsbseq	r7, r4, r9, ror #6
     a7c:	73694c76 	cmnvc	r9, #30208	@ 0x7600
     a80:	696e4974 	stmdbvs	lr!, {r2, r4, r5, r6, r8, fp, lr}^
     a84:	6c616974 			@ <UNDEFINED> instruction: 0x6c616974
     a88:	00657369 	rsbeq	r7, r5, r9, ror #6
     a8c:	69547870 	ldmdbvs	r4, {r4, r5, r6, fp, ip, sp, lr}^
     a90:	54736b63 	ldrbtpl	r6, [r3], #-2915	@ 0xfffff49d
     a94:	6961576f 	stmdbvs	r1!, {r0, r1, r2, r3, r5, r6, r8, r9, sl, ip, lr}^
    {
     a98:	4c760074 	ldclmi	0, cr0, [r6], #-464	@ 0xfffffe30
     a9c:	49747369 	ldmdbmi	r4!, {r0, r3, r5, r6, r8, r9, ip, sp, lr}^
        if( uxSchedulerSuspended != ( UBaseType_t ) 0U )
     aa0:	7265736e 	rsbvc	r7, r5, #-1207959551	@ 0xb8000001
     aa4:	78750074 	ldmdavc	r5!, {r2, r4, r5, r6}^
            xYieldPendings[ 0 ] = pdTRUE;
     aa8:	50706f54 	rsbspl	r6, r0, r4, asr pc
    }
     aac:	726f6972 	rsbvc	r6, pc, #1867776	@ 0x1c8000
            xYieldPendings[ 0 ] = pdFALSE;
     ab0:	00797469 	rsbseq	r7, r9, r9, ror #8
            taskSELECT_HIGHEST_PRIORITY_TASK();
     ab4:	5f424354 	svcpl	0x00424354
     ab8:	76700074 			@ <UNDEFINED> instruction: 0x76700074
        __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
     abc:	656e774f 	strbvs	r7, [lr, #-1871]!	@ 0xfffff8b1
     ac0:	41780072 	cmnmi	r8, r2, ror r0
     ac4:	6165726c 	cmnvs	r5, ip, ror #4
     ac8:	69597964 	ldmdbvs	r9, {r2, r5, r6, r8, fp, ip, sp, lr}^
     acc:	65646c65 	strbvs	r6, [r4, #-3173]!	@ 0xfffff39b
     ad0:	54780064 	ldrbtpl	r0, [r8], #-100	@ 0xffffff9c
     ad4:	476b7361 	strbmi	r7, [fp, -r1, ror #6]!
     ad8:	75437465 	strbvc	r7, [r3, #-1125]	@ 0xfffffb9b
     adc:	6e657272 	mcrvs	2, 3, r7, cr5, cr2, {3}
     ae0:	73615474 	cmnvc	r1, #116, 8	@ 0x74000000
     ae4:	6e61486b 	cdpvs	8, 6, cr4, cr1, cr11, {3}
     ae8:	00656c64 	rsbeq	r6, r5, r4, ror #24
     aec:	76457870 			@ <UNDEFINED> instruction: 0x76457870
     af0:	4c746e65 	ldclmi	14, cr6, [r4], #-404	@ 0xfffffe6c
     af4:	49747369 	ldmdbmi	r4!, {r0, r3, r5, r6, r8, r9, ip, sp, lr}^
     af8:	006d6574 	rsbeq	r6, sp, r4, ror r5
     afc:	6e655078 	mcrvs	0, 3, r5, cr5, cr8, {3}
     b00:	54646564 	strbtpl	r6, [r4], #-1380	@ 0xfffffa9c
            portTASK_SWITCH_HOOK( pxCurrentTCB );
     b04:	736b6369 	cmnvc	fp, #-1543503871	@ 0xa4000001
    }
     b08:	69547800 	ldmdbvs	r4, {fp, ip, sp, lr}^
     b0c:	54736b63 	ldrbtpl	r6, [r3], #-2915	@ 0xfffff49d
     b10:	7461436f 	strbtvc	r4, [r1], #-879	@ 0xfffffc91
     b14:	70556863 	subsvc	r6, r5, r3, ror #16
     b18:	65527800 	ldrbvs	r7, [r2, #-2048]	@ 0xfffff800
     b1c:	6e6f6967 	vnmulvs.f16	s13, s30, s15	@ <UNPREDICTABLE>
     b20:	72700073 	rsbsvc	r0, r0, #115	@ 0x73
{
     b24:	64644176 	strbtvs	r4, [r4], #-374	@ 0xfffffe8a
     b28:	72727543 	rsbsvc	r7, r2, #281018368	@ 0x10c00000
     b2c:	54746e65 	ldrbtpl	r6, [r4], #-3685	@ 0xfffff19b
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     b30:	546b7361 	strbtpl	r7, [fp], #-865	@ 0xfffffc9f
     b34:	6c65446f 	cfstrdvs	mvd4, [r5], #-444	@ 0xfffffe44
     b38:	64657961 	strbtvs	r7, [r5], #-2401	@ 0xfffff69f
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     b3c:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
     b40:	61547800 	cmpvs	r4, r0, lsl #16
}
     b44:	65476b73 	strbvs	r6, [r7, #-2931]	@ 0xfffff48d
     b48:	72754374 	rsbsvc	r4, r5, #116, 6	@ 0xd0000001
     b4c:	746e6572 	strbtvc	r6, [lr], #-1394	@ 0xfffffa8e
{
     b50:	6b736154 	blvs	1cd90a8 <xNumberOfSuccessfulFrees+0x1cd442c>
     b54:	646e6148 	strbtvs	r6, [lr], #-328	@ 0xfffffeb8
     b58:	6f46656c 	svcvs	0x0046656c
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     b5c:	726f4372 	rsbvc	r4, pc, #-939524095	@ 0xc8000001
     b60:	78750065 	ldmdavc	r5!, {r0, r2, r5, r6}^
     b64:	72727543 	rsbsvc	r7, r2, #281018368	@ 0x10c00000
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     b68:	4e746e65 	cdpmi	14, 7, cr6, cr4, cr5, {3}
     b6c:	65626d75 	strbvs	r6, [r2, #-3445]!	@ 0xfffff28b
     b70:	54664f72 	strbtpl	r4, [r6], #-3954	@ 0xfffff08e
     b74:	736b7361 	cmnvc	fp, #-2080374783	@ 0x84000001
     b78:	69547800 	ldmdbvs	r4, {fp, ip, sp, lr}^
     b7c:	6f54656d 	svcvs	0x0054656d
     b80:	656b6157 	strbvs	r6, [fp, #-343]!	@ 0xfffffea9
     b84:	74537800 	ldrbvc	r7, [r3], #-2048	@ 0xfffff800
     b88:	4c657461 	cfstrdmi	mvd7, [r5], #-388	@ 0xfffffe7c
     b8c:	49747369 	ldmdbmi	r4!, {r0, r3, r5, r6, r8, r9, ip, sp, lr}^
     b90:	006d6574 	rsbeq	r6, sp, r4, ror r5
     b94:	43547870 	cmpmi	r4, #112, 16	@ 0x700000
     b98:	54780042 	ldrbtpl	r0, [r8], #-66	@ 0xffffffbe
     b9c:	476b7361 	strbmi	r7, [fp, -r1, ror #6]!
     ba0:	72656e65 	rsbvc	r6, r5, #1616	@ 0x650
     ba4:	6f4e6369 	svcvs	0x004e6369
     ba8:	79666974 	stmdbvc	r6!, {r2, r4, r5, r6, r8, fp, sp, lr}^
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
     bac:	74617453 	strbtvc	r7, [r1], #-1107	@ 0xfffffbad
     bb0:	656c4365 	strbvs	r4, [ip, #-869]!	@ 0xfffffc9b
}
     bb4:	75007261 	strvc	r7, [r0, #-609]	@ 0xfffffd9f
     bb8:	68635378 	stmdavs	r3!, {r3, r4, r5, r6, r8, r9, ip, lr}^
     bbc:	6c756465 	cfldrdvs	mvd6, [r5], #-404	@ 0xfffffe6c
{
     bc0:	75537265 	ldrbvc	r7, [r3, #-613]	@ 0xfffffd9b
     bc4:	6e657073 	mcrvs	0, 3, r7, cr5, cr3, {3}
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     bc8:	00646564 	rsbeq	r6, r4, r4, ror #10
     bcc:	6f547870 	svcvs	0x00547870
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
     bd0:	53664f70 	cmnpl	r6, #112, 30	@ 0x1c0
     bd4:	6b636174 	blvs	18d91ac <xNumberOfSuccessfulFrees+0x18d4530>
     bd8:	50767000 	rsbspl	r7, r6, r0
     bdc:	4d74726f 	lfmmi	f7, 2, [r4, #-444]!	@ 0xfffffe44
     be0:	6f6c6c61 	svcvs	0x006c6c61
     be4:	50760063 	rsbspl	r0, r6, r3, rrx
     be8:	4574726f 	ldrbmi	r7, [r4, #-623]!	@ 0xfffffd91
     bec:	6353646e 	cmpvs	r3, #1845493760	@ 0x6e000000
     bf0:	75646568 	strbvc	r6, [r4, #-1384]!	@ 0xfffffa98
     bf4:	0072656c 	rsbseq	r6, r2, ip, ror #10
     bf8:	694c7870 	stmdbvs	ip, {r4, r5, r6, fp, ip, sp, lr}^
     bfc:	75007473 	strvc	r7, [r0, #-1139]	@ 0xfffffb8d
     c00:	646e4978 	strbtvs	r4, [lr], #-2424	@ 0xfffff688
     c04:	6f547865 	svcvs	0x00547865
     c08:	69746f4e 	ldmdbvs	r4!, {r1, r2, r3, r6, r8, r9, sl, fp, sp, lr}^
     c0c:	70007966 	andvc	r7, r0, r6, ror #18
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
     c10:	65724378 	ldrbvs	r4, [r2, #-888]!	@ 0xfffffc88
     c14:	64657461 	strbtvs	r7, [r5], #-1121	@ 0xfffffb9f
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
     c18:	6b736154 	blvs	1cd9170 <xNumberOfSuccessfulFrees+0x1cd44f4>
     c1c:	76727000 	ldrbtvc	r7, [r2], -r0
     c20:	63656843 	cmnvs	r5, #4390912	@ 0x430000
     c24:	7361546b 	cmnvc	r1, #1795162112	@ 0x6b000000
     c28:	6157736b 	cmpvs	r7, fp, ror #6
     c2c:	6e697469 	cdpvs	4, 6, cr7, cr9, cr9, {3}
     c30:	72655467 	rsbvc	r5, r5, #1728053248	@ 0x67000000
     c34:	616e696d 	cmnvs	lr, sp, ror #18
     c38:	6e6f6974 			@ <UNDEFINED> instruction: 0x6e6f6974
     c3c:	4f787000 	svcmi	0x00787000
     c40:	66726576 			@ <UNDEFINED> instruction: 0x66726576
     c44:	44776f6c 	ldrbtmi	r6, [r7], #-3948	@ 0xfffff094
     c48:	79616c65 	stmdbvc	r1!, {r0, r2, r5, r6, sl, fp, sp, lr}^
     c4c:	694c6465 	stmdbvs	ip, {r0, r2, r5, r6, sl, sp, lr}^
     c50:	75007473 	strvc	r7, [r0, #-1139]	@ 0xfffffb8d
        prvAddTaskToReadyList( pxUnblockedTCB );
     c54:	646e4978 	strbtvs	r4, [lr], #-2424	@ 0xfffff688
     c58:	6f547865 	svcvs	0x00547865
     c5c:	74696157 	strbtvc	r6, [r9], #-343	@ 0xfffffea9
     c60:	2e006e4f 	cdpcs	14, 0, cr6, cr0, cr15, {2}
     c64:	72462f2e 	subvc	r2, r6, #46, 30	@ 0xb8
     c68:	54526565 	ldrbpl	r6, [r2], #-1381	@ 0xfffffa9b
     c6c:	4b2d534f 	blmi	b559b0 <xNumberOfSuccessfulFrees+0xb50d34>
     c70:	656e7265 	strbvs	r7, [lr, #-613]!	@ 0xfffffd9b
     c74:	696c2f6c 	stmdbvs	ip!, {r2, r3, r5, r6, r8, r9, sl, fp, sp}^
     c78:	632e7473 			@ <UNDEFINED> instruction: 0x632e7473
     c7c:	49787000 	ldmdbmi	r8!, {ip, sp, lr}^
     c80:	546d6574 	strbtpl	r6, [sp], #-1396	@ 0xfffffa8c
     c84:	6d65526f 	sfmvs	f5, 2, [r5, #-444]!	@ 0xfffffe44
     c88:	0065766f 	rsbeq	r7, r5, pc, ror #12
     c8c:	73694c76 	cmnvc	r9, #30208	@ 0x7600
     c90:	736e4974 	cmnvc	lr, #116, 18	@ 0x1d0000
     c94:	45747265 	ldrbmi	r7, [r4, #-613]!	@ 0xfffffd9b
     c98:	7800646e 	stmdavc	r0, {r1, r2, r3, r5, r6, sl, sp, lr}
     c9c:	756c6156 	strbvc	r6, [ip, #-342]!	@ 0xfffffeaa
     ca0:	49664f65 	stmdbmi	r6!, {r0, r2, r5, r6, r8, r9, sl, fp, lr}^
     ca4:	7265736e 	rsbvc	r7, r5, #-1207959551	@ 0xb8000001
     ca8:	6e6f6974 			@ <UNDEFINED> instruction: 0x6e6f6974
     cac:	49787000 	ldmdbmi	r8!, {ip, sp, lr}^
     cb0:	006d6574 	rsbeq	r6, sp, r4, ror r5
     cb4:	74497870 	strbvc	r7, [r9], #-2160	@ 0xfffff790
     cb8:	74617265 	strbtvc	r7, [r1], #-613	@ 0xfffffd9b
     cbc:	7000726f 	andvc	r7, r0, pc, ror #4
     cc0:	77654e78 			@ <UNDEFINED> instruction: 0x77654e78
     cc4:	7473694c 	ldrbtvc	r6, [r3], #-2380	@ 0xfffff6b4
     cc8:	6d657449 	cfstrdvs	mvd7, [r5, #-292]!	@ 0xfffffedc
     ccc:	50787000 	rsbspl	r7, r8, r0
     cd0:	69766572 	ldmdbvs	r6!, {r1, r4, r5, r6, r8, sl, sp, lr}^
     cd4:	4273756f 	rsbsmi	r7, r3, #465567744	@ 0x1bc00000
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     cd8:	6b636f6c 	blvs	18dca90 <xNumberOfSuccessfulFrees+0x18d7e14>
     cdc:	48787000 	ldmdami	r8!, {ip, sp, lr}^
     ce0:	53706165 	cmnpl	r0, #1073741849	@ 0x40000019
     ce4:	73746174 	cmnvc	r4, #116, 2
     ce8:	694d7800 	stmdbvs	sp, {fp, ip, sp, lr}^
     cec:	756d696e 	strbvc	r6, [sp, #-2414]!	@ 0xfffff692
     cf0:	6576456d 	ldrbvs	r4, [r6, #-1389]!	@ 0xfffffa93
     cf4:	65724672 	ldrbvs	r4, [r2, #-1650]!	@ 0xfffff98e
     cf8:	74794265 	ldrbtvc	r4, [r9], #-613	@ 0xfffffd9b
     cfc:	65527365 	ldrbvs	r7, [r2, #-869]	@ 0xfffffc9b
     d00:	6e69616d 	powvsez	f6, f1, #5.0
     d04:	00676e69 	rsbeq	r6, r7, r9, ror #28
     d08:	70616548 	rsbvc	r6, r1, r8, asr #10
     d0c:	74617453 	strbtvc	r7, [r1], #-1107	@ 0xfffffbad
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     d10:	00745f73 	rsbseq	r5, r4, r3, ror pc
     d14:	6c427870 	mcrrvs	8, 7, r7, r2, cr0
     d18:	006b636f 	rsbeq	r6, fp, pc, ror #6
     d1c:	6e694d78 	mcrvs	13, 3, r4, cr9, cr8, {3}
            xReturn = pdTRUE;
     d20:	657a6953 	ldrbvs	r6, [sl, #-2387]!	@ 0xfffff6ad
            xYieldPendings[ 0 ] = pdTRUE;
     d24:	754e7800 	strbvc	r7, [lr, #-2048]	@ 0xfffff800
     d28:	7265626d 	rsbvc	r6, r5, #-805306362	@ 0xd0000006
            xReturn = pdFALSE;
     d2c:	7246664f 	subvc	r6, r6, #82837504	@ 0x4f00000
}
     d30:	6c426565 	cfstr64vs	mvdx6, [r2], {101}	@ 0x65
     d34:	736b636f 	cmnvc	fp, #-1140850687	@ 0xbc000001
     d38:	45787000 	ldrbmi	r7, [r8, #-0]!
     d3c:	7000646e 	andvc	r6, r0, lr, ror #8
     d40:	6e497672 	mcrvs	6, 2, r7, cr9, cr2, {3}
     d44:	74726573 	ldrbtvc	r6, [r2], #-1395	@ 0xfffffa8d
     d48:	636f6c42 	cmnvs	pc, #16896	@ 0x4200
     d4c:	746e496b 	strbtvc	r4, [lr], #-2411	@ 0xfffff695
     d50:	6572466f 	ldrbvs	r4, [r2, #-1647]!	@ 0xfffff991
{
     d54:	73694c65 	cmnvc	r9, #25856	@ 0x6500
     d58:	50780074 	rsbspl	r0, r8, r4, ror r0
     d5c:	5274726f 	rsbspl	r7, r4, #-268435450	@ 0xf0000006
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
     d60:	74657365 	strbtvc	r7, [r5], #-869	@ 0xfffffc9b
     d64:	70616548 	rsbvc	r6, r1, r8, asr #10
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem );
     d68:	696e694d 	stmdbvs	lr!, {r0, r2, r3, r6, r8, fp, sp, lr}^
     d6c:	456d756d 	strbmi	r7, [sp, #-1389]!	@ 0xfffffa93
    listREMOVE_ITEM( pxEventListItem );
     d70:	46726576 			@ <UNDEFINED> instruction: 0x46726576
     d74:	48656572 	stmdami	r5!, {r1, r4, r5, r6, r8, sl, sp, lr}^
     d78:	53706165 	cmnpl	r0, #1073741849	@ 0x40000019
     d7c:	00657a69 	rsbeq	r7, r5, r9, ror #20
     d80:	4c425f41 	mcrrmi	15, 4, r5, r2, cr1
     d84:	5f4b434f 	svcpl	0x004b434f
     d88:	4b4e494c 	blmi	13932c0 <xNumberOfSuccessfulFrees+0x138e644>
     d8c:	53787500 	cmnpl	r8, #0, 10
     d90:	74726174 	ldrbtvc	r6, [r2], #-372	@ 0xfffffe8c
     d94:	72646441 	rsbvc	r6, r4, #1090519040	@ 0x41000000
     d98:	00737365 	rsbseq	r7, r3, r5, ror #6
     d9c:	7a695378 	bvc	1a55b84 <xNumberOfSuccessfulFrees+0x1a50f08>
     da0:	53664f65 	cmnpl	r6, #404	@ 0x194
     da4:	6c6c616d 	stfvse	f6, [ip], #-436	@ 0xfffffe4c
     da8:	46747365 	ldrbtmi	r7, [r4], -r5, ror #6
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
     dac:	42656572 	rsbmi	r6, r5, #478150656	@ 0x1c800000
     db0:	6b636f6c 	blvs	18dcb68 <xNumberOfSuccessfulFrees+0x18d7eec>
     db4:	79426e49 	stmdbvc	r2, {r0, r3, r6, r9, sl, fp, sp, lr}^
     db8:	00736574 	rsbseq	r6, r3, r4, ror r5
     dbc:	61654878 	smcvs	21640	@ 0x5488
     dc0:	72745370 	rsbsvc	r5, r4, #112, 6	@ 0xc0000001
     dc4:	53746375 	cmnpl	r4, #-738197503	@ 0xd4000001
     dc8:	00657a69 	rsbeq	r7, r5, r9, ror #20
     dcc:	6c6c4178 	stfvse	f4, [ip], #-480	@ 0xfffffe20
     dd0:	7461636f 	strbtvc	r6, [r1], #-879	@ 0xfffffc91
     dd4:	6c426465 	cfstrdvs	mvd6, [r2], {101}	@ 0x65
     dd8:	536b636f 	cmnpl	fp, #-1140850687	@ 0xbc000001
     ddc:	00657a69 	rsbeq	r7, r5, r9, ror #20
     de0:	6e457875 	mcrvs	8, 2, r7, cr5, cr5, {3}
     de4:	64644164 	strbtvs	r4, [r4], #-356	@ 0xfffffe9c
    prvAddTaskToReadyList( pxUnblockedTCB );
     de8:	73736572 	cmnvc	r3, #478150656	@ 0x1c800000
     dec:	4e787000 	cdpmi	0, 7, cr7, cr8, cr0, {0}
     df0:	6c427765 	mcrrvs	7, 6, r7, r2, cr5
     df4:	4c6b636f 	stclmi	3, cr6, [fp], #-444	@ 0xfffffe44
     df8:	006b6e69 	rsbeq	r6, fp, r9, ror #28
     dfc:	726f5078 	rsbvc	r5, pc, #120	@ 0x78
     e00:	74654774 	strbtvc	r4, [r5], #-1908	@ 0xfffff88c
     e04:	65657246 	strbvs	r7, [r5, #-582]!	@ 0xfffffdba
     e08:	70616548 	rsbvc	r6, r1, r8, asr #10
     e0c:	657a6953 	ldrbvs	r6, [sl, #-2387]!	@ 0xfffff6ad
     e10:	64417800 	strbvs	r7, [r1], #-2048	@ 0xfffff800
     e14:	69746964 	ldmdbvs	r4!, {r2, r5, r6, r8, fp, sp, lr}^
     e18:	6c616e6f 	stclvs	14, cr6, [r1], #-444	@ 0xfffffe44
     e1c:	75716552 	ldrbvc	r6, [r1, #-1362]!	@ 0xfffffaae
     e20:	64657269 	strbtvs	r7, [r5], #-617	@ 0xfffffd97
     e24:	657a6953 	ldrbvs	r6, [sl, #-2387]!	@ 0xfffff6ad
     e28:	52767000 	rsbspl	r7, r6, #0
     e2c:	72757465 	rsbsvc	r7, r5, #1694498816	@ 0x65000000
     e30:	5076006e 	rsbspl	r0, r6, lr, rrx
     e34:	4874726f 	ldmdami	r4!, {r0, r1, r2, r3, r5, r6, r9, ip, sp, lr}^
     e38:	52706165 	rsbspl	r6, r0, #1073741849	@ 0x40000019
     e3c:	74657365 	strbtvc	r7, [r5], #-869	@ 0xfffffc9b
     e40:	74617453 	strbtvc	r7, [r1], #-1107	@ 0xfffffbad
     e44:	4d780065 	ldclmi	0, cr0, [r8, #-404]!	@ 0xfffffe6c
     e48:	69537861 	ldmdbvs	r3, {r0, r5, r6, fp, ip, sp, lr}^
     e4c:	7800657a 	stmdavc	r0, {r1, r3, r4, r5, r6, r8, sl, sp, lr}
     e50:	74726f50 	ldrbtvc	r6, [r2], #-3920	@ 0xfffff0b0
     e54:	4d746547 	cfldr64mi	mvdx6, [r4, #-284]!	@ 0xfffffee4
     e58:	6d696e69 	stclvs	14, cr6, [r9, #-420]!	@ 0xfffffe5c
     e5c:	76456d75 			@ <UNDEFINED> instruction: 0x76456d75
     e60:	72467265 	subvc	r7, r6, #1342177286	@ 0x50000006
     e64:	65486565 	strbvs	r6, [r8, #-1381]	@ 0xfffffa9b
     e68:	69537061 	ldmdbvs	r3, {r0, r5, r6, ip, sp, lr}^
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     e6c:	4200657a 	andmi	r6, r0, #511705088	@ 0x1e800000
     e70:	6b636f6c 	blvs	18dcc28 <xNumberOfSuccessfulFrees+0x18d7fac>
     e74:	6b6e694c 	blvs	1b9b3ac <xNumberOfSuccessfulFrees+0x1b96730>
            xYieldPendings[ 0 ] = pdTRUE;
     e78:	7800745f 	stmdavc	r0, {r0, r1, r2, r3, r4, r6, sl, ip, sp, lr}
     e7c:	626d754e 	rsbvs	r7, sp, #327155712	@ 0x13800000
}
     e80:	664f7265 	strbvs	r7, [pc], -r5, ror #4
     e84:	63637553 	cmnvs	r3, #348127232	@ 0x14c00000
     e88:	66737365 	ldrbtvs	r7, [r3], -r5, ror #6
     e8c:	6c416c75 	mcrrvs	12, 7, r6, r1, cr5
     e90:	61636f6c 	cmnvs	r3, ip, ror #30
     e94:	6e6f6974 			@ <UNDEFINED> instruction: 0x6e6f6974
{
     e98:	41780073 	cmnmi	r8, r3, ror r0
     e9c:	6c696176 	stfvse	f6, [r9], #-472	@ 0xfffffe28
    taskENTER_CRITICAL();
     ea0:	656c6261 	strbvs	r6, [ip, #-609]!	@ 0xfffffd9f
        pxTimeOut->xOverflowCount = xNumOfOverflows;
     ea4:	70616548 	rsbvc	r6, r1, r8, asr #10
     ea8:	63617053 	cmnvs	r1, #83	@ 0x53
        pxTimeOut->xTimeOnEntering = xTickCount;
     eac:	426e4965 	rsbmi	r4, lr, #1654784	@ 0x194000
     eb0:	73657479 	cmnvc	r5, #2030043136	@ 0x79000000
    taskEXIT_CRITICAL();
     eb4:	50767000 	rsbspl	r7, r6, r0
}
     eb8:	4374726f 	cmnmi	r4, #-268435450	@ 0xf0000006
     ebc:	6f6c6c61 	svcvs	0x006c6c61
     ec0:	2e2e0063 	cdpcs	0, 2, cr0, cr14, cr3, {3}
     ec4:	6572462f 	ldrbvs	r4, [r2, #-1583]!	@ 0xfffff9d1
{
     ec8:	4f545265 	svcmi	0x00545265
     ecc:	654b2d53 	strbvs	r2, [fp, #-3411]	@ 0xfffff2ad
    pxTimeOut->xOverflowCount = xNumOfOverflows;
     ed0:	6c656e72 	stclvs	14, cr6, [r5], #-456	@ 0xfffffe38
     ed4:	726f702f 	rsbvc	r7, pc, #47	@ 0x2f
    pxTimeOut->xTimeOnEntering = xTickCount;
     ed8:	6c626174 	stfvse	f6, [r2], #-464	@ 0xfffffe30
     edc:	654d2f65 	strbvs	r2, [sp, #-3941]	@ 0xfffff09b
}
     ee0:	6e614d6d 	cdpvs	13, 6, cr4, cr1, cr13, {3}
     ee4:	65682f67 	strbvs	r2, [r8, #-3943]!	@ 0xfffff099
     ee8:	345f7061 	ldrbcc	r7, [pc], #-97	@ ef0 <vTaskInternalSetTimeOutState+0x28>
     eec:	7800632e 	stmdavc	r0, {r1, r2, r3, r5, r8, r9, sp, lr}
     ef0:	65657246 	strbvs	r7, [r5, #-582]!	@ 0xfffffdba
{
     ef4:	65747942 	ldrbvs	r7, [r4, #-2370]!	@ 0xfffff6be
     ef8:	6d655273 	sfmvs	f5, 2, [r5, #-460]!	@ 0xfffffe34
     efc:	696e6961 	stmdbvs	lr!, {r0, r5, r6, r8, fp, sp, lr}^
    taskENTER_CRITICAL();
     f00:	7800676e 	stmdavc	r0, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}
        const TickType_t xConstTickCount = xTickCount;
     f04:	657a6953 	ldrbvs	r6, [sl, #-2387]!	@ 0xfffff6ad
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
     f08:	614c664f 	cmpvs	ip, pc, asr #12
     f0c:	73656772 	cmnvc	r5, #29884416	@ 0x1c80000
     f10:	65724674 	ldrbvs	r4, [r2, #-1652]!	@ 0xfffff98c
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) )
     f14:	6f6c4265 	svcvs	0x006c4265
     f18:	6e496b63 	vmlsvs.f64	d22, d9, d19
     f1c:	65747942 	ldrbvs	r7, [r4, #-2370]!	@ 0xfffff6be
     f20:	72700073 	rsbsvc	r0, r0, #115	@ 0x73
     f24:	61654876 	smcvs	21638	@ 0x5486
            xReturn = pdTRUE;
     f28:	696e4970 	stmdbvs	lr!, {r4, r5, r6, r8, fp, lr}^
            *pxTicksToWait = ( TickType_t ) 0;
     f2c:	78700074 	ldmdavc	r0!, {r2, r4, r5, r6}^
     f30:	636f6c42 	cmnvs	pc, #16896	@ 0x4200
        else if( xElapsedTime < *pxTicksToWait )
     f34:	496f546b 	stmdbmi	pc!, {r0, r1, r3, r5, r6, sl, ip, lr}^	@ <UNPREDICTABLE>
     f38:	7265736e 	rsbvc	r7, r5, #-1207959551	@ 0xb8000001
     f3c:	78700074 	ldmdavc	r0!, {r2, r4, r5, r6}^
            *pxTicksToWait -= xElapsedTime;
     f40:	7478654e 	ldrbtvc	r6, [r8], #-1358	@ 0xfffffab2
     f44:	65657246 	strbvs	r7, [r5, #-582]!	@ 0xfffffdba
     f48:	636f6c42 	cmnvs	pc, #16896	@ 0x4200
            vTaskInternalSetTimeOutState( pxTimeOut );
     f4c:	5478006b 	ldrbtpl	r0, [r8], #-107	@ 0xffffff95
            xReturn = pdFALSE;
     f50:	6c61746f 	cfstrdvs	mvd7, [r1], #-444	@ 0xfffffe44
     f54:	70616548 	rsbvc	r6, r1, r8, asr #10
            *pxTicksToWait = ( TickType_t ) 0;
     f58:	657a6953 	ldrbvs	r6, [sl, #-2387]!	@ 0xfffff6ad
            xReturn = pdTRUE;
     f5c:	754e7800 	strbvc	r7, [lr, #-2048]	@ 0xfffff800
    taskEXIT_CRITICAL();
     f60:	7265626d 	rsbvc	r6, r5, #-805306362	@ 0xd0000006
    return xReturn;
     f64:	7553664f 	ldrbvc	r6, [r3, #-1615]	@ 0xfffff9b1
}
     f68:	73656363 	cmnvc	r5, #-1946157055	@ 0x8c000001
     f6c:	6c756673 	ldclvs	6, cr6, [r5], #-460	@ 0xfffffe34
     f70:	65657246 	strbvs	r7, [r5, #-582]!	@ 0xfffffdba
     f74:	42780073 	rsbsmi	r0, r8, #115	@ 0x73
{
     f78:	6b636f6c 	blvs	18dcd30 <xNumberOfSuccessfulFrees+0x18d80b4>
    xYieldPendings[ portGET_CORE_ID() ] = pdTRUE;
     f7c:	657a6953 	ldrbvs	r6, [sl, #-2387]!	@ 0xfffff6ad
     f80:	74537800 	ldrbvc	r7, [r3], #-2048	@ 0xfffff800
}
     f84:	00747261 	rsbseq	r7, r4, r1, ror #4
     f88:	6f6c4278 	svcvs	0x006c4278
     f8c:	00736b63 	rsbseq	r6, r3, r3, ror #22
{
     f90:	6d754e78 	ldclvs	14, cr4, [r5, #-480]!	@ 0xfffffe20
     f94:	46787000 	ldrbtmi	r7, [r8], -r0
        prvCheckTasksWaitingTermination();
     f98:	74737269 	ldrbtvc	r7, [r3], #-617	@ 0xfffffd97
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) configNUMBER_OF_CORES )
     f9c:	65657246 	strbvs	r7, [r5, #-582]!	@ 0xfffffdba
     fa0:	636f6c42 	cmnvs	pc, #16896	@ 0x4200
                taskYIELD();
     fa4:	5778006b 	ldrbpl	r0, [r8, -fp, rrx]!
     fa8:	65746e61 	ldrbvs	r6, [r4, #-3681]!	@ 0xfffff19f
     fac:	7a695364 	bvc	1a55d44 <xNumberOfSuccessfulFrees+0x1a510c8>
     fb0:	50760065 	rsbspl	r0, r6, r5, rrx
        prvCheckTasksWaitingTermination();
     fb4:	4974726f 	ldmdbmi	r4!, {r0, r1, r2, r3, r5, r6, r9, ip, sp, lr}^
     fb8:	6974696e 	ldmdbvs	r4!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
     fbc:	73696c61 	cmnvc	r9, #24832	@ 0x6100
{
     fc0:	6f6c4265 	svcvs	0x006c4265
     fc4:	00736b63 	rsbseq	r6, r3, r3, ror #22
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
     fc8:	726f5076 	rsbvc	r5, pc, #118	@ 0x76
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     fcc:	74654774 	strbtvc	r4, [r5], #-1908	@ 0xfffff88c
     fd0:	70616548 	rsbvc	r6, r1, r8, asr #10
     fd4:	74617453 	strbtvc	r7, [r1], #-1107	@ 0xfffffbad
     fd8:	78700073 	ldmdavc	r0!, {r0, r1, r4, r5, r6}^
     fdc:	6b6e694c 	blvs	1b9b514 <xNumberOfSuccessfulFrees+0x1b96898>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
     fe0:	48637500 	stmdami	r3!, {r8, sl, ip, sp, lr}^
     fe4:	00706165 	rsbseq	r6, r0, r5, ror #2
     fe8:	6f437870 	svcvs	0x00437870
    vListInitialise( &xDelayedTaskList1 );
     fec:	78006564 	stmdavc	r0, {r2, r5, r6, r8, sl, sp, lr}
     ff0:	74726f50 	ldrbtvc	r6, [r2], #-3920	@ 0xfffff0b0
    vListInitialise( &xDelayedTaskList2 );
     ff4:	646e6550 	strbtvs	r6, [lr], #-1360	@ 0xfffffab0
    vListInitialise( &xPendingReadyList );
     ff8:	61485653 	cmpvs	r8, r3, asr r6
     ffc:	656c646e 	strbvs	r6, [ip, #-1134]!	@ 0xfffffb92
    pxDelayedTaskList = &xDelayedTaskList1;
    1000:	72700072 	rsbsvc	r0, r0, #114	@ 0x72
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1004:	73615476 	cmnvc	r1, #1979711488	@ 0x76000000
    1008:	6978456b 	ldmdbvs	r8!, {r0, r1, r3, r5, r6, r8, sl, lr}^
}
    100c:	72724574 	rsbsvc	r4, r2, #116, 10	@ 0x1d000000
    1010:	7500726f 	strvc	r7, [r0, #-623]	@ 0xfffffd91
    1014:	6d75446c 	cfldrdvs	mvd4, [r5, #-432]!	@ 0xfffffe50
    1018:	7800796d 	stmdavc	r0, {r0, r2, r3, r5, r6, r8, fp, ip, sp, lr}
    101c:	74726f50 	ldrbtvc	r6, [r2], #-3920	@ 0xfffff0b0
    1020:	54737953 	ldrbtpl	r7, [r3], #-2387	@ 0xfffff6ad
    1024:	486b6369 	stmdami	fp!, {r0, r3, r5, r6, r8, r9, sp, lr}^
    1028:	6c646e61 	stclvs	14, cr6, [r4], #-388	@ 0xfffffe7c
{
    102c:	75007265 	strvc	r7, [r0, #-613]	@ 0xfffffd9b
}
    1030:	69724378 	ldmdbvs	r2!, {r3, r4, r5, r6, r8, r9, lr}^
    1034:	61636974 	smcvs	13972	@ 0x3694
{
    1038:	73654e6c 	cmnvc	r5, #108, 28	@ 0x6c0
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    103c:	676e6974 			@ <UNDEFINED> instruction: 0x676e6974
    1040:	6f507600 	svcvs	0x00507600
    1044:	65537472 	ldrbvs	r7, [r3, #-1138]	@ 0xfffffb8e
        xNextTaskUnblockTime = portMAX_DELAY;
    1048:	54707574 	ldrbtpl	r7, [r0], #-1396	@ 0xfffffa8c
    104c:	72656d69 	rsbvc	r6, r5, #6720	@ 0x1a40
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    1050:	65746e49 	ldrbvs	r6, [r4, #-3657]!	@ 0xfffff1b7
    1054:	70757272 	rsbsvc	r7, r5, r2, ror r2
    1058:	2e2e0074 	mcrcs	0, 1, r0, cr14, cr4, {3}
}
    105c:	6572462f 	ldrbvs	r4, [r2, #-1583]!	@ 0xfffff9d1
    1060:	4f545265 	svcmi	0x00545265
    1064:	654b2d53 	strbvs	r2, [fp, #-3411]	@ 0xfffff2ad
    1068:	6c656e72 	stclvs	14, cr6, [r5], #-456	@ 0xfffffe38
        {
    106c:	726f702f 	rsbvc	r7, pc, #47	@ 0x2f
    1070:	6c626174 	stfvse	f6, [r2], #-464	@ 0xfffffe30
            xReturn = pxCurrentTCB;
    1074:	43472f65 	movtmi	r2, #32613	@ 0x7f65
            return xReturn;
    1078:	52412f43 	subpl	r2, r1, #268	@ 0x10c
        }
    107c:	4d435f4d 	stclmi	15, cr5, [r3, #-308]	@ 0xfffffecc
    1080:	6f702f33 	svcvs	0x00702f33
    1084:	632e7472 			@ <UNDEFINED> instruction: 0x632e7472
    {
    1088:	56787000 	ldrbtpl	r7, [r8], -r0
    108c:	6f746365 	svcvs	0x00746365
        TaskHandle_t xReturn = NULL;
    1090:	62615472 	rsbvs	r5, r1, #1912602624	@ 0x72000000
        if( taskVALID_CORE_ID( xCoreID ) != pdFALSE )
    1094:	7000656c 	andvc	r6, r0, ip, ror #10
    1098:	4974726f 	ldmdbmi	r4!, {r0, r1, r2, r3, r5, r6, r9, ip, sp, lr}^
    109c:	745f5253 	ldrbvc	r5, [pc], #-595	@ 10a4 <xTaskGetCurrentTaskHandleForCore+0x1c>
                xReturn = pxCurrentTCB;
    10a0:	6f507600 	svcvs	0x00507600
    10a4:	56537472 			@ <UNDEFINED> instruction: 0x56537472
    }
    10a8:	6e614843 	cdpvs	8, 6, cr4, cr1, cr3, {2}
    10ac:	72656c64 	rsbvc	r6, r5, #100, 24	@ 0x6400
    10b0:	76727000 	ldrbtvc	r7, [r2], -r0
    10b4:	74726f50 	ldrbtvc	r6, [r2], #-3920	@ 0xfffff0b0
{
    10b8:	72617453 	rsbvc	r7, r1, #1392508928	@ 0x53000000
    10bc:	72694674 	rsbvc	r4, r9, #116, 12	@ 0x7400000
    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    10c0:	61547473 	cmpvs	r4, r3, ror r4
    10c4:	Address 0x10c4 is out of bounds.


Disassembly of section .debug_frame:

00000000 <.debug_frame>:
   0:	0000000c 	andeq	r0, r0, ip
   4:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
   8:	7c020001 	stcvc	0, cr0, [r2], {1}
   c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  10:	00000018 	andeq	r0, r0, r8, lsl r0
  14:	00000000 	andeq	r0, r0, r0
  18:	0000019c 	muleq	r0, ip, r1
  1c:	0000000c 	andeq	r0, r0, ip
  20:	87080e41 	strhi	r0, [r8, -r1, asr #28]
  24:	41018e02 	tstmi	r1, r2, lsl #28
  28:	0000070d 	andeq	r0, r0, sp, lsl #14
  2c:	0000000c 	andeq	r0, r0, ip
  30:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  34:	7c020001 	stcvc	0, cr0, [r2], {1}
  38:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  3c:	00000024 	andeq	r0, r0, r4, lsr #32
  40:	0000002c 	andeq	r0, r0, ip, lsr #32
  44:	000001a8 	andeq	r0, r0, r8, lsr #3
  48:	0000003a 	andeq	r0, r0, sl, lsr r0
  4c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
  50:	200e4101 	andcs	r4, lr, r1, lsl #2
  54:	57070d41 	strpl	r0, [r7, -r1, asr #26]
  58:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
  5c:	0ec7410d 	poleqs	f4, f7, #5.0
  60:	00000000 	andeq	r0, r0, r0
  64:	0000000c 	andeq	r0, r0, ip
  68:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
  6c:	7c020001 	stcvc	0, cr0, [r2], {1}
  70:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  74:	00000020 	andeq	r0, r0, r0, lsr #32
  78:	00000064 	andeq	r0, r0, r4, rrx
  7c:	000001e4 	andeq	r0, r0, r4, ror #3
  80:	00000078 	andeq	r0, r0, r8, ror r0
  84:	87080e41 	strhi	r0, [r8, -r1, asr #28]
  88:	41018e02 	tstmi	r1, r2, lsl #28
  8c:	0c41300e 	mcrreq	0, 0, r3, r1, cr14
  90:	0e772007 	cdpeq	0, 7, cr2, cr7, cr7, {0}
  94:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
  98:	00000020 	andeq	r0, r0, r0, lsr #32
  9c:	00000064 	andeq	r0, r0, r4, rrx
  a0:	0000025c 	andeq	r0, r0, ip, asr r2
  a4:	00000046 	andeq	r0, r0, r6, asr #32
  a8:	87080e41 	strhi	r0, [r8, -r1, asr #28]
  ac:	41018e02 	tstmi	r1, r2, lsl #28
  b0:	0c41280e 	mcrreq	8, 0, r2, r1, cr14
  b4:	0e5e2007 	cdpeq	0, 5, cr2, cr14, cr7, {0}
  b8:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
  bc:	00000020 	andeq	r0, r0, r0, lsr #32
  c0:	00000064 	andeq	r0, r0, r4, rrx
  c4:	000002a2 	andeq	r0, r0, r2, lsr #5
  c8:	000000ca 	andeq	r0, r0, sl, asr #1
  cc:	87080e41 	strhi	r0, [r8, -r1, asr #28]
  d0:	41018e02 	tstmi	r1, r2, lsl #28
  d4:	0d41200e 	stcleq	0, cr2, [r1, #-56]	@ 0xffffffc8
  d8:	0e600207 	cdpeq	2, 6, cr0, cr0, cr7, {0}
  dc:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
  e0:	00000020 	andeq	r0, r0, r0, lsr #32
  e4:	00000064 	andeq	r0, r0, r4, rrx
  e8:	0000036c 	andeq	r0, r0, ip, ror #6
  ec:	00000128 	andeq	r0, r0, r8, lsr #2
  f0:	87080e41 	strhi	r0, [r8, -r1, asr #28]
  f4:	41018e02 	tstmi	r1, r2, lsl #28
  f8:	0d41180e 	stcleq	8, cr1, [r1, #-56]	@ 0xffffffc8
  fc:	0e810207 	cdpeq	2, 8, cr0, cr1, cr7, {0}
 100:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
 104:	00000024 	andeq	r0, r0, r4, lsr #32
 108:	00000064 	andeq	r0, r0, r4, rrx
 10c:	00000494 	muleq	r0, r4, r4
 110:	000000ac 	andeq	r0, r0, ip, lsr #1
 114:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 118:	41018e02 	tstmi	r1, r2, lsl #28
 11c:	0c41300e 	mcrreq	0, 0, r3, r1, cr14
 120:	4b022807 	blmi	8a144 <xNumberOfSuccessfulFrees+0x854c8>
 124:	0d41080e 	stcleq	8, cr0, [r1, #-56]	@ 0xffffffc8
 128:	0000000d 	andeq	r0, r0, sp
 12c:	00000020 	andeq	r0, r0, r0, lsr #32
 130:	00000064 	andeq	r0, r0, r4, rrx
 134:	00000540 	andeq	r0, r0, r0, asr #10
 138:	0000005c 	andeq	r0, r0, ip, asr r0
 13c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 140:	41018e02 	tstmi	r1, r2, lsl #28
 144:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
 148:	080e6007 	stmdaeq	lr, {r0, r1, r2, sp, lr}
 14c:	000d0d41 	andeq	r0, sp, r1, asr #26
 150:	00000020 	andeq	r0, r0, r0, lsr #32
 154:	00000064 	andeq	r0, r0, r4, rrx
 158:	0000059c 	muleq	r0, ip, r5
 15c:	00000030 	andeq	r0, r0, r0, lsr r0
 160:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 164:	41018e02 	tstmi	r1, r2, lsl #28
 168:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
 16c:	080e5107 	stmdaeq	lr, {r0, r1, r2, r8, ip, lr}
 170:	000d0d41 	andeq	r0, sp, r1, asr #26
 174:	0000001c 	andeq	r0, r0, ip, lsl r0
 178:	00000064 	andeq	r0, r0, r4, rrx
 17c:	000005cc 	andeq	r0, r0, ip, asr #11
 180:	0000001c 	andeq	r0, r0, ip, lsl r0
 184:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 188:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 18c:	410d0d47 	tstmi	sp, r7, asr #26
 190:	00000ec7 	andeq	r0, r0, r7, asr #29
 194:	00000020 	andeq	r0, r0, r0, lsr #32
 198:	00000064 	andeq	r0, r0, r4, rrx
{
 19c:	000005e8 	andeq	r0, r0, r8, ror #11
    vTaskStartScheduler();
 1a0:	000001f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
    return;
 1a4:	87080e41 	strhi	r0, [r8, -r1, asr #28]
void* memset(void* dst, int value, unsigned int size) {
 1a8:	41018e02 	tstmi	r1, r2, lsl #28
 1ac:	0d41280e 	stcleq	8, cr2, [r1, #-56]	@ 0xffffffc8
 1b0:	0ee10207 	cdpeq	2, 14, cr0, cr1, cr7, {0}
    unsigned char *ptr = (unsigned char *)dst;
 1b4:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
    unsigned char byte_value = (unsigned char)value;
 1b8:	00000024 	andeq	r0, r0, r4, lsr #32
    while(size > 0){
 1bc:	00000064 	andeq	r0, r0, r4, rrx
        *ptr = byte_value;
 1c0:	000007d8 	ldrdeq	r0, [r0], -r8
        ptr++;
 1c4:	0000001c 	andeq	r0, r0, ip, lsl r0
 1c8:	87040e41 	strhi	r0, [r4, -r1, asr #28]
        size--;
 1cc:	100e4101 	andne	r4, lr, r1, lsl #2
    while(size > 0){
 1d0:	46070d41 	strmi	r0, [r7], -r1, asr #26
 1d4:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 1d8:	0ec7410d 	poleqs	f4, f7, #5.0
 1dc:	00000000 	andeq	r0, r0, r0
 1e0:	00000024 	andeq	r0, r0, r4, lsr #32
    {
 1e4:	00000064 	andeq	r0, r0, r4, rrx
 1e8:	000007f4 	strdeq	r0, [r0], -r4
 1ec:	00000020 	andeq	r0, r0, r0, lsr #32
 1f0:	87040e41 	strhi	r0, [r4, -r1, asr #28]
            pxStack = pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) );
 1f4:	100e4101 	andne	r4, lr, r1, lsl #2
 1f8:	48070d41 	stmdami	r7, {r0, r6, r8, sl, fp}
 1fc:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
            if( pxStack != NULL )
 200:	0ec7410d 	poleqs	f4, f7, #5.0
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 204:	00000000 	andeq	r0, r0, r0
 208:	0000001c 	andeq	r0, r0, ip, lsl r0
                if( pxNewTCB != NULL )
 20c:	00000064 	andeq	r0, r0, r4, rrx
 210:	00000814 	andeq	r0, r0, r4, lsl r8
                    ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 214:	00000014 	andeq	r0, r0, r4, lsl r0
 218:	87040e41 	strhi	r0, [r4, -r1, asr #28]
                    pxNewTCB->pxStack = pxStack;
 21c:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 220:	410d0d44 	tstmi	sp, r4, asr #26
                    vPortFreeStack( pxStack );
 224:	00000ec7 	andeq	r0, r0, r7, asr #29
 228:	00000024 	andeq	r0, r0, r4, lsr #32
                pxNewTCB = NULL;
 22c:	00000064 	andeq	r0, r0, r4, rrx
        if( pxNewTCB != NULL )
 230:	00000828 	andeq	r0, r0, r8, lsr #16
 234:	0000002c 	andeq	r0, r0, ip, lsr #32
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 238:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 23c:	180e4101 	stmdane	lr, {r0, r8, lr}
 240:	4d070d41 	stcmi	13, cr0, [r7, #-260]	@ 0xfffffefc
 244:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 248:	0ec7410d 	poleqs	f4, f7, #5.0
 24c:	00000000 	andeq	r0, r0, r0
 250:	00000020 	andeq	r0, r0, r0, lsr #32
    }
 254:	00000064 	andeq	r0, r0, r4, rrx
 258:	00000854 	andeq	r0, r0, r4, asr r8
    {
 25c:	00000034 	andeq	r0, r0, r4, lsr r0
 260:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 264:	41018e02 	tstmi	r1, r2, lsl #28
 268:	0d41180e 	stcleq	8, cr1, [r1, #-56]	@ 0xffffffc8
        pxNewTCB = prvCreateTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask );
 26c:	080e5307 	stmdaeq	lr, {r0, r1, r2, r8, r9, ip, lr}
 270:	000d0d41 	andeq	r0, sp, r1, asr #26
 274:	00000020 	andeq	r0, r0, r0, lsr #32
 278:	00000064 	andeq	r0, r0, r4, rrx
 27c:	00000888 	andeq	r0, r0, r8, lsl #17
        if( pxNewTCB != NULL )
 280:	00000210 	andeq	r0, r0, r0, lsl r2
 284:	87080e41 	strhi	r0, [r8, -r1, asr #28]
            prvAddNewTaskToReadyList( pxNewTCB );
 288:	41018e02 	tstmi	r1, r2, lsl #28
            xReturn = pdPASS;
 28c:	0d41280e 	stcleq	8, cr2, [r1, #-56]	@ 0xffffffc8
 290:	0eed0207 	cdpeq	2, 14, cr0, cr13, cr7, {0}
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 294:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
        return xReturn;
 298:	00000024 	andeq	r0, r0, r4, lsr #32
    }
 29c:	00000064 	andeq	r0, r0, r4, rrx
 2a0:	00000a98 	muleq	r0, r8, sl
{
 2a4:	0000008c 	andeq	r0, r0, ip, lsl #1
 2a8:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 2ac:	180e4101 	stmdane	lr, {r0, r8, lr}
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
 2b0:	76070d41 	strvc	r0, [r7], -r1, asr #26
 2b4:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 2b8:	0ec7410d 	poleqs	f4, f7, #5.0
 2bc:	00000000 	andeq	r0, r0, r0
 2c0:	00000020 	andeq	r0, r0, r0, lsr #32
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 2c4:	00000064 	andeq	r0, r0, r4, rrx
 2c8:	00000b24 	andeq	r0, r0, r4, lsr #22
    if( pcName != NULL )
 2cc:	0000002c 	andeq	r0, r0, ip, lsr #32
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 2d0:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 2d4:	41018e02 	tstmi	r1, r2, lsl #28
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 2d8:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
 2dc:	080e4f07 	stmdaeq	lr, {r0, r1, r2, r8, r9, sl, fp, lr}
 2e0:	000d0d41 	andeq	r0, sp, r1, asr #26
 2e4:	00000020 	andeq	r0, r0, r0, lsr #32
 2e8:	00000064 	andeq	r0, r0, r4, rrx
            if( pcName[ x ] == ( char ) 0x00 )
 2ec:	00000b50 	andeq	r0, r0, r0, asr fp
 2f0:	00000070 	andeq	r0, r0, r0, ror r0
 2f4:	87080e41 	strhi	r0, [r8, -r1, asr #28]
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 2f8:	41018e02 	tstmi	r1, r2, lsl #28
 2fc:	0d41200e 	stcleq	0, cr2, [r1, #-56]	@ 0xffffffc8
 300:	080e7007 	stmdaeq	lr, {r0, r1, r2, ip, sp, lr}
                break;
 304:	000d0d41 	andeq	r0, sp, r1, asr #26
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1U ] = '\0';
 308:	00000024 	andeq	r0, r0, r4, lsr #32
 30c:	00000064 	andeq	r0, r0, r4, rrx
    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 310:	00000bc0 	andeq	r0, r0, r0, asr #23
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 314:	00000194 	muleq	r0, r4, r1
    pxNewTCB->uxPriority = uxPriority;
 318:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 31c:	280e4101 	stmdacs	lr, {r0, r8, lr}
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 320:	02070d41 	andeq	r0, r7, #4160	@ 0x1040
 324:	41040eb7 			@ <UNDEFINED> instruction: 0x41040eb7
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 328:	c7410d0d 	strbgt	r0, [r1, -sp, lsl #26]
 32c:	0000000e 	andeq	r0, r0, lr
 330:	00000024 	andeq	r0, r0, r4, lsr #32
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 334:	00000064 	andeq	r0, r0, r4, rrx
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );
 338:	00000d54 	andeq	r0, r0, r4, asr sp
 33c:	00000144 	andeq	r0, r0, r4, asr #2
 340:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 344:	200e4101 	andcs	r4, lr, r1, lsl #2
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 348:	02070d41 	andeq	r0, r7, #4160	@ 0x1040
 34c:	41040e94 			@ <UNDEFINED> instruction: 0x41040e94
 350:	c7410d0d 	strbgt	r0, [r1, -sp, lsl #26]
 354:	0000000e 	andeq	r0, r0, lr
    if( pxCreatedTask != NULL )
 358:	00000020 	andeq	r0, r0, r0, lsr #32
 35c:	00000064 	andeq	r0, r0, r4, rrx
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 360:	00000e98 	muleq	r0, r8, lr
}
 364:	00000030 	andeq	r0, r0, r0, lsr r0
 368:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    {
 36c:	41018e02 	tstmi	r1, r2, lsl #28
 370:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
        taskENTER_CRITICAL();
 374:	080e4f07 	stmdaeq	lr, {r0, r1, r2, r8, r9, sl, fp, lr}
            uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );
 378:	000d0d41 	andeq	r0, sp, r1, asr #26
 37c:	00000024 	andeq	r0, r0, r4, lsr #32
 380:	00000064 	andeq	r0, r0, r4, rrx
            if( pxCurrentTCB == NULL )
 384:	00000ec8 	andeq	r0, r0, r8, asr #29
 388:	0000002c 	andeq	r0, r0, ip, lsr #32
                pxCurrentTCB = pxNewTCB;
 38c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
                if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 390:	100e4101 	andne	r4, lr, r1, lsl #2
 394:	4b070d41 	blmi	1c38a0 <xNumberOfSuccessfulFrees+0x1bec24>
                    prvInitialiseTaskLists();
 398:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 39c:	0ec7410d 	poleqs	f4, f7, #5.0
                if( xSchedulerRunning == pdFALSE )
 3a0:	00000000 	andeq	r0, r0, r0
 3a4:	00000020 	andeq	r0, r0, r0, lsr #32
                    if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 3a8:	00000064 	andeq	r0, r0, r4, rrx
 3ac:	00000ef4 	strdeq	r0, [r0], -r4
 3b0:	00000084 	andeq	r0, r0, r4, lsl #1
                        pxCurrentTCB = pxNewTCB;
 3b4:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 3b8:	41018e02 	tstmi	r1, r2, lsl #28
            uxTaskNumber++;
 3bc:	0d41200e 	stcleq	0, cr2, [r1, #-56]	@ 0xffffffc8
 3c0:	080e7807 	stmdaeq	lr, {r0, r1, r2, fp, ip, sp, lr}
            prvAddTaskToReadyList( pxNewTCB );
 3c4:	000d0d41 	andeq	r0, sp, r1, asr #26
 3c8:	0000001c 	andeq	r0, r0, ip, lsl r0
 3cc:	00000064 	andeq	r0, r0, r4, rrx
 3d0:	00000f78 	andeq	r0, r0, r8, ror pc
 3d4:	00000018 	andeq	r0, r0, r8, lsl r0
 3d8:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 3dc:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 3e0:	410d0d45 	tstmi	sp, r5, asr #26
 3e4:	00000ec7 	andeq	r0, r0, r7, asr #29
 3e8:	0000001c 	andeq	r0, r0, ip, lsl r0
 3ec:	00000064 	andeq	r0, r0, r4, rrx
 3f0:	00000f90 	muleq	r0, r0, pc	@ <UNPREDICTABLE>
 3f4:	00000030 	andeq	r0, r0, r0, lsr r0
 3f8:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 3fc:	41018e02 	tstmi	r1, r2, lsl #28
 400:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
 404:	00000007 	andeq	r0, r0, r7
 408:	00000020 	andeq	r0, r0, r0, lsr #32
 40c:	00000064 	andeq	r0, r0, r4, rrx
 410:	00000fc0 	andeq	r0, r0, r0, asr #31
 414:	0000006c 	andeq	r0, r0, ip, rrx
 418:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 41c:	41018e02 	tstmi	r1, r2, lsl #28
 420:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
 424:	080e6407 	stmdaeq	lr, {r0, r1, r2, sl, sp, lr}
 428:	000d0d41 	andeq	r0, sp, r1, asr #26
 42c:	0000001c 	andeq	r0, r0, ip, lsl r0
 430:	00000064 	andeq	r0, r0, r4, rrx
 434:	0000102c 	andeq	r1, r0, ip, lsr #32
 438:	0000000c 	andeq	r0, r0, ip
 43c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 440:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 444:	410d0d42 	tstmi	sp, r2, asr #26
        taskEXIT_CRITICAL();
 448:	00000ec7 	andeq	r0, r0, r7, asr #29
        if( xSchedulerRunning != pdFALSE )
 44c:	0000001c 	andeq	r0, r0, ip, lsl r0
 450:	00000064 	andeq	r0, r0, r4, rrx
            taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
 454:	00001038 	andeq	r1, r0, r8, lsr r0
 458:	00000034 	andeq	r0, r0, r4, lsr r0
 45c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 460:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 464:	410d0d52 	tstmi	sp, r2, asr sp
 468:	00000ec7 	andeq	r0, r0, r7, asr #29
 46c:	00000024 	andeq	r0, r0, r4, lsr #32
    }
 470:	00000064 	andeq	r0, r0, r4, rrx
 474:	0000106c 	andeq	r1, r0, ip, rrx
 478:	0000001c 	andeq	r0, r0, ip, lsl r0
 47c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 480:	100e4101 	andne	r4, lr, r1, lsl #2
 484:	46070d41 	strmi	r0, [r7], -r1, asr #26
 488:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 48c:	0ec7410d 	poleqs	f4, f7, #5.0
 490:	00000000 	andeq	r0, r0, r0
{
 494:	00000024 	andeq	r0, r0, r4, lsr #32
 498:	00000064 	andeq	r0, r0, r4, rrx
    BaseType_t xReturn = pdPASS;
 49c:	00001088 	andeq	r1, r0, r8, lsl #1
    char cIdleName[ configMAX_TASK_NAME_LEN ] = { 0 };
 4a0:	00000030 	andeq	r0, r0, r0, lsr r0
 4a4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 4a8:	180e4101 	stmdane	lr, {r0, r8, lr}
    TaskFunction_t pxIdleTaskFunction = NULL;
 4ac:	4f070d41 	svcmi	0x00070d41
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
 4b0:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
        cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
 4b4:	0ec7410d 	poleqs	f4, f7, #5.0
 4b8:	00000000 	andeq	r0, r0, r0
 4bc:	00000024 	andeq	r0, r0, r4, lsr #32
 4c0:	00000064 	andeq	r0, r0, r4, rrx
 4c4:	000010b8 	strheq	r1, [r0], -r8
        if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
 4c8:	00000030 	andeq	r0, r0, r0, lsr r0
 4cc:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 4d0:	100e4101 	andne	r4, lr, r1, lsl #2
    for( xIdleTaskNameIndex = 0U; xIdleTaskNameIndex < ( configMAX_TASK_NAME_LEN - taskRESERVED_TASK_NAME_LENGTH ); xIdleTaskNameIndex++ )
 4d4:	4f070d41 	svcmi	0x00070d41
 4d8:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 4dc:	0ec7410d 	poleqs	f4, f7, #5.0
            break;
 4e0:	00000000 	andeq	r0, r0, r0
    cIdleName[ xIdleTaskNameIndex ] = '\0';
 4e4:	00000020 	andeq	r0, r0, r0, lsr #32
 4e8:	00000064 	andeq	r0, r0, r4, rrx
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
 4ec:	000010e8 	andeq	r1, r0, r8, ror #1
 4f0:	000000f0 	strdeq	r0, [r0], -r0	@ <UNPREDICTABLE>
            pxIdleTaskFunction = &prvIdleTask;
 4f4:	87080e41 	strhi	r0, [r8, -r1, asr #28]
            xReturn = xTaskCreate( pxIdleTaskFunction,
 4f8:	41018e02 	tstmi	r1, r2, lsl #28
 4fc:	0d41280e 	stcleq	8, cr2, [r1, #-56]	@ 0xffffffc8
 500:	0e6f0207 	cdpeq	2, 6, cr0, cr15, cr7, {0}
 504:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
 508:	00000020 	andeq	r0, r0, r0, lsr #32
 50c:	00000064 	andeq	r0, r0, r4, rrx
 510:	000011d8 	ldrdeq	r1, [r0], -r8
        if( xReturn != pdPASS )
 514:	00000124 	andeq	r0, r0, r4, lsr #2
 518:	87080e41 	strhi	r0, [r8, -r1, asr #28]
    for( xCoreID = ( BaseType_t ) 0; xCoreID < ( BaseType_t ) configNUMBER_OF_CORES; xCoreID++ )
 51c:	41018e02 	tstmi	r1, r2, lsl #28
 520:	0d41280e 	stcleq	8, cr2, [r1, #-56]	@ 0xffffffc8
 524:	0e880207 	cdpeq	2, 8, cr0, cr8, cr7, {0}
            break;
 528:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
}
 52c:	00000020 	andeq	r0, r0, r0, lsr #32
 530:	00000064 	andeq	r0, r0, r4, rrx
 534:	000012fc 	strdeq	r1, [r0], -ip
 538:	000001d4 	ldrdeq	r0, [r0], -r4
 53c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
{
 540:	41018e02 	tstmi	r1, r2, lsl #28
 544:	0d41300e 	stcleq	0, cr3, [r1, #-56]	@ 0xffffffc8
    xReturn = prvCreateIdleTasks();
 548:	0edc0207 	cdpeq	2, 13, cr0, cr12, cr7, {0}
    if( xReturn == pdPASS )
 54c:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
 550:	00000024 	andeq	r0, r0, r4, lsr #32
    __asm volatile
 554:	00000064 	andeq	r0, r0, r4, rrx
 558:	000014d0 	ldrdeq	r1, [r0], -r0
 55c:	0000024c 	andeq	r0, r0, ip, asr #4
 560:	87040e41 	strhi	r0, [r4, -r1, asr #28]
}
 564:	400e4101 	andmi	r4, lr, r1, lsl #2
        xNextTaskUnblockTime = portMAX_DELAY;
 568:	03070d41 	movweq	r0, #32065	@ 0x7d41
 56c:	040e0113 	streq	r0, [lr], #-275	@ 0xfffffeed
        xSchedulerRunning = pdTRUE;
 570:	410d0d41 	tstmi	sp, r1, asr #26
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 574:	00000ec7 	andeq	r0, r0, r7, asr #29
 578:	00000024 	andeq	r0, r0, r4, lsr #32
        ( void ) xPortStartScheduler();
 57c:	00000064 	andeq	r0, r0, r4, rrx
    ( void ) uxTopUsedPriority;
 580:	0000171c 	andeq	r1, r0, ip, lsl r7
}
 584:	000001bc 			@ <UNDEFINED> instruction: 0x000001bc
 588:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 58c:	400e4101 	andmi	r4, lr, r1, lsl #2
 590:	02070d41 	andeq	r0, r7, #4160	@ 0x1040
 594:	41040ecb 	smlabtmi	r4, fp, lr, r0
 598:	c7410d0d 	strbgt	r0, [r1, -sp, lsl #26]
{
 59c:	0000000e 	andeq	r0, r0, lr
 5a0:	00000020 	andeq	r0, r0, r0, lsr #32
    __asm volatile
 5a4:	00000064 	andeq	r0, r0, r4, rrx
 5a8:	000018d8 	ldrdeq	r1, [r0], -r8
 5ac:	00000058 	andeq	r0, r0, r8, asr r0
 5b0:	87080e41 	strhi	r0, [r8, -r1, asr #28]
}
 5b4:	41018e02 	tstmi	r1, r2, lsl #28
    xSchedulerRunning = pdFALSE;
 5b8:	0d41180e 	stcleq	8, cr1, [r1, #-56]	@ 0xffffffc8
    vPortEndScheduler();
 5bc:	080e6407 	stmdaeq	lr, {r0, r1, r2, sl, sp, lr}
}
 5c0:	000d0d41 	andeq	r0, sp, r1, asr #26
 5c4:	00000020 	andeq	r0, r0, r0, lsr #32
 5c8:	00000064 	andeq	r0, r0, r4, rrx
{
 5cc:	00001930 	andeq	r1, r0, r0, lsr r9
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
 5d0:	00000060 	andeq	r0, r0, r0, rrx
 5d4:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 5d8:	41018e02 	tstmi	r1, r2, lsl #28
}
 5dc:	0d41200e 	stcleq	0, cr2, [r1, #-56]	@ 0xffffffc8
 5e0:	080e6807 	stmdaeq	lr, {r0, r1, r2, fp, sp, lr}
 5e4:	000d0d41 	andeq	r0, sp, r1, asr #26
{
 5e8:	00000020 	andeq	r0, r0, r0, lsr #32
 5ec:	00000064 	andeq	r0, r0, r4, rrx
    TCB_t * pxTCB = NULL;
 5f0:	00001990 	muleq	r0, r0, r9
    BaseType_t xAlreadyYielded = pdFALSE;
 5f4:	000000ac 	andeq	r0, r0, ip, lsr #1
        taskENTER_CRITICAL();
 5f8:	87080e41 	strhi	r0, [r8, -r1, asr #28]
            const BaseType_t xCoreID = ( BaseType_t ) portGET_CORE_ID();
 5fc:	41018e02 	tstmi	r1, r2, lsl #28
            uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended - 1U );
 600:	0d41200e 	stcleq	0, cr2, [r1, #-56]	@ 0xffffffc8
 604:	0e450207 	cdpeq	2, 4, cr0, cr5, cr7, {0}
            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 608:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
 60c:	00000024 	andeq	r0, r0, r4, lsr #32
 610:	00000064 	andeq	r0, r0, r4, rrx
                if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 614:	00001a3c 	andeq	r1, r0, ip, lsr sl
 618:	00000094 	muleq	r0, r4, r0
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 61c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 620:	100e4101 	andne	r4, lr, r1, lsl #2
 624:	6e070d41 	cdpvs	13, 0, cr0, cr7, cr1, {2}
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 628:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 62c:	0ec7410d 	poleqs	f4, f7, #5.0
 630:	00000000 	andeq	r0, r0, r0
 634:	0000000c 	andeq	r0, r0, ip
 638:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 63c:	7c020001 	stcvc	0, cr0, [r2], {1}
 640:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 644:	00000024 	andeq	r0, r0, r4, lsr #32
 648:	00000634 	andeq	r0, r0, r4, lsr r6
 64c:	00001ad0 	ldrdeq	r1, [r0], -r0
 650:	0000003e 	andeq	r0, r0, lr, lsr r0
 654:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 658:	100e4101 	andne	r4, lr, r1, lsl #2
 65c:	59070d41 	stmdbpl	r7, {r0, r6, r8, sl, fp}
 660:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 664:	0ec7410d 	poleqs	f4, f7, #5.0
 668:	00000000 	andeq	r0, r0, r0
 66c:	00000024 	andeq	r0, r0, r4, lsr #32
 670:	00000634 	andeq	r0, r0, r4, lsr r6
 674:	00001b0e 	andeq	r1, r0, lr, lsl #22
 678:	00000018 	andeq	r0, r0, r8, lsl r0
 67c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 680:	100e4101 	andne	r4, lr, r1, lsl #2
 684:	46070d41 	strmi	r0, [r7], -r1, asr #26
 688:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 68c:	0ec7410d 	poleqs	f4, f7, #5.0
 690:	00000000 	andeq	r0, r0, r0
 694:	00000024 	andeq	r0, r0, r4, lsr #32
 698:	00000634 	andeq	r0, r0, r4, lsr r6
 69c:	00001b26 	andeq	r1, r0, r6, lsr #22
 6a0:	00000046 	andeq	r0, r0, r6, asr #32
                        prvAddTaskToReadyList( pxTCB );
 6a4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 6a8:	180e4101 	stmdane	lr, {r0, r8, lr}
 6ac:	5d070d41 	stcpl	13, cr0, [r7, #-260]	@ 0xfffffefc
 6b0:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 6b4:	0ec7410d 	poleqs	f4, f7, #5.0
 6b8:	00000000 	andeq	r0, r0, r0
 6bc:	00000024 	andeq	r0, r0, r4, lsr #32
 6c0:	00000634 	andeq	r0, r0, r4, lsr r6
 6c4:	00001b6c 	andeq	r1, r0, ip, ror #22
 6c8:	00000070 	andeq	r0, r0, r0, ror r0
 6cc:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 6d0:	180e4101 	stmdane	lr, {r0, r8, lr}
 6d4:	72070d41 	andvc	r0, r7, #4160	@ 0x1040
 6d8:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 6dc:	0ec7410d 	poleqs	f4, f7, #5.0
 6e0:	00000000 	andeq	r0, r0, r0
 6e4:	00000024 	andeq	r0, r0, r4, lsr #32
 6e8:	00000634 	andeq	r0, r0, r4, lsr r6
 6ec:	00001bdc 	ldrdeq	r1, [r0], -ip
 6f0:	00000052 	andeq	r0, r0, r2, asr r0
 6f4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 6f8:	180e4101 	stmdane	lr, {r0, r8, lr}
 6fc:	63070d41 	movwvs	r0, #32065	@ 0x7d41
 700:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 704:	0ec7410d 	poleqs	f4, f7, #5.0
 708:	00000000 	andeq	r0, r0, r0
 70c:	0000000c 	andeq	r0, r0, ip
 710:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
 714:	7c020001 	stcvc	0, cr0, [r2], {1}
 718:	000d0c0e 	andeq	r0, sp, lr, lsl #24
 71c:	00000020 	andeq	r0, r0, r0, lsr #32
 720:	0000070c 	andeq	r0, r0, ip, lsl #14
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 724:	00001c30 	andeq	r1, r0, r0, lsr ip
 728:	00000164 	andeq	r0, r0, r4, ror #2
 72c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 730:	41018e02 	tstmi	r1, r2, lsl #28
                                xYieldPendings[ xCoreID ] = pdTRUE;
 734:	0d41280e 	stcleq	8, cr2, [r1, #-56]	@ 0xffffffc8
 738:	0ea30207 	cdpeq	2, 10, cr0, cr3, cr7, {0}
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 73c:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
 740:	00000020 	andeq	r0, r0, r0, lsr #32
 744:	0000070c 	andeq	r0, r0, ip, lsl #14
                    if( pxTCB != NULL )
 748:	00001d94 	muleq	r0, r4, sp
                        prvResetNextTaskUnblockTime();
 74c:	00000074 	andeq	r0, r0, r4, ror r0
                        TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 750:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 754:	41018e02 	tstmi	r1, r2, lsl #28
                        if( xPendedCounts > ( TickType_t ) 0U )
 758:	0d41180e 	stcleq	8, cr1, [r1, #-56]	@ 0xffffffc8
                                if( xTaskIncrementTick() != pdFALSE )
 75c:	080e7007 	stmdaeq	lr, {r0, r1, r2, ip, sp, lr}
 760:	000d0d41 	andeq	r0, sp, r1, asr #26
 764:	0000001c 	andeq	r0, r0, ip, lsl r0
                                    xYieldPendings[ xCoreID ] = pdTRUE;
 768:	0000070c 	andeq	r0, r0, ip, lsl #14
 76c:	00001e08 	andeq	r1, r0, r8, lsl #28
                                --xPendedCounts;
 770:	00000014 	andeq	r0, r0, r4, lsl r0
 774:	87040e41 	strhi	r0, [r4, -r1, asr #28]
                            } while( xPendedCounts > ( TickType_t ) 0U );
 778:	070d4101 	streq	r4, [sp, -r1, lsl #2]
                            xPendedTicks = 0;
 77c:	410d0d44 	tstmi	sp, r4, asr #26
 780:	00000ec7 	andeq	r0, r0, r7, asr #29
                    if( xYieldPendings[ xCoreID ] != pdFALSE )
 784:	0000001c 	andeq	r0, r0, ip, lsl r0
 788:	0000070c 	andeq	r0, r0, ip, lsl #14
 78c:	00001e1c 	andeq	r1, r0, ip, lsl lr
                            xAlreadyYielded = pdTRUE;
 790:	00000014 	andeq	r0, r0, r4, lsl r0
                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
 794:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 798:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 79c:	410d0d44 	tstmi	sp, r4, asr #26
 7a0:	00000ec7 	andeq	r0, r0, r7, asr #29
 7a4:	0000001c 	andeq	r0, r0, ip, lsl r0
        taskEXIT_CRITICAL();
 7a8:	0000070c 	andeq	r0, r0, ip, lsl #14
}
 7ac:	00001e30 	andeq	r1, r0, r0, lsr lr
 7b0:	0000001c 	andeq	r0, r0, ip, lsl r0
 7b4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 7b8:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 7bc:	410d0d46 	tstmi	sp, r6, asr #26
 7c0:	00000ec7 	andeq	r0, r0, r7, asr #29
 7c4:	0000001c 	andeq	r0, r0, ip, lsl r0
 7c8:	0000070c 	andeq	r0, r0, ip, lsl #14
 7cc:	00001e4c 	andeq	r1, r0, ip, asr #28
 7d0:	0000000c 	andeq	r0, r0, ip
 7d4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
{
 7d8:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 7dc:	410d0d42 	tstmi	sp, r2, asr #26
        xTicks = xTickCount;
 7e0:	00000ec7 	andeq	r0, r0, r7, asr #29
    return xTicks;
 7e4:	00000020 	andeq	r0, r0, r0, lsr #32
}
 7e8:	0000070c 	andeq	r0, r0, ip, lsl #14
 7ec:	00001e58 	andeq	r1, r0, r8, asr lr
 7f0:	00000060 	andeq	r0, r0, r0, rrx
{
 7f4:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 7f8:	41018e02 	tstmi	r1, r2, lsl #28
    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 7fc:	0d41180e 	stcleq	8, cr1, [r1, #-56]	@ 0xffffffc8
        xReturn = xTickCount;
 800:	080e6b07 	stmdaeq	lr, {r0, r1, r2, r8, r9, fp, sp, lr}
    return xReturn;
 804:	000d0d41 	andeq	r0, sp, r1, asr #26
}
 808:	00000024 	andeq	r0, r0, r4, lsr #32
 80c:	0000070c 	andeq	r0, r0, ip, lsl #14
 810:	00001eb8 			@ <UNDEFINED> instruction: 0x00001eb8
{
 814:	000000b4 	strheq	r0, [r0], -r4
    return uxCurrentNumberOfTasks;
 818:	87040e41 	strhi	r0, [r4, -r1, asr #28]
}
 81c:	180e4101 	stmdane	lr, {r0, r8, lr}
 820:	02070d41 	andeq	r0, r7, #4160	@ 0x1040
 824:	41040e49 	tstmi	r4, r9, asr #28
{
 828:	c7410d0d 	strbgt	r0, [r1, -sp, lsl #26]
 82c:	0000000e 	andeq	r0, r0, lr
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 830:	00000024 	andeq	r0, r0, r4, lsr #32
 834:	0000070c 	andeq	r0, r0, ip, lsl #14
 838:	00001f6c 	andeq	r1, r0, ip, ror #30
 83c:	000000b0 	strheq	r0, [r0], -r0	@ <UNPREDICTABLE>
    return &( pxTCB->pcTaskName[ 0 ] );
 840:	87040e41 	strhi	r0, [r4, -r1, asr #28]
}
 844:	180e4101 	stmdane	lr, {r0, r8, lr}
 848:	02070d41 	andeq	r0, r7, #4160	@ 0x1040
 84c:	41040e4e 	tstmi	r4, lr, asr #28
 850:	c7410d0d 	strbgt	r0, [r1, -sp, lsl #26]
{
 854:	0000000e 	andeq	r0, r0, lr
 858:	00000020 	andeq	r0, r0, r0, lsr #32
    vTaskSuspendAll();
 85c:	0000070c 	andeq	r0, r0, ip, lsl #14
    taskENTER_CRITICAL();
 860:	0000201c 	andeq	r2, r0, ip, lsl r0
        xPendedTicks += xTicksToCatchUp;
 864:	000000bc 	strheq	r0, [r0], -ip
 868:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 86c:	41018e02 	tstmi	r1, r2, lsl #28
    taskEXIT_CRITICAL();
 870:	0d41200e 	stcleq	0, cr2, [r1, #-56]	@ 0xffffffc8
    xYieldOccurred = xTaskResumeAll();
 874:	0e4d0207 	cdpeq	2, 4, cr0, cr13, cr7, {0}
 878:	0d0d4108 	stfeqs	f4, [sp, #-32]	@ 0xffffffe0
}
 87c:	0000001c 	andeq	r0, r0, ip, lsl r0
 880:	0000070c 	andeq	r0, r0, ip, lsl #14
 884:	000020d8 	ldrdeq	r2, [r0], -r8
{
 888:	00000040 	andeq	r0, r0, r0, asr #32
 88c:	87040e41 	strhi	r0, [r4, -r1, asr #28]
    BaseType_t xSwitchRequired = pdFALSE;
 890:	070d4101 	streq	r4, [sp, -r1, lsl #2]
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 894:	410d0d51 	tstmi	sp, r1, asr sp
 898:	00000ec7 	andeq	r0, r0, r7, asr #29
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 89c:	0000000c 	andeq	r0, r0, ip
 8a0:	ffffffff 			@ <UNDEFINED> instruction: 0xffffffff
        xTickCount = xConstTickCount;
 8a4:	7c020001 	stcvc	0, cr0, [r2], {1}
 8a8:	000d0c0e 	andeq	r0, sp, lr, lsl #24
        if( xConstTickCount == ( TickType_t ) 0U )
 8ac:	00000024 	andeq	r0, r0, r4, lsr #32
            taskSWITCH_DELAYED_LISTS();
 8b0:	0000089c 	muleq	r0, ip, r8
 8b4:	00002118 	andeq	r2, r0, r8, lsl r1
 8b8:	00000058 	andeq	r0, r0, r8, asr r0
 8bc:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 8c0:	180e4101 	stmdane	lr, {r0, r8, lr}
 8c4:	64070d41 	strvs	r0, [r7], #-3393	@ 0xfffff2bf
 8c8:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 8cc:	0ec7410d 	poleqs	f4, f7, #5.0
 8d0:	00000000 	andeq	r0, r0, r0
        if( xConstTickCount >= xNextTaskUnblockTime )
 8d4:	00000024 	andeq	r0, r0, r4, lsr #32
 8d8:	0000089c 	muleq	r0, ip, r8
 8dc:	00002170 	andeq	r2, r0, r0, ror r1
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8e0:	00000032 	andeq	r0, r0, r2, lsr r0
 8e4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
                    xNextTaskUnblockTime = portMAX_DELAY;
 8e8:	100e4101 	andne	r4, lr, r1, lsl #2
 8ec:	53070d41 	movwpl	r0, #32065	@ 0x7d41
                    break;
 8f0:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8f4:	0ec7410d 	poleqs	f4, f7, #5.0
 8f8:	00000000 	andeq	r0, r0, r0
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8fc:	0000000c 	andeq	r0, r0, ip
 900:	0000089c 	muleq	r0, ip, r8
                    if( xConstTickCount < xItemValue )
 904:	000021a2 	andeq	r2, r0, r2, lsr #3
 908:	00000028 	andeq	r0, r0, r8, lsr #32
                        xNextTaskUnblockTime = xItemValue;
 90c:	0000000c 	andeq	r0, r0, ip
                        break;
 910:	0000089c 	muleq	r0, ip, r8
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 914:	000021ca 	andeq	r2, r0, sl, asr #3
 918:	00000020 	andeq	r0, r0, r0, lsr #32
 91c:	00000020 	andeq	r0, r0, r0, lsr #32
 920:	0000089c 	muleq	r0, ip, r8
 924:	000021ea 	andeq	r2, r0, sl, ror #3
 928:	0000005a 	andeq	r0, r0, sl, asr r0
 92c:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 930:	41018e02 	tstmi	r1, r2, lsl #28
 934:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
 938:	080e6007 	stmdaeq	lr, {r0, r1, r2, sp, lr}
 93c:	000d0d41 	andeq	r0, sp, r1, asr #26
 940:	0000001c 	andeq	r0, r0, ip, lsl r0
 944:	0000089c 	muleq	r0, ip, r8
 948:	00002244 	andeq	r2, r0, r4, asr #4
 94c:	0000000c 	andeq	r0, r0, ip
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 950:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 954:	070d4101 	streq	r4, [sp, -r1, lsl #2]
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 958:	410d0d42 	tstmi	sp, r2, asr #26
 95c:	00000ec7 	andeq	r0, r0, r7, asr #29
 960:	00000024 	andeq	r0, r0, r4, lsr #32
 964:	0000089c 	muleq	r0, ip, r8
 968:	00002250 	andeq	r2, r0, r0, asr r2
 96c:	00000034 	andeq	r0, r0, r4, lsr r0
 970:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 974:	100e4101 	andne	r4, lr, r1, lsl #2
 978:	51070d41 	tstpl	r7, r1, asr #26
 97c:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 980:	0ec7410d 	poleqs	f4, f7, #5.0
 984:	00000000 	andeq	r0, r0, r0
 988:	00000024 	andeq	r0, r0, r4, lsr #32
 98c:	0000089c 	muleq	r0, ip, r8
 990:	00002284 	andeq	r2, r0, r4, lsl #5
 994:	00000034 	andeq	r0, r0, r4, lsr r0
                    prvAddTaskToReadyList( pxTCB );
 998:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 99c:	100e4101 	andne	r4, lr, r1, lsl #2
 9a0:	51070d41 	tstpl	r7, r1, asr #26
 9a4:	0d41040e 	cfstrdeq	mvd0, [r1, #-56]	@ 0xffffffc8
 9a8:	0ec7410d 	poleqs	f4, f7, #5.0
 9ac:	00000000 	andeq	r0, r0, r0
 9b0:	0000000c 	andeq	r0, r0, ip
 9b4:	0000089c 	muleq	r0, ip, r8
 9b8:	000022b8 			@ <UNDEFINED> instruction: 0x000022b8
 9bc:	00000046 	andeq	r0, r0, r6, asr #32
 9c0:	00000020 	andeq	r0, r0, r0, lsr #32
 9c4:	0000089c 	muleq	r0, ip, r8
 9c8:	000022fe 	strdeq	r2, [r0], -lr
 9cc:	00000046 	andeq	r0, r0, r6, asr #32
 9d0:	87080e41 	strhi	r0, [r8, -r1, asr #28]
 9d4:	41018e02 	tstmi	r1, r2, lsl #28
 9d8:	0d41100e 	stcleq	0, cr1, [r1, #-56]	@ 0xffffffc8
 9dc:	080e5b07 	stmdaeq	lr, {r0, r1, r2, r8, r9, fp, ip, lr}
 9e0:	000d0d41 	andeq	r0, sp, r1, asr #26
 9e4:	0000001c 	andeq	r0, r0, ip, lsl r0
 9e8:	0000089c 	muleq	r0, ip, r8
 9ec:	00002344 	andeq	r2, r0, r4, asr #6
 9f0:	00000034 	andeq	r0, r0, r4, lsr r0
 9f4:	87040e41 	strhi	r0, [r4, -r1, asr #28]
 9f8:	070d4101 	streq	r4, [sp, -r1, lsl #2]
 9fc:	410d0d4e 	tstmi	sp, lr, asr #26
 a00:	00000ec7 	andeq	r0, r0, r7, asr #29
